
================================================================================
FILE_BEGIN: next-env.d.ts
TYPE: TS
SIZE: 262 bytes
================================================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


[FILE_END: next-env.d.ts]
################################################################################

================================================================================
FILE_BEGIN: playwright.config.ts
TYPE: TS
SIZE: 974 bytes
================================================================================
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3001',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'chrome-mobile',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'chrome-tablet',
      use: { ...devices['iPad Pro'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3001',
    reuseExistingServer: !process.env.CI,
  },
});


[FILE_END: playwright.config.ts]
################################################################################

================================================================================
FILE_BEGIN: prisma\seed.ts
TYPE: TS
SIZE: 2247 bytes
================================================================================
import { PrismaClient } from '@prisma/client'
import { PrismaPg } from '@prisma/adapter-pg'
import pg from 'pg'

const { Pool } = pg

function createPrismaClient() {
  const connectionString = process.env.DATABASE_URL
  
  if (!connectionString) {
    throw new Error('DATABASE_URL environment variable is not set')
  }
  
  const pool = new Pool({ connectionString })
  const adapter = new PrismaPg(pool)
  
  return new PrismaClient({ adapter })
}

const prisma = createPrismaClient()

const seedProperties = [
  {
    address: '309 E Brandon St',
    city: 'Overton',
    state: 'TX',
    zip: '75684',
    lat: 32.2757,
    lng: -94.9427,
    listPrice: 149900,
    equityGap: 25000,
    sqft: 1700,
    bedrooms: 3,
    bathrooms: 3,
    decision: 'Pass Platinum',
    strategy: 'Section 8',
    rationale: 'Multi-family potential in rental desert; high yield',
    type: 'Multi-family home for sale',
    realtor: null,
    url: null,
    details: null,
    images: [],
    estimatedRent: 0,
    annualTaxes: 0,
    annualInsurance: 0,
    renovationBudget: 0,
    afterRepairValue: 0,
    notes: '',
  },
  {
    address: '2319 Luther St',
    city: 'Tyler',
    state: 'TX',
    zip: '75701',
    lat: 32.3513,
    lng: -95.3011,
    listPrice: 99999,
    equityGap: 125001,
    sqft: 1909,
    bedrooms: 4,
    bathrooms: 2,
    decision: 'Pass Platinum',
    strategy: 'Retail Flip',
    rationale: 'Massive equity gap; tax value $225k vs $100k list',
    type: 'House for sale',
    realtor: null,
    url: null,
    details: null,
    images: [],
    estimatedRent: 0,
    annualTaxes: 0,
    annualInsurance: 0,
    renovationBudget: 0,
    afterRepairValue: 0,
    notes: '',
  },
];

async function main() {
  console.log('Starting seed...');

  // Clear existing properties
  await prisma.property.deleteMany({});
  console.log('Cleared existing properties');

  // Insert properties from the data file
  for (const property of seedProperties) {
    await prisma.property.create({
      data: property,
    });
  }

  console.log(`Seeded ${seedProperties.length} properties`);
}

main()
  .catch((e) => {
    console.error('Seed error:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


[FILE_END: prisma\seed.ts]
################################################################################

================================================================================
FILE_BEGIN: prisma.config.ts
TYPE: TS
SIZE: 403 bytes
================================================================================
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: process.env["DIRECT_URL"] || process.env["DATABASE_URL"],
  },
});


[FILE_END: prisma.config.ts]
################################################################################

================================================================================
FILE_BEGIN: src\app\api\properties\route.ts
TYPE: TS
SIZE: 9574 bytes
================================================================================
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/app/lib/db';
import { prisma } from '@/app/lib/db';
import { 
  addCalculations, 
  serializeProperty,
  PropertyBase,
  PropertyWithCalculations 
} from '@/lib/calculations';

/**
 * GET /api/properties
 * Fetch properties with optional filtering.
 * Returns properties with calculated fields.
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const search = searchParams.get('search');
    const strategy = searchParams.get('strategy');
    const decision = searchParams.get('decision');
    const city = searchParams.get('city');

    // 1. Handle Single Property Fetch
    if (id) {
      const { data, error } = await supabase
        .from('properties')
        .select('*')
        .eq('id', id)
        .single()
      
      if (error || !data) {
        return NextResponse.json(
          { success: false, error: 'Property not found' }, 
          { status: 404 }
        );
      }
      
      // Convert, serialize and add calculations
      const converted = convertSupabaseProperty(data)
      const serialized = serializeProperty(converted);
      // @ts-ignore - serializeProperty intentionally converts Date to string
      const calculated = addCalculations(serialized);
      return NextResponse.json({ success: true, data: calculated });
    }

    // 2. Build query with filters
    let query = supabase.from('properties').select('*')
    
    if (strategy) query = query.eq('strategy', strategy)
    if (decision) query = query.eq('decision', decision)
    if (city) query = query.ilike('city', city)
    
    if (search) {
      query = query.or(`address.ilike.%${search}%,city.ilike.%${search}%,rationale.ilike.%${search}%,details.ilike.%${search}%`)
    }
    
    query = query.order('created_at', { ascending: false })

    // 3. Execute query
    const { data, error } = await query
    
    if (error) {
      console.error('Supabase error:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch properties' }, 
        { status: 500 }
      );
    }

    // 4. Convert, serialize and add calculations
    const converted = (data || []).map(convertSupabaseProperty)
    const serialized = converted.map(serializeProperty) as PropertyBase[];
    const calculated = serialized.map(addCalculations);

    return NextResponse.json({ 
      success: true, 
      data: calculated, 
      count: calculated.length 
    });

  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch properties' }, 
      { status: 500 }
    );
  }
}

// Helper to convert Supabase snake_case to camelCase
function convertSupabaseProperty(prop: any): any {
  return {
    ...prop,
    listPrice: prop.list_price,
    equityGap: prop.equity_gap,
    isOwned: prop.is_owned,
    purchasePrice: prop.purchase_price,
    purchaseDate: prop.purchase_date ? new Date(prop.purchase_date) : null,
    rehabCompleted: prop.rehab_completed ? new Date(prop.rehab_completed) : null,
    isFavorite: prop.is_favorite,
    favoriteNotes: prop.favorite_notes,
    dealScore: prop.deal_score,
    riskLevel: prop.risk_level,
    createdAt: new Date(prop.created_at),
    updatedAt: new Date(prop.updated_at),
  }
}

/**
 * POST /api/properties
 * Create a new property.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { id, createdAt, updatedAt, ...data } = body;

    // Convert camelCase to snake_case for Supabase
    const insertData = {
      address: data.address,
      city: data.city,
      state: data.state || 'TX',
      zip: data.zip || '',
      lat: data.lat || 0,
      lng: data.lng || 0,
      list_price: Number(data.listPrice) || 0,
      equity_gap: data.equityGap || 0,
      sqft: Number(data.sqft) || 0,
      bedrooms: data.bedrooms || 0,
      bathrooms: data.bathrooms || 0,
      decision: data.decision || 'Review',
      strategy: data.strategy || 'None',
      rationale: data.rationale || '',
      type: data.type || 'House for sale',
      realtor: data.realtor || null,
      url: data.url || null,
      details: data.details || null,
      images: data.images || [],
      estimatedRent: Number(data.estimatedRent) || 0,
      annualTaxes: data.annualTaxes || 0,
      annualInsurance: data.annualInsurance || 0,
      renovationBudget: data.renovationBudget || 0,
      afterRepairValue: data.afterRepairValue || 0,
      notes: data.notes || '',
      is_owned: data.isOwned || false,
      purchase_price: data.purchasePrice || 0,
      purchase_date: data.purchaseDate || null,
      rehab_completed: data.rehabCompleted || null,
      is_favorite: data.isFavorite || false,
      favorite_notes: data.favoriteNotes || '',
      deal_score: data.dealScore || 0,
      risk_level: data.riskLevel || 'Medium',
    }

    const { data: newProperty, error } = await supabase
      .from('properties')
      .insert(insertData)
      .select()
      .single()

    if (error) {
      console.error('Supabase insert error:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to create property' }, 
        { status: 500 }
      );
    }

    // Convert, serialize and add calculations
    const converted = convertSupabaseProperty(newProperty)
    const serialized = serializeProperty(converted);
    // @ts-ignore - serializeProperty intentionally converts Date to string
    const calculated = addCalculations(serialized);

    return NextResponse.json({ success: true, data: calculated }, { status: 201 });
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to create property' }, 
      { status: 500 }
    );
  }
}

/**
 * PUT /api/properties
 * Update an existing property.
 */
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { id, createdAt, updatedAt, ...data } = body;

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Property ID is required' }, 
        { status: 400 }
      );
    }

    // Convert camelCase to snake_case for fields that need it
    const updateData: any = {}
    
    if (data.listPrice !== undefined) updateData.list_price = Number(data.listPrice)
    if (data.equityGap !== undefined) updateData.equity_gap = data.equityGap
    if (data.isOwned !== undefined) updateData.is_owned = data.isOwned
    if (data.purchasePrice !== undefined) updateData.purchase_price = data.purchasePrice
    if (data.purchaseDate !== undefined) updateData.purchase_date = data.purchaseDate
    if (data.rehabCompleted !== undefined) updateData.rehab_completed = data.rehabCompleted
    if (data.isFavorite !== undefined) updateData.is_favorite = data.isFavorite
    if (data.favoriteNotes !== undefined) updateData.favorite_notes = data.favoriteNotes
    if (data.dealScore !== undefined) updateData.deal_score = data.dealScore
    if (data.riskLevel !== undefined) updateData.risk_level = data.riskLevel
    
    // Copy over fields that don't need conversion
    const directFields = ['address', 'city', 'state', 'zip', 'lat', 'lng', 'sqft', 
      'bedrooms', 'bathrooms', 'decision', 'strategy', 'rationale', 'type', 
      'realtor', 'url', 'details', 'images', 'estimatedRent', 'annualTaxes', 
      'annualInsurance', 'renovationBudget', 'afterRepairValue', 'notes']
    
    directFields.forEach(field => {
      if (data[field] !== undefined) updateData[field] = data[field]
    })

    const { data: updatedProperty, error } = await supabase
      .from('properties')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      console.error('Supabase update error:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to update property' }, 
        { status: 500 }
      );
    }

    // Convert, serialize and add calculations
    const converted = convertSupabaseProperty(updatedProperty)
    const serialized = serializeProperty(converted);
    // @ts-ignore - serializeProperty intentionally converts Date to string
    const calculated = addCalculations(serialized);

    return NextResponse.json({ success: true, data: calculated });
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to update property' }, 
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/properties
 * Delete a property by ID.
 */
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Property ID is required' }, 
        { status: 400 }
      );
    }

    const { error } = await supabase
      .from('properties')
      .delete()
      .eq('id', id)

    if (error) {
      console.error('Supabase delete error:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to delete property' }, 
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true, message: 'Property deleted successfully' });
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to delete property' }, 
      { status: 500 }
    );
  }
}


[FILE_END: src\app\api\properties\route.ts]
################################################################################

================================================================================
FILE_BEGIN: src\app\lib\db.ts
TYPE: TS
SIZE: 1193 bytes
================================================================================
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Missing Supabase environment variables')
}

// Create a single supabase client for server-side use
export const supabase = createClient(supabaseUrl, supabaseKey)

// Keep prisma export for compatibility but mark as deprecated
// TODO: Migrate all queries to use supabase client
import { PrismaClient } from '../../generated/client'
import { PrismaPg } from '@prisma/adapter-pg'
import { Pool } from 'pg'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

function createPrismaClient() {
  const connectionString = process.env.DATABASE_URL
  
  if (!connectionString) {
    console.warn('DATABASE_URL not set, Prisma client may not work')
    return null as any
  }
  
  const pool = new Pool({ connectionString })
  const adapter = new PrismaPg(pool)
  
  return new PrismaClient({ adapter })
}

export const prisma = globalForPrisma.prisma || createPrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma


[FILE_END: src\app\lib\db.ts]
################################################################################

================================================================================
FILE_BEGIN: src\data\properties.ts
TYPE: TS
SIZE: 7312 bytes
================================================================================
export type Decision = 'Pass Platinum' | 'Pass Gold' | 'Pass Silver' | 'Hard Fail' | 'Caution';
export type Strategy = 'Retail Flip' | 'Section 8' | 'BRRR' | 'Owner Finance' | 'Wholesaling';

export interface Property {
  id: string;
  address: string;
  city: string;
  state: string;
  zip: string;
  lat: number;
  lng: number;
  listPrice: number;
  equityGap: number;
  sqft: number;
  bedrooms: number;
  bathrooms: number;
  decision: Decision;
  strategy: Strategy;
  rationale: string;
  type: string;
  realtor: string;
  url: string;
  details: string;
  // New fields for enhanced functionality
  images: string[];
  estimatedRent: number;
  annualTaxes: number;
  annualInsurance: number;
  renovationBudget: number;
  afterRepairValue: number;
  notes: string;
  createdAt: string;
  updatedAt: string;
}

// Approximate lat/lng coordinates for East Texas cities
const cityCoordinates: Record<string, { lat: number; lng: number }> = {
  'Longview': { lat: 32.5007, lng: -94.7405 },
  'Marshall': { lat: 32.5449, lng: -94.3674 },
  'Kilgore': { lat: 32.3863, lng: -94.8756 },
  'Tyler': { lat: 32.3513, lng: -95.3011 },
  'Gilmer': { lat: 32.7288, lng: -94.9424 },
  'Athens': { lat: 32.2049, lng: -95.8550 },
  'Quitman': { lat: 32.8479, lng: -95.4458 },
  'Henderson': { lat: 32.1532, lng: -94.7997 },
  'Jacksonville': { lat: 31.9635, lng: -95.2705 },
  'Mineola': { lat: 32.6626, lng: -95.4891 },
  'Tatum': { lat: 32.5868, lng: -94.5199 },
  'Hawkins': { lat: 32.5885, lng: -95.2044 },
  'Bullard': { lat: 32.1388, lng: -95.3219 },
  'Whitehouse': { lat: 32.2207, lng: -95.2219 },
  'Flint': { lat: 32.2040, lng: -95.3491 },
  'Lindale': { lat: 32.5157, lng: -95.4094 },
  'Rusk': { lat: 31.7957, lng: -95.1505 },
  'Overton': { lat: 32.2757, lng: -94.9427 },
  'Arp': { lat: 32.2274, lng: -95.0544 },
  'Chandler': { lat: 32.3032, lng: -95.4794 },
  'Frankston': { lat: 32.0524, lng: -95.5058 },
  'Avinger': { lat: 32.5457, lng: -94.5488 },
  'Laneville': { lat: 32.2346, lng: -94.8852 },
  'Ore City': { lat: 32.7999, lng: -94.7216 },
  'Big Sandy': { lat: 32.5818, lng: -95.0769 },
  'Winona': { lat: 32.3299, lng: -95.1172 },
  'Diana': { lat: 32.7010, lng: -94.7155 },
  'Brownsboro': { lat: 32.3018, lng: -95.6133 },
  'Mount Enterprise': { lat: 31.9310, lng: -94.6841 },
  'Troup': { lat: 32.1507, lng: -95.1227 },
  'Mt Enterprise': { lat: 31.9310, lng: -94.6841 },
};

// Helper to add small random offset for map visibility
const addOffset = (coord: number, offset: number = 0.01): number => {
  return coord + (Math.random() - 0.5) * offset;
};

// Parse specs string like "3bd/3ba/1700sqft"
const parseSpecs = (specs: string): { bedrooms: number; bathrooms: number; sqft: number } => {
  const bedroomMatch = specs.match(/(\d+)bd/);
  const bathroomMatch = specs.match(/(\d+\.?\d*)ba/);
  const sqftMatch = specs.match(/(\d+)sqft/);

  return {
    bedrooms: bedroomMatch ? parseInt(bedroomMatch[1]) : 0,
    bathrooms: bathroomMatch ? parseFloat(bathroomMatch[1]) : 0,
    sqft: sqftMatch ? parseInt(sqftMatch[1]) : 0,
  };
};

// Parse price string like "$149,900" or "Auction"
const parsePrice = (priceStr: string): number => {
  if (priceStr.toLowerCase() === 'auction') return 0;
  const cleaned = priceStr.replace(/[$,]/g, '');
  return parseInt(cleaned) || 0;
};

// Map CSV decision to our Decision type
const mapDecision = (decision: string): Decision => {
  const upper = decision.toUpperCase();
  if (upper.includes('PLATINUM')) return 'Pass Platinum';
  if (upper.includes('GOLD')) return 'Pass Gold';
  if (upper.includes('SILVER')) return 'Pass Silver';
  if (upper.includes('HARD_FAIL') || upper.includes('HARD FAIL')) return 'Hard Fail';
  if (upper === 'CAUTION') return 'Caution';
  return 'Pass Gold'; // Default for "PASS" without level
};

// Map CSV strategy to our Strategy type (choose primary)
const mapStrategy = (strategy: string): Strategy => {
  const upper = strategy.toUpperCase();
  if (upper.includes('RETAIL FLIP')) return 'Retail Flip';
  if (upper.includes('SECTION 8')) return 'Section 8';
  if (upper.includes('BRRR')) return 'BRRR';
  if (upper.includes('OWNER FINANCE')) return 'Owner Finance';
  if (upper.includes('WHOLESALING') || upper.includes('WHOLETAIL')) return 'Wholesaling';
  return 'Retail Flip'; // Default
};

// Default values for new Property fields
const defaultProps = {
  images: [] as string[],
  estimatedRent: 0,
  annualTaxes: 0,
  annualInsurance: 0,
  renovationBudget: 0,
  afterRepairValue: 0,
  notes: '',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
};

// CSV data parsed and converted to Property objects
export const properties: Property[] = [];

// Helper functions for data analysis
export const getPricePerSqft = (property: Property): number => {
  if (property.sqft <= 0) return 0;
  return property.listPrice / property.sqft;
};

export const getPricePerDoor = (property: Property): number => {
  if (property.bedrooms <= 0) return 0;
  return property.listPrice / property.bedrooms;
};

// Financial calculation functions
export const calculateCapRate = (property: Property): number => {
  if (property.listPrice <= 0) return 0;
  const annualRent = property.estimatedRent * 12;
  const noi = annualRent - property.annualTaxes - property.annualInsurance;
  return (noi / property.listPrice) * 100;
};

export const calculateCashOnCashReturn = (
  property: Property, 
  downPaymentPercent: number = 25,
  interestRate: number = 7.5
): number => {
  const downPayment = property.listPrice * (downPaymentPercent / 100);
  const loanAmount = property.listPrice - downPayment;
  const monthlyPayment = (loanAmount * (interestRate / 100 / 12)) / (1 - Math.pow(1 + interestRate / 100 / 12, -360));
  const annualMortgage = monthlyPayment * 12;
  const annualRent = property.estimatedRent * 12;
  const noi = annualRent - property.annualTaxes - property.annualInsurance;
  const annualCashFlow = noi - annualMortgage;
  const totalCashInvested = downPayment + property.renovationBudget + property.annualTaxes + property.annualInsurance;
  if (totalCashInvested <= 0) return 0;
  return (annualCashFlow / totalCashInvested) * 100;
};

export const calculateMAO = (
  property: Property,
  targetProfitPercent: number = 20
): number => {
  if (property.afterRepairValue <= 0) return 0;
  const mao = property.afterRepairValue * (1 - targetProfitPercent / 100) - property.renovationBudget;
  return Math.max(0, mao);
};

export const calculateOnePercentRule = (property: Property): boolean => {
  if (property.listPrice <= 0) return false;
  const monthlyRent = property.estimatedRent;
  return monthlyRent >= property.listPrice * 0.01;
};

export const calculateGrossYield = (property: Property): number => {
  if (property.listPrice <= 0) return 0;
  const annualRent = property.estimatedRent * 12;
  return (annualRent / property.listPrice) * 100;
};

export const getDecisionColor = (decision: Decision): string => {
  switch (decision) {
    case 'Pass Platinum':
      return '#10b981'; // green
    case 'Pass Gold':
      return '#f59e0b'; // yellow/gold
    case 'Pass Silver':
      return '#f97316'; // orange
    case 'Hard Fail':
      return '#ef4444'; // red
    case 'Caution':
      return '#8b5cf6'; // purple
    default:
      return '#64748b'; // gray
  }
};


[FILE_END: src\data\properties.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\browser.ts
TYPE: TS
SIZE: 1433 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma-related types and utilities in a browser. 
 * Use it to get access to models, enums, and input types.
 * 
 * This file does not contain a `PrismaClient` class, nor several other helpers that are intended as server-side only.
 * See `client.ts` for the standard, server-side entry point.
 *
 * 游릭 You can import this file directly.
 */

import * as Prisma from './internal/prismaNamespaceBrowser'
export { Prisma }
export * as $Enums from './enums'
export * from './enums';
/**
 * Model Property
 * 
 */
export type Property = Prisma.PropertyModel
/**
 * Model Expense
 * 
 */
export type Expense = Prisma.ExpenseModel
/**
 * Model Task
 * 
 */
export type Task = Prisma.TaskModel
/**
 * Model RehabItem
 * 
 */
export type RehabItem = Prisma.RehabItemModel
/**
 * Model MarketData
 * 
 */
export type MarketData = Prisma.MarketDataModel
/**
 * Model RentComp
 * 
 */
export type RentComp = Prisma.RentCompModel
/**
 * Model Projection
 * 
 */
export type Projection = Prisma.ProjectionModel
/**
 * Model TimelineEvent
 * 
 */
export type TimelineEvent = Prisma.TimelineEventModel
/**
 * Model Comment
 * 
 */
export type Comment = Prisma.CommentModel
/**
 * Model Document
 * 
 */
export type Document = Prisma.DocumentModel


[FILE_END: src\generated\browser.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\client.ts
TYPE: TS
SIZE: 2314 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.
 *
 * 游릭 You can import this file directly.
 */

import * as process from 'node:process'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
globalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))

import * as runtime from "@prisma/client/runtime/client"
import * as $Enums from "./enums"
import * as $Class from "./internal/class"
import * as Prisma from "./internal/prismaNamespace"

export * as $Enums from './enums'
export * from "./enums"
/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Properties
 * const properties = await prisma.property.findMany()
 * ```
 * 
 * Read more in our [docs](https://pris.ly/d/client).
 */
export const PrismaClient = $Class.getPrismaClientClass()
export type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions["omit"] = Prisma.PrismaClientOptions["omit"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>
export { Prisma }

/**
 * Model Property
 * 
 */
export type Property = Prisma.PropertyModel
/**
 * Model Expense
 * 
 */
export type Expense = Prisma.ExpenseModel
/**
 * Model Task
 * 
 */
export type Task = Prisma.TaskModel
/**
 * Model RehabItem
 * 
 */
export type RehabItem = Prisma.RehabItemModel
/**
 * Model MarketData
 * 
 */
export type MarketData = Prisma.MarketDataModel
/**
 * Model RentComp
 * 
 */
export type RentComp = Prisma.RentCompModel
/**
 * Model Projection
 * 
 */
export type Projection = Prisma.ProjectionModel
/**
 * Model TimelineEvent
 * 
 */
export type TimelineEvent = Prisma.TimelineEventModel
/**
 * Model Comment
 * 
 */
export type Comment = Prisma.CommentModel
/**
 * Model Document
 * 
 */
export type Document = Prisma.DocumentModel


[FILE_END: src\generated\client.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\commonInputTypes.ts
TYPE: TS
SIZE: 19996 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports various common sort, input & filter types that are not directly linked to a particular model.
 *
 * 游릭 You can import this file directly.
 */

import type * as runtime from "@prisma/client/runtime/client"
import * as $Enums from "./enums"
import type * as Prisma from "./internal/prismaNamespace"


export type StringFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringFilter<$PrismaModel> | string
}

export type FloatFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatFilter<$PrismaModel> | number
}

export type IntFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntFilter<$PrismaModel> | number
}

export type StringNullableFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringNullableFilter<$PrismaModel> | string | null
}

export type BoolFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolFilter<$PrismaModel> | boolean
}

export type DateTimeNullableFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
}

export type DateTimeFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeFilter<$PrismaModel> | Date | string
}

export type SortOrderInput = {
  sort: Prisma.SortOrder
  nulls?: Prisma.NullsOrder
}

export type StringWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringWithAggregatesFilter<$PrismaModel> | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedStringFilter<$PrismaModel>
  _max?: Prisma.NestedStringFilter<$PrismaModel>
}

export type FloatWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedFloatFilter<$PrismaModel>
  _min?: Prisma.NestedFloatFilter<$PrismaModel>
  _max?: Prisma.NestedFloatFilter<$PrismaModel>
}

export type IntWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedIntFilter<$PrismaModel>
  _max?: Prisma.NestedIntFilter<$PrismaModel>
}

export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedStringNullableFilter<$PrismaModel>
  _max?: Prisma.NestedStringNullableFilter<$PrismaModel>
}

export type BoolWithAggregatesFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedBoolFilter<$PrismaModel>
  _max?: Prisma.NestedBoolFilter<$PrismaModel>
}

export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
}

export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeFilter<$PrismaModel>
}

export type NestedStringFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringFilter<$PrismaModel> | string
}

export type NestedFloatFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatFilter<$PrismaModel> | number
}

export type NestedIntFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntFilter<$PrismaModel> | number
}

export type NestedStringNullableFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringNullableFilter<$PrismaModel> | string | null
}

export type NestedBoolFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolFilter<$PrismaModel> | boolean
}

export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
}

export type NestedDateTimeFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeFilter<$PrismaModel> | Date | string
}

export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringWithAggregatesFilter<$PrismaModel> | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedStringFilter<$PrismaModel>
  _max?: Prisma.NestedStringFilter<$PrismaModel>
}

export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedFloatFilter<$PrismaModel>
  _min?: Prisma.NestedFloatFilter<$PrismaModel>
  _max?: Prisma.NestedFloatFilter<$PrismaModel>
}

export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedIntFilter<$PrismaModel>
  _max?: Prisma.NestedIntFilter<$PrismaModel>
}

export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedStringNullableFilter<$PrismaModel>
  _max?: Prisma.NestedStringNullableFilter<$PrismaModel>
}

export type NestedIntNullableFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel> | null
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntNullableFilter<$PrismaModel> | number | null
}

export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedBoolFilter<$PrismaModel>
  _max?: Prisma.NestedBoolFilter<$PrismaModel>
}

export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
}

export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeFilter<$PrismaModel>
}




[FILE_END: src\generated\commonInputTypes.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\enums.ts
TYPE: TS
SIZE: 336 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
* This file exports all enum related types from the schema.
*
* 游릭 You can import this file directly.
*/



// This file is empty because there are no enums in the schema.
export {}


[FILE_END: src\generated\enums.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\internal\class.ts
TYPE: TS
SIZE: 77068 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * 游띔 Under no circumstances should you import this file directly! 游띔
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "./prismaNamespace"


const config: runtime.GetPrismaClientConfig = {
  "previewFeatures": [],
  "clientVersion": "7.4.0",
  "engineVersion": "ab56fe763f921d033a6c195e7ddeb3e255bdbb57",
  "activeProvider": "postgresql",
  "inlineSchema": "generator client {\n  provider = \"prisma-client\"\n  output   = \"../src/generated\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n}\n\nmodel Property {\n  id        String  @id @default(uuid())\n  address   String\n  city      String\n  state     String  @default(\"TX\")\n  zip       String  @default(\"\")\n  lat       Float   @default(0)\n  lng       Float   @default(0)\n  listPrice Int     @map(\"list_price\")\n  equityGap Int     @default(0) @map(\"equity_gap\")\n  sqft      Int     @default(0)\n  bedrooms  Int     @default(0)\n  bathrooms Float   @default(0)\n  decision  String  @default(\"Review\")\n  strategy  String  @default(\"None\")\n  rationale String  @default(\"\")\n  type      String  @default(\"House for sale\")\n  realtor   String?\n  url       String?\n  details   String?\n\n  // New fields to match your app logic\n  images           String[]  @default([])\n  estimatedRent    Int       @default(0)\n  annualTaxes      Int       @default(0)\n  annualInsurance  Int       @default(0)\n  renovationBudget Int       @default(0)\n  afterRepairValue Int       @default(0)\n  notes            String    @default(\"\")\n  isOwned          Boolean   @default(false) @map(\"is_owned\")\n  purchasePrice    Int       @default(0) @map(\"purchase_price\")\n  purchaseDate     DateTime? @map(\"purchase_date\")\n  rehabCompleted   DateTime? @map(\"rehab_completed\")\n  isFavorite       Boolean   @default(false) @map(\"is_favorite\")\n  favoriteNotes    String    @default(\"\") @map(\"favorite_notes\")\n  dealScore        Float     @default(0) @map(\"deal_score\")\n  riskLevel        String    @default(\"Medium\") @map(\"risk_level\")\n\n  createdAt DateTime @default(now()) @map(\"created_at\")\n  updatedAt DateTime @updatedAt @map(\"updated_at\")\n\n  // Relations\n  expenses       Expense[]\n  tasks          Task[]\n  rehabItems     RehabItem[]\n  marketData     MarketData[]\n  rentComps      RentComp[]\n  projections    Projection[]\n  timelineEvents TimelineEvent[]\n  comments       Comment[]\n  documents      Document[]\n\n  @@map(\"properties\")\n}\n\nmodel Expense {\n  id          String   @id @default(uuid())\n  propertyId  String\n  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  category    String\n  amount      Float\n  description String?\n  createdAt   DateTime @default(now())\n\n  @@map(\"expenses\")\n}\n\nmodel Task {\n  id          String   @id @default(uuid())\n  propertyId  String\n  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  title       String\n  isCompleted Boolean  @default(false)\n  createdAt   DateTime @default(now())\n\n  @@map(\"tasks\")\n}\n\nmodel RehabItem {\n  id          String   @id @default(uuid())\n  propertyId  String\n  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  category    String\n  item        String\n  quantity    Int      @default(1)\n  unitCost    Float    @map(\"unit_cost\")\n  totalCost   Float    @map(\"total_cost\")\n  isCompleted Boolean  @default(false)\n  notes       String   @default(\"\")\n  createdAt   DateTime @default(now()) @map(\"created_at\")\n  updatedAt   DateTime @updatedAt @map(\"updated_at\")\n\n  @@map(\"rehab_items\")\n}\n\nmodel MarketData {\n  id              String   @id @default(uuid())\n  propertyId      String\n  property        Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  neighborhood    String\n  avgDaysOnMarket Int      @default(0) @map(\"avg_days_on_market\")\n  avgPricePerSqft Float    @default(0) @map(\"avg_price_per_sqft\")\n  priceTrend      Float    @default(0) @map(\"price_trend\")\n  inventory       Int      @default(0)\n  dataDate        DateTime @default(now()) @map(\"data_date\")\n\n  @@map(\"market_data\")\n}\n\nmodel RentComp {\n  id         String   @id @default(uuid())\n  propertyId String\n  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  address    String\n  rentAmount Int      @map(\"rent_amount\")\n  sqft       Int      @default(0)\n  bedrooms   Int      @default(0)\n  bathrooms  Float    @default(0)\n  distance   Float\n  source     String   @default(\"Manual\")\n  createdAt  DateTime @default(now()) @map(\"created_at\")\n\n  @@map(\"rent_comps\")\n}\n\nmodel Projection {\n  id                String   @id @default(uuid())\n  propertyId        String\n  property          Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  year              Int\n  monthlyRent       Float    @map(\"monthly_rent\")\n  vacancyRate       Float    @default(0.05) @map(\"vacancy_rate\")\n  operatingExpenses Float    @map(\"operating_expenses\")\n  mortgagePayment   Float    @map(\"mortgage_payment\")\n  cashFlow          Float    @map(\"cash_flow\")\n  equityBuild       Float    @map(\"equity_build\")\n  totalReturn       Float    @map(\"total_return\")\n  createdAt         DateTime @default(now()) @map(\"created_at\")\n\n  @@map(\"projections\")\n}\n\nmodel TimelineEvent {\n  id          String    @id @default(uuid())\n  propertyId  String\n  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  title       String\n  description String    @default(\"\")\n  eventType   String    @map(\"event_type\")\n  startDate   DateTime  @map(\"start_date\")\n  endDate     DateTime? @map(\"end_date\")\n  isCompleted Boolean   @default(false)\n  assignedTo  String?   @map(\"assigned_to\")\n  createdAt   DateTime  @default(now()) @map(\"created_at\")\n\n  @@map(\"timeline_events\")\n}\n\nmodel Comment {\n  id         String   @id @default(uuid())\n  propertyId String\n  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  userId     String   @map(\"user_id\")\n  userName   String   @map(\"user_name\")\n  content    String\n  createdAt  DateTime @default(now()) @map(\"created_at\")\n\n  @@map(\"comments\")\n}\n\nmodel Document {\n  id         String   @id @default(uuid())\n  propertyId String\n  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)\n  fileName   String   @map(\"file_name\")\n  fileUrl    String   @map(\"file_url\")\n  fileType   String   @map(\"file_type\")\n  category   String\n  uploadedBy String   @map(\"uploaded_by\")\n  createdAt  DateTime @default(now()) @map(\"created_at\")\n\n  @@map(\"documents\")\n}\n",
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  },
  "parameterizationSchema": {
    "strings": [],
    "graph": ""
  }
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"Property\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"address\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"city\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"state\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"zip\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"lat\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"lng\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"listPrice\",\"kind\":\"scalar\",\"type\":\"Int\",\"dbName\":\"list_price\"},{\"name\":\"equityGap\",\"kind\":\"scalar\",\"type\":\"Int\",\"dbName\":\"equity_gap\"},{\"name\":\"sqft\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"bedrooms\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"bathrooms\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"decision\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"strategy\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"rationale\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"type\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"realtor\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"url\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"details\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"images\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"estimatedRent\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"annualTaxes\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"annualInsurance\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"renovationBudget\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"afterRepairValue\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"notes\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"isOwned\",\"kind\":\"scalar\",\"type\":\"Boolean\",\"dbName\":\"is_owned\"},{\"name\":\"purchasePrice\",\"kind\":\"scalar\",\"type\":\"Int\",\"dbName\":\"purchase_price\"},{\"name\":\"purchaseDate\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"purchase_date\"},{\"name\":\"rehabCompleted\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"rehab_completed\"},{\"name\":\"isFavorite\",\"kind\":\"scalar\",\"type\":\"Boolean\",\"dbName\":\"is_favorite\"},{\"name\":\"favoriteNotes\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"favorite_notes\"},{\"name\":\"dealScore\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"deal_score\"},{\"name\":\"riskLevel\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"risk_level\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"expenses\",\"kind\":\"object\",\"type\":\"Expense\",\"relationName\":\"ExpenseToProperty\"},{\"name\":\"tasks\",\"kind\":\"object\",\"type\":\"Task\",\"relationName\":\"PropertyToTask\"},{\"name\":\"rehabItems\",\"kind\":\"object\",\"type\":\"RehabItem\",\"relationName\":\"PropertyToRehabItem\"},{\"name\":\"marketData\",\"kind\":\"object\",\"type\":\"MarketData\",\"relationName\":\"MarketDataToProperty\"},{\"name\":\"rentComps\",\"kind\":\"object\",\"type\":\"RentComp\",\"relationName\":\"PropertyToRentComp\"},{\"name\":\"projections\",\"kind\":\"object\",\"type\":\"Projection\",\"relationName\":\"ProjectionToProperty\"},{\"name\":\"timelineEvents\",\"kind\":\"object\",\"type\":\"TimelineEvent\",\"relationName\":\"PropertyToTimelineEvent\"},{\"name\":\"comments\",\"kind\":\"object\",\"type\":\"Comment\",\"relationName\":\"CommentToProperty\"},{\"name\":\"documents\",\"kind\":\"object\",\"type\":\"Document\",\"relationName\":\"DocumentToProperty\"}],\"dbName\":\"properties\"},\"Expense\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"ExpenseToProperty\"},{\"name\":\"category\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"amount\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":\"expenses\"},\"Task\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"PropertyToTask\"},{\"name\":\"title\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"isCompleted\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":\"tasks\"},\"RehabItem\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"PropertyToRehabItem\"},{\"name\":\"category\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"item\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"quantity\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"unitCost\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"unit_cost\"},{\"name\":\"totalCost\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"total_cost\"},{\"name\":\"isCompleted\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"notes\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"}],\"dbName\":\"rehab_items\"},\"MarketData\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"MarketDataToProperty\"},{\"name\":\"neighborhood\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"avgDaysOnMarket\",\"kind\":\"scalar\",\"type\":\"Int\",\"dbName\":\"avg_days_on_market\"},{\"name\":\"avgPricePerSqft\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"avg_price_per_sqft\"},{\"name\":\"priceTrend\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"price_trend\"},{\"name\":\"inventory\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"dataDate\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"data_date\"}],\"dbName\":\"market_data\"},\"RentComp\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"PropertyToRentComp\"},{\"name\":\"address\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"rentAmount\",\"kind\":\"scalar\",\"type\":\"Int\",\"dbName\":\"rent_amount\"},{\"name\":\"sqft\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"bedrooms\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"bathrooms\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"distance\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"source\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"}],\"dbName\":\"rent_comps\"},\"Projection\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"ProjectionToProperty\"},{\"name\":\"year\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"monthlyRent\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"monthly_rent\"},{\"name\":\"vacancyRate\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"vacancy_rate\"},{\"name\":\"operatingExpenses\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"operating_expenses\"},{\"name\":\"mortgagePayment\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"mortgage_payment\"},{\"name\":\"cashFlow\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"cash_flow\"},{\"name\":\"equityBuild\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"equity_build\"},{\"name\":\"totalReturn\",\"kind\":\"scalar\",\"type\":\"Float\",\"dbName\":\"total_return\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"}],\"dbName\":\"projections\"},\"TimelineEvent\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"PropertyToTimelineEvent\"},{\"name\":\"title\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"eventType\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"event_type\"},{\"name\":\"startDate\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"start_date\"},{\"name\":\"endDate\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"end_date\"},{\"name\":\"isCompleted\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"assignedTo\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"assigned_to\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"}],\"dbName\":\"timeline_events\"},\"Comment\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"CommentToProperty\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"user_id\"},{\"name\":\"userName\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"user_name\"},{\"name\":\"content\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"}],\"dbName\":\"comments\"},\"Document\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"propertyId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"property\",\"kind\":\"object\",\"type\":\"Property\",\"relationName\":\"DocumentToProperty\"},{\"name\":\"fileName\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"file_name\"},{\"name\":\"fileUrl\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"file_url\"},{\"name\":\"fileType\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"file_type\"},{\"name\":\"category\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"uploadedBy\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"uploaded_by\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"}],\"dbName\":\"documents\"}},\"enums\":{},\"types\":{}}")
config.parameterizationSchema = {
  strings: JSON.parse("[\"where\",\"orderBy\",\"cursor\",\"property\",\"expenses\",\"tasks\",\"rehabItems\",\"marketData\",\"rentComps\",\"projections\",\"timelineEvents\",\"comments\",\"documents\",\"_count\",\"Property.findUnique\",\"Property.findUniqueOrThrow\",\"Property.findFirst\",\"Property.findFirstOrThrow\",\"Property.findMany\",\"data\",\"Property.createOne\",\"Property.createMany\",\"Property.createManyAndReturn\",\"Property.updateOne\",\"Property.updateMany\",\"Property.updateManyAndReturn\",\"create\",\"update\",\"Property.upsertOne\",\"Property.deleteOne\",\"Property.deleteMany\",\"having\",\"_avg\",\"_sum\",\"_min\",\"_max\",\"Property.groupBy\",\"Property.aggregate\",\"Expense.findUnique\",\"Expense.findUniqueOrThrow\",\"Expense.findFirst\",\"Expense.findFirstOrThrow\",\"Expense.findMany\",\"Expense.createOne\",\"Expense.createMany\",\"Expense.createManyAndReturn\",\"Expense.updateOne\",\"Expense.updateMany\",\"Expense.updateManyAndReturn\",\"Expense.upsertOne\",\"Expense.deleteOne\",\"Expense.deleteMany\",\"Expense.groupBy\",\"Expense.aggregate\",\"Task.findUnique\",\"Task.findUniqueOrThrow\",\"Task.findFirst\",\"Task.findFirstOrThrow\",\"Task.findMany\",\"Task.createOne\",\"Task.createMany\",\"Task.createManyAndReturn\",\"Task.updateOne\",\"Task.updateMany\",\"Task.updateManyAndReturn\",\"Task.upsertOne\",\"Task.deleteOne\",\"Task.deleteMany\",\"Task.groupBy\",\"Task.aggregate\",\"RehabItem.findUnique\",\"RehabItem.findUniqueOrThrow\",\"RehabItem.findFirst\",\"RehabItem.findFirstOrThrow\",\"RehabItem.findMany\",\"RehabItem.createOne\",\"RehabItem.createMany\",\"RehabItem.createManyAndReturn\",\"RehabItem.updateOne\",\"RehabItem.updateMany\",\"RehabItem.updateManyAndReturn\",\"RehabItem.upsertOne\",\"RehabItem.deleteOne\",\"RehabItem.deleteMany\",\"RehabItem.groupBy\",\"RehabItem.aggregate\",\"MarketData.findUnique\",\"MarketData.findUniqueOrThrow\",\"MarketData.findFirst\",\"MarketData.findFirstOrThrow\",\"MarketData.findMany\",\"MarketData.createOne\",\"MarketData.createMany\",\"MarketData.createManyAndReturn\",\"MarketData.updateOne\",\"MarketData.updateMany\",\"MarketData.updateManyAndReturn\",\"MarketData.upsertOne\",\"MarketData.deleteOne\",\"MarketData.deleteMany\",\"MarketData.groupBy\",\"MarketData.aggregate\",\"RentComp.findUnique\",\"RentComp.findUniqueOrThrow\",\"RentComp.findFirst\",\"RentComp.findFirstOrThrow\",\"RentComp.findMany\",\"RentComp.createOne\",\"RentComp.createMany\",\"RentComp.createManyAndReturn\",\"RentComp.updateOne\",\"RentComp.updateMany\",\"RentComp.updateManyAndReturn\",\"RentComp.upsertOne\",\"RentComp.deleteOne\",\"RentComp.deleteMany\",\"RentComp.groupBy\",\"RentComp.aggregate\",\"Projection.findUnique\",\"Projection.findUniqueOrThrow\",\"Projection.findFirst\",\"Projection.findFirstOrThrow\",\"Projection.findMany\",\"Projection.createOne\",\"Projection.createMany\",\"Projection.createManyAndReturn\",\"Projection.updateOne\",\"Projection.updateMany\",\"Projection.updateManyAndReturn\",\"Projection.upsertOne\",\"Projection.deleteOne\",\"Projection.deleteMany\",\"Projection.groupBy\",\"Projection.aggregate\",\"TimelineEvent.findUnique\",\"TimelineEvent.findUniqueOrThrow\",\"TimelineEvent.findFirst\",\"TimelineEvent.findFirstOrThrow\",\"TimelineEvent.findMany\",\"TimelineEvent.createOne\",\"TimelineEvent.createMany\",\"TimelineEvent.createManyAndReturn\",\"TimelineEvent.updateOne\",\"TimelineEvent.updateMany\",\"TimelineEvent.updateManyAndReturn\",\"TimelineEvent.upsertOne\",\"TimelineEvent.deleteOne\",\"TimelineEvent.deleteMany\",\"TimelineEvent.groupBy\",\"TimelineEvent.aggregate\",\"Comment.findUnique\",\"Comment.findUniqueOrThrow\",\"Comment.findFirst\",\"Comment.findFirstOrThrow\",\"Comment.findMany\",\"Comment.createOne\",\"Comment.createMany\",\"Comment.createManyAndReturn\",\"Comment.updateOne\",\"Comment.updateMany\",\"Comment.updateManyAndReturn\",\"Comment.upsertOne\",\"Comment.deleteOne\",\"Comment.deleteMany\",\"Comment.groupBy\",\"Comment.aggregate\",\"Document.findUnique\",\"Document.findUniqueOrThrow\",\"Document.findFirst\",\"Document.findFirstOrThrow\",\"Document.findMany\",\"Document.createOne\",\"Document.createMany\",\"Document.createManyAndReturn\",\"Document.updateOne\",\"Document.updateMany\",\"Document.updateManyAndReturn\",\"Document.upsertOne\",\"Document.deleteOne\",\"Document.deleteMany\",\"Document.groupBy\",\"Document.aggregate\",\"AND\",\"OR\",\"NOT\",\"id\",\"propertyId\",\"fileName\",\"fileUrl\",\"fileType\",\"category\",\"uploadedBy\",\"createdAt\",\"equals\",\"in\",\"notIn\",\"lt\",\"lte\",\"gt\",\"gte\",\"not\",\"contains\",\"startsWith\",\"endsWith\",\"userId\",\"userName\",\"content\",\"title\",\"description\",\"eventType\",\"startDate\",\"endDate\",\"isCompleted\",\"assignedTo\",\"year\",\"monthlyRent\",\"vacancyRate\",\"operatingExpenses\",\"mortgagePayment\",\"cashFlow\",\"equityBuild\",\"totalReturn\",\"address\",\"rentAmount\",\"sqft\",\"bedrooms\",\"bathrooms\",\"distance\",\"source\",\"neighborhood\",\"avgDaysOnMarket\",\"avgPricePerSqft\",\"priceTrend\",\"inventory\",\"dataDate\",\"item\",\"quantity\",\"unitCost\",\"totalCost\",\"notes\",\"updatedAt\",\"amount\",\"city\",\"state\",\"zip\",\"lat\",\"lng\",\"listPrice\",\"equityGap\",\"decision\",\"strategy\",\"rationale\",\"type\",\"realtor\",\"url\",\"details\",\"images\",\"estimatedRent\",\"annualTaxes\",\"annualInsurance\",\"renovationBudget\",\"afterRepairValue\",\"isOwned\",\"purchasePrice\",\"purchaseDate\",\"rehabCompleted\",\"isFavorite\",\"favoriteNotes\",\"dealScore\",\"riskLevel\",\"has\",\"hasEvery\",\"hasSome\",\"every\",\"some\",\"none\",\"is\",\"isNot\",\"connectOrCreate\",\"upsert\",\"createMany\",\"set\",\"disconnect\",\"delete\",\"connect\",\"updateMany\",\"deleteMany\",\"push\",\"increment\",\"decrement\",\"multiply\",\"divide\"]"),
  graph: "zAReoAEwBAAAtgIAIAUAALcCACAGAAC4AgAgBwAAuQIAIAgAALoCACAJAAC7AgAgCgAAvAIAIAsAAL0CACAMAAC-AgAgtgEAAK4CADC3AQAAMQAQuAEAAK4CADC5AQEAAAABwAFAALUCACHeAQEArwIAIeABAgCxAgAh4QECALECACHiAQgAsAIAIe8BAQCvAgAh8AFAALUCACHyAQEArwIAIfMBAQCvAgAh9AEBAK8CACH1AQgAsAIAIfYBCACwAgAh9wECALECACH4AQIAsQIAIfkBAQCvAgAh-gEBAK8CACH7AQEArwIAIfwBAQCvAgAh_QEBALICACH-AQEAsgIAIf8BAQCyAgAhgAIAAK0CACCBAgIAsQIAIYICAgCxAgAhgwICALECACGEAgIAsQIAIYUCAgCxAgAhhgIgALMCACGHAgIAsQIAIYgCQAC0AgAhiQJAALQCACGKAiAAswIAIYsCAQCvAgAhjAIIALACACGNAgEArwIAIQEAAAABACAKAwAAwAIAILYBAADIAgAwtwEAAAMAELgBAADIAgAwuQEBAK8CACG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHQAQEAsgIAIfEBCACwAgAhAgMAAJYEACDQAQAA1QIAIAoDAADAAgAgtgEAAMgCADC3AQAAAwAQuAEAAMgCADC5AQEAAAABugEBAK8CACG-AQEArwIAIcABQAC1AgAh0AEBALICACHxAQgAsAIAIQMAAAADACABAAAEADACAAAFACAJAwAAwAIAILYBAADHAgAwtwEAAAcAELgBAADHAgAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAhzwEBAK8CACHUASAAswIAIQEDAACWBAAgCQMAAMACACC2AQAAxwIAMLcBAAAHABC4AQAAxwIAMLkBAQAAAAG6AQEArwIAIcABQAC1AgAhzwEBAK8CACHUASAAswIAIQMAAAAHACABAAAIADACAAAJACAPAwAAwAIAILYBAADGAgAwtwEAAAsAELgBAADGAgAwuQEBAK8CACG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHUASAAswIAIesBAQCvAgAh7AECALECACHtAQgAsAIAIe4BCACwAgAh7wEBAK8CACHwAUAAtQIAIQEDAACWBAAgDwMAAMACACC2AQAAxgIAMLcBAAALABC4AQAAxgIAMLkBAQAAAAG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHUASAAswIAIesBAQCvAgAh7AECALECACHtAQgAsAIAIe4BCACwAgAh7wEBAK8CACHwAUAAtQIAIQMAAAALACABAAAMADACAAANACAMAwAAwAIAILYBAADFAgAwtwEAAA8AELgBAADFAgAwuQEBAK8CACG6AQEArwIAIeUBAQCvAgAh5gECALECACHnAQgAsAIAIegBCACwAgAh6QECALECACHqAUAAtQIAIQEDAACWBAAgDAMAAMACACC2AQAAxQIAMLcBAAAPABC4AQAAxQIAMLkBAQAAAAG6AQEArwIAIeUBAQCvAgAh5gECALECACHnAQgAsAIAIegBCACwAgAh6QECALECACHqAUAAtQIAIQMAAAAPACABAAAQADACAAARACAOAwAAwAIAILYBAADEAgAwtwEAABMAELgBAADEAgAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAh3gEBAK8CACHfAQIAsQIAIeABAgCxAgAh4QECALECACHiAQgAsAIAIeMBCACwAgAh5AEBAK8CACEBAwAAlgQAIA4DAADAAgAgtgEAAMQCADC3AQAAEwAQuAEAAMQCADC5AQEAAAABugEBAK8CACHAAUAAtQIAId4BAQCvAgAh3wECALECACHgAQIAsQIAIeEBAgCxAgAh4gEIALACACHjAQgAsAIAIeQBAQCvAgAhAwAAABMAIAEAABQAMAIAABUAIA8DAADAAgAgtgEAAMMCADC3AQAAFwAQuAEAAMMCADC5AQEArwIAIboBAQCvAgAhwAFAALUCACHWAQIAsQIAIdcBCACwAgAh2AEIALACACHZAQgAsAIAIdoBCACwAgAh2wEIALACACHcAQgAsAIAId0BCACwAgAhAQMAAJYEACAPAwAAwAIAILYBAADDAgAwtwEAABcAELgBAADDAgAwuQEBAAAAAboBAQCvAgAhwAFAALUCACHWAQIAsQIAIdcBCACwAgAh2AEIALACACHZAQgAsAIAIdoBCACwAgAh2wEIALACACHcAQgAsAIAId0BCACwAgAhAwAAABcAIAEAABgAMAIAABkAIA4DAADAAgAgtgEAAMICADC3AQAAGwAQuAEAAMICADC5AQEArwIAIboBAQCvAgAhwAFAALUCACHPAQEArwIAIdABAQCvAgAh0QEBAK8CACHSAUAAtQIAIdMBQAC0AgAh1AEgALMCACHVAQEAsgIAIQMDAACWBAAg0wEAANUCACDVAQAA1QIAIA4DAADAAgAgtgEAAMICADC3AQAAGwAQuAEAAMICADC5AQEAAAABugEBAK8CACHAAUAAtQIAIc8BAQCvAgAh0AEBAK8CACHRAQEArwIAIdIBQAC1AgAh0wFAALQCACHUASAAswIAIdUBAQCyAgAhAwAAABsAIAEAABwAMAIAAB0AIAoDAADAAgAgtgEAAMECADC3AQAAHwAQuAEAAMECADC5AQEArwIAIboBAQCvAgAhwAFAALUCACHMAQEArwIAIc0BAQCvAgAhzgEBAK8CACEBAwAAlgQAIAoDAADAAgAgtgEAAMECADC3AQAAHwAQuAEAAMECADC5AQEAAAABugEBAK8CACHAAUAAtQIAIcwBAQCvAgAhzQEBAK8CACHOAQEArwIAIQMAAAAfACABAAAgADACAAAhACAMAwAAwAIAILYBAAC_AgAwtwEAACMAELgBAAC_AgAwuQEBAK8CACG6AQEArwIAIbsBAQCvAgAhvAEBAK8CACG9AQEArwIAIb4BAQCvAgAhvwEBAK8CACHAAUAAtQIAIQEDAACWBAAgDAMAAMACACC2AQAAvwIAMLcBAAAjABC4AQAAvwIAMLkBAQAAAAG6AQEArwIAIbsBAQCvAgAhvAEBAK8CACG9AQEArwIAIb4BAQCvAgAhvwEBAK8CACHAAUAAtQIAIQMAAAAjACABAAAkADACAAAlACABAAAAAwAgAQAAAAcAIAEAAAALACABAAAADwAgAQAAABMAIAEAAAAXACABAAAAGwAgAQAAAB8AIAEAAAAjACABAAAAAQAgMAQAALYCACAFAAC3AgAgBgAAuAIAIAcAALkCACAIAAC6AgAgCQAAuwIAIAoAALwCACALAAC9AgAgDAAAvgIAILYBAACuAgAwtwEAADEAELgBAACuAgAwuQEBAK8CACHAAUAAtQIAId4BAQCvAgAh4AECALECACHhAQIAsQIAIeIBCACwAgAh7wEBAK8CACHwAUAAtQIAIfIBAQCvAgAh8wEBAK8CACH0AQEArwIAIfUBCACwAgAh9gEIALACACH3AQIAsQIAIfgBAgCxAgAh-QEBAK8CACH6AQEArwIAIfsBAQCvAgAh_AEBAK8CACH9AQEAsgIAIf4BAQCyAgAh_wEBALICACGAAgAArQIAIIECAgCxAgAhggICALECACGDAgIAsQIAIYQCAgCxAgAhhQICALECACGGAiAAswIAIYcCAgCxAgAhiAJAALQCACGJAkAAtAIAIYoCIACzAgAhiwIBAK8CACGMAggAsAIAIY0CAQCvAgAhDgQAAI0EACAFAACOBAAgBgAAjwQAIAcAAJAEACAIAACRBAAgCQAAkgQAIAoAAJMEACALAACUBAAgDAAAlQQAIP0BAADVAgAg_gEAANUCACD_AQAA1QIAIIgCAADVAgAgiQIAANUCACADAAAAMQAgAQAAMgAwAgAAAQAgAwAAADEAIAEAADIAMAIAAAEAIAMAAAAxACABAAAyADACAAABACAtBAAAhAQAIAUAAIUEACAGAACGBAAgBwAAhwQAIAgAAIgEACAJAACJBAAgCgAAigQAIAsAAIsEACAMAACMBAAguQEBAAAAAcABQAAAAAHeAQEAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB7wEBAAAAAfABQAAAAAHyAQEAAAAB8wEBAAAAAfQBAQAAAAH1AQgAAAAB9gEIAAAAAfcBAgAAAAH4AQIAAAAB-QEBAAAAAfoBAQAAAAH7AQEAAAAB_AEBAAAAAf0BAQAAAAH-AQEAAAAB_wEBAAAAAYACAACDBAAggQICAAAAAYICAgAAAAGDAgIAAAABhAICAAAAAYUCAgAAAAGGAiAAAAABhwICAAAAAYgCQAAAAAGJAkAAAAABigIgAAAAAYsCAQAAAAGMAggAAAABjQIBAAAAAQETAAA2ACAkuQEBAAAAAcABQAAAAAHeAQEAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB7wEBAAAAAfABQAAAAAHyAQEAAAAB8wEBAAAAAfQBAQAAAAH1AQgAAAAB9gEIAAAAAfcBAgAAAAH4AQIAAAAB-QEBAAAAAfoBAQAAAAH7AQEAAAAB_AEBAAAAAf0BAQAAAAH-AQEAAAAB_wEBAAAAAYACAACDBAAggQICAAAAAYICAgAAAAGDAgIAAAABhAICAAAAAYUCAgAAAAGGAiAAAAABhwICAAAAAYgCQAAAAAGJAkAAAAABigIgAAAAAYsCAQAAAAGMAggAAAABjQIBAAAAAQETAAA4ADABEwAAOAAwLQQAAI4DACAFAACPAwAgBgAAkAMAIAcAAJEDACAIAACSAwAgCQAAkwMAIAoAAJQDACALAACVAwAgDAAAlgMAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAIQIAAAABACATAAA7ACAkuQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhAgAAADEAIBMAAD0AIAIAAAAxACATAAA9ACADAAAAAQAgGgAANgAgGwAAOwAgAQAAAAEAIAEAAAAxACAKDQAAiAMAICAAAIkDACAhAACMAwAgIgAAiwMAICMAAIoDACD9AQAA1QIAIP4BAADVAgAg_wEAANUCACCIAgAA1QIAIIkCAADVAgAgJ7YBAACsAgAwtwEAAEQAELgBAACsAgAwuQEBAI4CACHAAUAAjwIAId4BAQCOAgAh4AECAKICACHhAQIAogIAIeIBCACjAgAh7wEBAI4CACHwAUAAjwIAIfIBAQCOAgAh8wEBAI4CACH0AQEAjgIAIfUBCACjAgAh9gEIAKMCACH3AQIAogIAIfgBAgCiAgAh-QEBAI4CACH6AQEAjgIAIfsBAQCOAgAh_AEBAI4CACH9AQEAmQIAIf4BAQCZAgAh_wEBAJkCACGAAgAArQIAIIECAgCiAgAhggICAKICACGDAgIAogIAIYQCAgCiAgAhhQICAKICACGGAiAAmAIAIYcCAgCiAgAhiAJAAJcCACGJAkAAlwIAIYoCIACYAgAhiwIBAI4CACGMAggAowIAIY0CAQCOAgAhAwAAADEAIAEAAEMAMB8AAEQAIAMAAAAxACABAAAyADACAAABACABAAAABQAgAQAAAAUAIAMAAAADACABAAAEADACAAAFACADAAAAAwAgAQAABAAwAgAABQAgAwAAAAMAIAEAAAQAMAIAAAUAIAcDAACHAwAguQEBAAAAAboBAQAAAAG-AQEAAAABwAFAAAAAAdABAQAAAAHxAQgAAAABARMAAEwAIAa5AQEAAAABugEBAAAAAb4BAQAAAAHAAUAAAAAB0AEBAAAAAfEBCAAAAAEBEwAATgAwARMAAE4AMAcDAACGAwAguQEBAMwCACG6AQEAzAIAIb4BAQDMAgAhwAFAAM0CACHQAQEA2wIAIfEBCADkAgAhAgAAAAUAIBMAAFEAIAa5AQEAzAIAIboBAQDMAgAhvgEBAMwCACHAAUAAzQIAIdABAQDbAgAh8QEIAOQCACECAAAAAwAgEwAAUwAgAgAAAAMAIBMAAFMAIAMAAAAFACAaAABMACAbAABRACABAAAABQAgAQAAAAMAIAYNAACBAwAgIAAAggMAICEAAIUDACAiAACEAwAgIwAAgwMAINABAADVAgAgCbYBAACrAgAwtwEAAFoAELgBAACrAgAwuQEBAI4CACG6AQEAjgIAIb4BAQCOAgAhwAFAAI8CACHQAQEAmQIAIfEBCACjAgAhAwAAAAMAIAEAAFkAMB8AAFoAIAMAAAADACABAAAEADACAAAFACABAAAACQAgAQAAAAkAIAMAAAAHACABAAAIADACAAAJACADAAAABwAgAQAACAAwAgAACQAgAwAAAAcAIAEAAAgAMAIAAAkAIAYDAACAAwAguQEBAAAAAboBAQAAAAHAAUAAAAABzwEBAAAAAdQBIAAAAAEBEwAAYgAgBbkBAQAAAAG6AQEAAAABwAFAAAAAAc8BAQAAAAHUASAAAAABARMAAGQAMAETAABkADAGAwAA_wIAILkBAQDMAgAhugEBAMwCACHAAUAAzQIAIc8BAQDMAgAh1AEgANoCACECAAAACQAgEwAAZwAgBbkBAQDMAgAhugEBAMwCACHAAUAAzQIAIc8BAQDMAgAh1AEgANoCACECAAAABwAgEwAAaQAgAgAAAAcAIBMAAGkAIAMAAAAJACAaAABiACAbAABnACABAAAACQAgAQAAAAcAIAMNAAD8AgAgIgAA_gIAICMAAP0CACAItgEAAKoCADC3AQAAcAAQuAEAAKoCADC5AQEAjgIAIboBAQCOAgAhwAFAAI8CACHPAQEAjgIAIdQBIACYAgAhAwAAAAcAIAEAAG8AMB8AAHAAIAMAAAAHACABAAAIADACAAAJACABAAAADQAgAQAAAA0AIAMAAAALACABAAAMADACAAANACADAAAACwAgAQAADAAwAgAADQAgAwAAAAsAIAEAAAwAMAIAAA0AIAwDAAD7AgAguQEBAAAAAboBAQAAAAG-AQEAAAABwAFAAAAAAdQBIAAAAAHrAQEAAAAB7AECAAAAAe0BCAAAAAHuAQgAAAAB7wEBAAAAAfABQAAAAAEBEwAAeAAgC7kBAQAAAAG6AQEAAAABvgEBAAAAAcABQAAAAAHUASAAAAAB6wEBAAAAAewBAgAAAAHtAQgAAAAB7gEIAAAAAe8BAQAAAAHwAUAAAAABARMAAHoAMAETAAB6ADAMAwAA-gIAILkBAQDMAgAhugEBAMwCACG-AQEAzAIAIcABQADNAgAh1AEgANoCACHrAQEAzAIAIewBAgDjAgAh7QEIAOQCACHuAQgA5AIAIe8BAQDMAgAh8AFAAM0CACECAAAADQAgEwAAfQAgC7kBAQDMAgAhugEBAMwCACG-AQEAzAIAIcABQADNAgAh1AEgANoCACHrAQEAzAIAIewBAgDjAgAh7QEIAOQCACHuAQgA5AIAIe8BAQDMAgAh8AFAAM0CACECAAAACwAgEwAAfwAgAgAAAAsAIBMAAH8AIAMAAAANACAaAAB4ACAbAAB9ACABAAAADQAgAQAAAAsAIAUNAAD1AgAgIAAA9gIAICEAAPkCACAiAAD4AgAgIwAA9wIAIA62AQAAqQIAMLcBAACGAQAQuAEAAKkCADC5AQEAjgIAIboBAQCOAgAhvgEBAI4CACHAAUAAjwIAIdQBIACYAgAh6wEBAI4CACHsAQIAogIAIe0BCACjAgAh7gEIAKMCACHvAQEAjgIAIfABQACPAgAhAwAAAAsAIAEAAIUBADAfAACGAQAgAwAAAAsAIAEAAAwAMAIAAA0AIAEAAAARACABAAAAEQAgAwAAAA8AIAEAABAAMAIAABEAIAMAAAAPACABAAAQADACAAARACADAAAADwAgAQAAEAAwAgAAEQAgCQMAAPQCACC5AQEAAAABugEBAAAAAeUBAQAAAAHmAQIAAAAB5wEIAAAAAegBCAAAAAHpAQIAAAAB6gFAAAAAAQETAACOAQAgCLkBAQAAAAG6AQEAAAAB5QEBAAAAAeYBAgAAAAHnAQgAAAAB6AEIAAAAAekBAgAAAAHqAUAAAAABARMAAJABADABEwAAkAEAMAkDAADzAgAguQEBAMwCACG6AQEAzAIAIeUBAQDMAgAh5gECAOMCACHnAQgA5AIAIegBCADkAgAh6QECAOMCACHqAUAAzQIAIQIAAAARACATAACTAQAgCLkBAQDMAgAhugEBAMwCACHlAQEAzAIAIeYBAgDjAgAh5wEIAOQCACHoAQgA5AIAIekBAgDjAgAh6gFAAM0CACECAAAADwAgEwAAlQEAIAIAAAAPACATAACVAQAgAwAAABEAIBoAAI4BACAbAACTAQAgAQAAABEAIAEAAAAPACAFDQAA7gIAICAAAO8CACAhAADyAgAgIgAA8QIAICMAAPACACALtgEAAKgCADC3AQAAnAEAELgBAACoAgAwuQEBAI4CACG6AQEAjgIAIeUBAQCOAgAh5gECAKICACHnAQgAowIAIegBCACjAgAh6QECAKICACHqAUAAjwIAIQMAAAAPACABAACbAQAwHwAAnAEAIAMAAAAPACABAAAQADACAAARACABAAAAFQAgAQAAABUAIAMAAAATACABAAAUADACAAAVACADAAAAEwAgAQAAFAAwAgAAFQAgAwAAABMAIAEAABQAMAIAABUAIAsDAADtAgAguQEBAAAAAboBAQAAAAHAAUAAAAAB3gEBAAAAAd8BAgAAAAHgAQIAAAAB4QECAAAAAeIBCAAAAAHjAQgAAAAB5AEBAAAAAQETAACkAQAgCrkBAQAAAAG6AQEAAAABwAFAAAAAAd4BAQAAAAHfAQIAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB4wEIAAAAAeQBAQAAAAEBEwAApgEAMAETAACmAQAwCwMAAOwCACC5AQEAzAIAIboBAQDMAgAhwAFAAM0CACHeAQEAzAIAId8BAgDjAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh4wEIAOQCACHkAQEAzAIAIQIAAAAVACATAACpAQAgCrkBAQDMAgAhugEBAMwCACHAAUAAzQIAId4BAQDMAgAh3wECAOMCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHjAQgA5AIAIeQBAQDMAgAhAgAAABMAIBMAAKsBACACAAAAEwAgEwAAqwEAIAMAAAAVACAaAACkAQAgGwAAqQEAIAEAAAAVACABAAAAEwAgBQ0AAOcCACAgAADoAgAgIQAA6wIAICIAAOoCACAjAADpAgAgDbYBAACnAgAwtwEAALIBABC4AQAApwIAMLkBAQCOAgAhugEBAI4CACHAAUAAjwIAId4BAQCOAgAh3wECAKICACHgAQIAogIAIeEBAgCiAgAh4gEIAKMCACHjAQgAowIAIeQBAQCOAgAhAwAAABMAIAEAALEBADAfAACyAQAgAwAAABMAIAEAABQAMAIAABUAIAEAAAAZACABAAAAGQAgAwAAABcAIAEAABgAMAIAABkAIAMAAAAXACABAAAYADACAAAZACADAAAAFwAgAQAAGAAwAgAAGQAgDAMAAOYCACC5AQEAAAABugEBAAAAAcABQAAAAAHWAQIAAAAB1wEIAAAAAdgBCAAAAAHZAQgAAAAB2gEIAAAAAdsBCAAAAAHcAQgAAAAB3QEIAAAAAQETAAC6AQAgC7kBAQAAAAG6AQEAAAABwAFAAAAAAdYBAgAAAAHXAQgAAAAB2AEIAAAAAdkBCAAAAAHaAQgAAAAB2wEIAAAAAdwBCAAAAAHdAQgAAAABARMAALwBADABEwAAvAEAMAwDAADlAgAguQEBAMwCACG6AQEAzAIAIcABQADNAgAh1gECAOMCACHXAQgA5AIAIdgBCADkAgAh2QEIAOQCACHaAQgA5AIAIdsBCADkAgAh3AEIAOQCACHdAQgA5AIAIQIAAAAZACATAAC_AQAgC7kBAQDMAgAhugEBAMwCACHAAUAAzQIAIdYBAgDjAgAh1wEIAOQCACHYAQgA5AIAIdkBCADkAgAh2gEIAOQCACHbAQgA5AIAIdwBCADkAgAh3QEIAOQCACECAAAAFwAgEwAAwQEAIAIAAAAXACATAADBAQAgAwAAABkAIBoAALoBACAbAAC_AQAgAQAAABkAIAEAAAAXACAFDQAA3gIAICAAAN8CACAhAADiAgAgIgAA4QIAICMAAOACACAOtgEAAKECADC3AQAAyAEAELgBAAChAgAwuQEBAI4CACG6AQEAjgIAIcABQACPAgAh1gECAKICACHXAQgAowIAIdgBCACjAgAh2QEIAKMCACHaAQgAowIAIdsBCACjAgAh3AEIAKMCACHdAQgAowIAIQMAAAAXACABAADHAQAwHwAAyAEAIAMAAAAXACABAAAYADACAAAZACABAAAAHQAgAQAAAB0AIAMAAAAbACABAAAcADACAAAdACADAAAAGwAgAQAAHAAwAgAAHQAgAwAAABsAIAEAABwAMAIAAB0AIAsDAADdAgAguQEBAAAAAboBAQAAAAHAAUAAAAABzwEBAAAAAdABAQAAAAHRAQEAAAAB0gFAAAAAAdMBQAAAAAHUASAAAAAB1QEBAAAAAQETAADQAQAgCrkBAQAAAAG6AQEAAAABwAFAAAAAAc8BAQAAAAHQAQEAAAAB0QEBAAAAAdIBQAAAAAHTAUAAAAAB1AEgAAAAAdUBAQAAAAEBEwAA0gEAMAETAADSAQAwCwMAANwCACC5AQEAzAIAIboBAQDMAgAhwAFAAM0CACHPAQEAzAIAIdABAQDMAgAh0QEBAMwCACHSAUAAzQIAIdMBQADZAgAh1AEgANoCACHVAQEA2wIAIQIAAAAdACATAADVAQAgCrkBAQDMAgAhugEBAMwCACHAAUAAzQIAIc8BAQDMAgAh0AEBAMwCACHRAQEAzAIAIdIBQADNAgAh0wFAANkCACHUASAA2gIAIdUBAQDbAgAhAgAAABsAIBMAANcBACACAAAAGwAgEwAA1wEAIAMAAAAdACAaAADQAQAgGwAA1QEAIAEAAAAdACABAAAAGwAgBQ0AANYCACAiAADYAgAgIwAA1wIAINMBAADVAgAg1QEAANUCACANtgEAAJYCADC3AQAA3gEAELgBAACWAgAwuQEBAI4CACG6AQEAjgIAIcABQACPAgAhzwEBAI4CACHQAQEAjgIAIdEBAQCOAgAh0gFAAI8CACHTAUAAlwIAIdQBIACYAgAh1QEBAJkCACEDAAAAGwAgAQAA3QEAMB8AAN4BACADAAAAGwAgAQAAHAAwAgAAHQAgAQAAACEAIAEAAAAhACADAAAAHwAgAQAAIAAwAgAAIQAgAwAAAB8AIAEAACAAMAIAACEAIAMAAAAfACABAAAgADACAAAhACAHAwAA1AIAILkBAQAAAAG6AQEAAAABwAFAAAAAAcwBAQAAAAHNAQEAAAABzgEBAAAAAQETAADmAQAgBrkBAQAAAAG6AQEAAAABwAFAAAAAAcwBAQAAAAHNAQEAAAABzgEBAAAAAQETAADoAQAwARMAAOgBADAHAwAA0wIAILkBAQDMAgAhugEBAMwCACHAAUAAzQIAIcwBAQDMAgAhzQEBAMwCACHOAQEAzAIAIQIAAAAhACATAADrAQAgBrkBAQDMAgAhugEBAMwCACHAAUAAzQIAIcwBAQDMAgAhzQEBAMwCACHOAQEAzAIAIQIAAAAfACATAADtAQAgAgAAAB8AIBMAAO0BACADAAAAIQAgGgAA5gEAIBsAAOsBACABAAAAIQAgAQAAAB8AIAMNAADQAgAgIgAA0gIAICMAANECACAJtgEAAJUCADC3AQAA9AEAELgBAACVAgAwuQEBAI4CACG6AQEAjgIAIcABQACPAgAhzAEBAI4CACHNAQEAjgIAIc4BAQCOAgAhAwAAAB8AIAEAAPMBADAfAAD0AQAgAwAAAB8AIAEAACAAMAIAACEAIAEAAAAlACABAAAAJQAgAwAAACMAIAEAACQAMAIAACUAIAMAAAAjACABAAAkADACAAAlACADAAAAIwAgAQAAJAAwAgAAJQAgCQMAAM8CACC5AQEAAAABugEBAAAAAbsBAQAAAAG8AQEAAAABvQEBAAAAAb4BAQAAAAG_AQEAAAABwAFAAAAAAQETAAD8AQAgCLkBAQAAAAG6AQEAAAABuwEBAAAAAbwBAQAAAAG9AQEAAAABvgEBAAAAAb8BAQAAAAHAAUAAAAABARMAAP4BADABEwAA_gEAMAkDAADOAgAguQEBAMwCACG6AQEAzAIAIbsBAQDMAgAhvAEBAMwCACG9AQEAzAIAIb4BAQDMAgAhvwEBAMwCACHAAUAAzQIAIQIAAAAlACATAACBAgAgCLkBAQDMAgAhugEBAMwCACG7AQEAzAIAIbwBAQDMAgAhvQEBAMwCACG-AQEAzAIAIb8BAQDMAgAhwAFAAM0CACECAAAAIwAgEwAAgwIAIAIAAAAjACATAACDAgAgAwAAACUAIBoAAPwBACAbAACBAgAgAQAAACUAIAEAAAAjACADDQAAyQIAICIAAMsCACAjAADKAgAgC7YBAACNAgAwtwEAAIoCABC4AQAAjQIAMLkBAQCOAgAhugEBAI4CACG7AQEAjgIAIbwBAQCOAgAhvQEBAI4CACG-AQEAjgIAIb8BAQCOAgAhwAFAAI8CACEDAAAAIwAgAQAAiQIAMB8AAIoCACADAAAAIwAgAQAAJAAwAgAAJQAgC7YBAACNAgAwtwEAAIoCABC4AQAAjQIAMLkBAQCOAgAhugEBAI4CACG7AQEAjgIAIbwBAQCOAgAhvQEBAI4CACG-AQEAjgIAIb8BAQCOAgAhwAFAAI8CACEODQAAkQIAICIAAJQCACAjAACUAgAgwQEBAAAAAcIBAQAAAATDAQEAAAAExAEBAAAAAcUBAQAAAAHGAQEAAAABxwEBAAAAAcgBAQCTAgAhyQEBAAAAAcoBAQAAAAHLAQEAAAABCw0AAJECACAiAACSAgAgIwAAkgIAIMEBQAAAAAHCAUAAAAAEwwFAAAAABMQBQAAAAAHFAUAAAAABxgFAAAAAAccBQAAAAAHIAUAAkAIAIQsNAACRAgAgIgAAkgIAICMAAJICACDBAUAAAAABwgFAAAAABMMBQAAAAATEAUAAAAABxQFAAAAAAcYBQAAAAAHHAUAAAAAByAFAAJACACEIwQECAAAAAcIBAgAAAATDAQIAAAAExAECAAAAAcUBAgAAAAHGAQIAAAABxwECAAAAAcgBAgCRAgAhCMEBQAAAAAHCAUAAAAAEwwFAAAAABMQBQAAAAAHFAUAAAAABxgFAAAAAAccBQAAAAAHIAUAAkgIAIQ4NAACRAgAgIgAAlAIAICMAAJQCACDBAQEAAAABwgEBAAAABMMBAQAAAATEAQEAAAABxQEBAAAAAcYBAQAAAAHHAQEAAAAByAEBAJMCACHJAQEAAAABygEBAAAAAcsBAQAAAAELwQEBAAAAAcIBAQAAAATDAQEAAAAExAEBAAAAAcUBAQAAAAHGAQEAAAABxwEBAAAAAcgBAQCUAgAhyQEBAAAAAcoBAQAAAAHLAQEAAAABCbYBAACVAgAwtwEAAPQBABC4AQAAlQIAMLkBAQCOAgAhugEBAI4CACHAAUAAjwIAIcwBAQCOAgAhzQEBAI4CACHOAQEAjgIAIQ22AQAAlgIAMLcBAADeAQAQuAEAAJYCADC5AQEAjgIAIboBAQCOAgAhwAFAAI8CACHPAQEAjgIAIdABAQCOAgAh0QEBAI4CACHSAUAAjwIAIdMBQACXAgAh1AEgAJgCACHVAQEAmQIAIQsNAACbAgAgIgAAoAIAICMAAKACACDBAUAAAAABwgFAAAAABcMBQAAAAAXEAUAAAAABxQFAAAAAAcYBQAAAAAHHAUAAAAAByAFAAJ8CACEFDQAAkQIAICIAAJ4CACAjAACeAgAgwQEgAAAAAcgBIACdAgAhDg0AAJsCACAiAACcAgAgIwAAnAIAIMEBAQAAAAHCAQEAAAAFwwEBAAAABcQBAQAAAAHFAQEAAAABxgEBAAAAAccBAQAAAAHIAQEAmgIAIckBAQAAAAHKAQEAAAABywEBAAAAAQ4NAACbAgAgIgAAnAIAICMAAJwCACDBAQEAAAABwgEBAAAABcMBAQAAAAXEAQEAAAABxQEBAAAAAcYBAQAAAAHHAQEAAAAByAEBAJoCACHJAQEAAAABygEBAAAAAcsBAQAAAAEIwQECAAAAAcIBAgAAAAXDAQIAAAAFxAECAAAAAcUBAgAAAAHGAQIAAAABxwECAAAAAcgBAgCbAgAhC8EBAQAAAAHCAQEAAAAFwwEBAAAABcQBAQAAAAHFAQEAAAABxgEBAAAAAccBAQAAAAHIAQEAnAIAIckBAQAAAAHKAQEAAAABywEBAAAAAQUNAACRAgAgIgAAngIAICMAAJ4CACDBASAAAAAByAEgAJ0CACECwQEgAAAAAcgBIACeAgAhCw0AAJsCACAiAACgAgAgIwAAoAIAIMEBQAAAAAHCAUAAAAAFwwFAAAAABcQBQAAAAAHFAUAAAAABxgFAAAAAAccBQAAAAAHIAUAAnwIAIQjBAUAAAAABwgFAAAAABcMBQAAAAAXEAUAAAAABxQFAAAAAAcYBQAAAAAHHAUAAAAAByAFAAKACACEOtgEAAKECADC3AQAAyAEAELgBAAChAgAwuQEBAI4CACG6AQEAjgIAIcABQACPAgAh1gECAKICACHXAQgAowIAIdgBCACjAgAh2QEIAKMCACHaAQgAowIAIdsBCACjAgAh3AEIAKMCACHdAQgAowIAIQ0NAACRAgAgIAAApQIAICEAAJECACAiAACRAgAgIwAAkQIAIMEBAgAAAAHCAQIAAAAEwwECAAAABMQBAgAAAAHFAQIAAAABxgECAAAAAccBAgAAAAHIAQIApgIAIQ0NAACRAgAgIAAApQIAICEAAKUCACAiAAClAgAgIwAApQIAIMEBCAAAAAHCAQgAAAAEwwEIAAAABMQBCAAAAAHFAQgAAAABxgEIAAAAAccBCAAAAAHIAQgApAIAIQ0NAACRAgAgIAAApQIAICEAAKUCACAiAAClAgAgIwAApQIAIMEBCAAAAAHCAQgAAAAEwwEIAAAABMQBCAAAAAHFAQgAAAABxgEIAAAAAccBCAAAAAHIAQgApAIAIQjBAQgAAAABwgEIAAAABMMBCAAAAATEAQgAAAABxQEIAAAAAcYBCAAAAAHHAQgAAAAByAEIAKUCACENDQAAkQIAICAAAKUCACAhAACRAgAgIgAAkQIAICMAAJECACDBAQIAAAABwgECAAAABMMBAgAAAATEAQIAAAABxQECAAAAAcYBAgAAAAHHAQIAAAAByAECAKYCACENtgEAAKcCADC3AQAAsgEAELgBAACnAgAwuQEBAI4CACG6AQEAjgIAIcABQACPAgAh3gEBAI4CACHfAQIAogIAIeABAgCiAgAh4QECAKICACHiAQgAowIAIeMBCACjAgAh5AEBAI4CACELtgEAAKgCADC3AQAAnAEAELgBAACoAgAwuQEBAI4CACG6AQEAjgIAIeUBAQCOAgAh5gECAKICACHnAQgAowIAIegBCACjAgAh6QECAKICACHqAUAAjwIAIQ62AQAAqQIAMLcBAACGAQAQuAEAAKkCADC5AQEAjgIAIboBAQCOAgAhvgEBAI4CACHAAUAAjwIAIdQBIACYAgAh6wEBAI4CACHsAQIAogIAIe0BCACjAgAh7gEIAKMCACHvAQEAjgIAIfABQACPAgAhCLYBAACqAgAwtwEAAHAAELgBAACqAgAwuQEBAI4CACG6AQEAjgIAIcABQACPAgAhzwEBAI4CACHUASAAmAIAIQm2AQAAqwIAMLcBAABaABC4AQAAqwIAMLkBAQCOAgAhugEBAI4CACG-AQEAjgIAIcABQACPAgAh0AEBAJkCACHxAQgAowIAISe2AQAArAIAMLcBAABEABC4AQAArAIAMLkBAQCOAgAhwAFAAI8CACHeAQEAjgIAIeABAgCiAgAh4QECAKICACHiAQgAowIAIe8BAQCOAgAh8AFAAI8CACHyAQEAjgIAIfMBAQCOAgAh9AEBAI4CACH1AQgAowIAIfYBCACjAgAh9wECAKICACH4AQIAogIAIfkBAQCOAgAh-gEBAI4CACH7AQEAjgIAIfwBAQCOAgAh_QEBAJkCACH-AQEAmQIAIf8BAQCZAgAhgAIAAK0CACCBAgIAogIAIYICAgCiAgAhgwICAKICACGEAgIAogIAIYUCAgCiAgAhhgIgAJgCACGHAgIAogIAIYgCQACXAgAhiQJAAJcCACGKAiAAmAIAIYsCAQCOAgAhjAIIAKMCACGNAgEAjgIAIQTBAQEAAAAFjgIBAAAAAY8CAQAAAASQAgEAAAAEMAQAALYCACAFAAC3AgAgBgAAuAIAIAcAALkCACAIAAC6AgAgCQAAuwIAIAoAALwCACALAAC9AgAgDAAAvgIAILYBAACuAgAwtwEAADEAELgBAACuAgAwuQEBAK8CACHAAUAAtQIAId4BAQCvAgAh4AECALECACHhAQIAsQIAIeIBCACwAgAh7wEBAK8CACHwAUAAtQIAIfIBAQCvAgAh8wEBAK8CACH0AQEArwIAIfUBCACwAgAh9gEIALACACH3AQIAsQIAIfgBAgCxAgAh-QEBAK8CACH6AQEArwIAIfsBAQCvAgAh_AEBAK8CACH9AQEAsgIAIf4BAQCyAgAh_wEBALICACGAAgAArQIAIIECAgCxAgAhggICALECACGDAgIAsQIAIYQCAgCxAgAhhQICALECACGGAiAAswIAIYcCAgCxAgAhiAJAALQCACGJAkAAtAIAIYoCIACzAgAhiwIBAK8CACGMAggAsAIAIY0CAQCvAgAhC8EBAQAAAAHCAQEAAAAEwwEBAAAABMQBAQAAAAHFAQEAAAABxgEBAAAAAccBAQAAAAHIAQEAlAIAIckBAQAAAAHKAQEAAAABywEBAAAAAQjBAQgAAAABwgEIAAAABMMBCAAAAATEAQgAAAABxQEIAAAAAcYBCAAAAAHHAQgAAAAByAEIAKUCACEIwQECAAAAAcIBAgAAAATDAQIAAAAExAECAAAAAcUBAgAAAAHGAQIAAAABxwECAAAAAcgBAgCRAgAhC8EBAQAAAAHCAQEAAAAFwwEBAAAABcQBAQAAAAHFAQEAAAABxgEBAAAAAccBAQAAAAHIAQEAnAIAIckBAQAAAAHKAQEAAAABywEBAAAAAQLBASAAAAAByAEgAJ4CACEIwQFAAAAAAcIBQAAAAAXDAUAAAAAFxAFAAAAAAcUBQAAAAAHGAUAAAAABxwFAAAAAAcgBQACgAgAhCMEBQAAAAAHCAUAAAAAEwwFAAAAABMQBQAAAAAHFAUAAAAABxgFAAAAAAccBQAAAAAHIAUAAkgIAIQORAgAAAwAgkgIAAAMAIJMCAAADACADkQIAAAcAIJICAAAHACCTAgAABwAgA5ECAAALACCSAgAACwAgkwIAAAsAIAORAgAADwAgkgIAAA8AIJMCAAAPACADkQIAABMAIJICAAATACCTAgAAEwAgA5ECAAAXACCSAgAAFwAgkwIAABcAIAORAgAAGwAgkgIAABsAIJMCAAAbACADkQIAAB8AIJICAAAfACCTAgAAHwAgA5ECAAAjACCSAgAAIwAgkwIAACMAIAwDAADAAgAgtgEAAL8CADC3AQAAIwAQuAEAAL8CADC5AQEArwIAIboBAQCvAgAhuwEBAK8CACG8AQEArwIAIb0BAQCvAgAhvgEBAK8CACG_AQEArwIAIcABQAC1AgAhMgQAALYCACAFAAC3AgAgBgAAuAIAIAcAALkCACAIAAC6AgAgCQAAuwIAIAoAALwCACALAAC9AgAgDAAAvgIAILYBAACuAgAwtwEAADEAELgBAACuAgAwuQEBAK8CACHAAUAAtQIAId4BAQCvAgAh4AECALECACHhAQIAsQIAIeIBCACwAgAh7wEBAK8CACHwAUAAtQIAIfIBAQCvAgAh8wEBAK8CACH0AQEArwIAIfUBCACwAgAh9gEIALACACH3AQIAsQIAIfgBAgCxAgAh-QEBAK8CACH6AQEArwIAIfsBAQCvAgAh_AEBAK8CACH9AQEAsgIAIf4BAQCyAgAh_wEBALICACGAAgAArQIAIIECAgCxAgAhggICALECACGDAgIAsQIAIYQCAgCxAgAhhQICALECACGGAiAAswIAIYcCAgCxAgAhiAJAALQCACGJAkAAtAIAIYoCIACzAgAhiwIBAK8CACGMAggAsAIAIY0CAQCvAgAhlAIAADEAIJUCAAAxACAKAwAAwAIAILYBAADBAgAwtwEAAB8AELgBAADBAgAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAhzAEBAK8CACHNAQEArwIAIc4BAQCvAgAhDgMAAMACACC2AQAAwgIAMLcBAAAbABC4AQAAwgIAMLkBAQCvAgAhugEBAK8CACHAAUAAtQIAIc8BAQCvAgAh0AEBAK8CACHRAQEArwIAIdIBQAC1AgAh0wFAALQCACHUASAAswIAIdUBAQCyAgAhDwMAAMACACC2AQAAwwIAMLcBAAAXABC4AQAAwwIAMLkBAQCvAgAhugEBAK8CACHAAUAAtQIAIdYBAgCxAgAh1wEIALACACHYAQgAsAIAIdkBCACwAgAh2gEIALACACHbAQgAsAIAIdwBCACwAgAh3QEIALACACEOAwAAwAIAILYBAADEAgAwtwEAABMAELgBAADEAgAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAh3gEBAK8CACHfAQIAsQIAIeABAgCxAgAh4QECALECACHiAQgAsAIAIeMBCACwAgAh5AEBAK8CACEMAwAAwAIAILYBAADFAgAwtwEAAA8AELgBAADFAgAwuQEBAK8CACG6AQEArwIAIeUBAQCvAgAh5gECALECACHnAQgAsAIAIegBCACwAgAh6QECALECACHqAUAAtQIAIQ8DAADAAgAgtgEAAMYCADC3AQAACwAQuAEAAMYCADC5AQEArwIAIboBAQCvAgAhvgEBAK8CACHAAUAAtQIAIdQBIACzAgAh6wEBAK8CACHsAQIAsQIAIe0BCACwAgAh7gEIALACACHvAQEArwIAIfABQAC1AgAhCQMAAMACACC2AQAAxwIAMLcBAAAHABC4AQAAxwIAMLkBAQCvAgAhugEBAK8CACHAAUAAtQIAIc8BAQCvAgAh1AEgALMCACEKAwAAwAIAILYBAADIAgAwtwEAAAMAELgBAADIAgAwuQEBAK8CACG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHQAQEAsgIAIfEBCACwAgAhAAAAAZkCAQAAAAEBmQJAAAAAAQUaAADIBAAgGwAAywQAIJYCAADJBAAglwIAAMoEACCcAgAAAQAgAxoAAMgEACCWAgAAyQQAIJwCAAABACAAAAAFGgAAwwQAIBsAAMYEACCWAgAAxAQAIJcCAADFBAAgnAIAAAEAIAMaAADDBAAglgIAAMQEACCcAgAAAQAgAAAAAAGZAkAAAAABAZkCIAAAAAEBmQIBAAAAAQUaAAC-BAAgGwAAwQQAIJYCAAC_BAAglwIAAMAEACCcAgAAAQAgAxoAAL4EACCWAgAAvwQAIJwCAAABACAAAAAAAAWZAgIAAAABoAICAAAAAaECAgAAAAGiAgIAAAABowICAAAAAQWZAggAAAABoAIIAAAAAaECCAAAAAGiAggAAAABowIIAAAAAQUaAAC5BAAgGwAAvAQAIJYCAAC6BAAglwIAALsEACCcAgAAAQAgAxoAALkEACCWAgAAugQAIJwCAAABACAAAAAAAAUaAAC0BAAgGwAAtwQAIJYCAAC1BAAglwIAALYEACCcAgAAAQAgAxoAALQEACCWAgAAtQQAIJwCAAABACAAAAAAAAUaAACvBAAgGwAAsgQAIJYCAACwBAAglwIAALEEACCcAgAAAQAgAxoAAK8EACCWAgAAsAQAIJwCAAABACAAAAAAAAUaAACqBAAgGwAArQQAIJYCAACrBAAglwIAAKwEACCcAgAAAQAgAxoAAKoEACCWAgAAqwQAIJwCAAABACAAAAAFGgAApQQAIBsAAKgEACCWAgAApgQAIJcCAACnBAAgnAIAAAEAIAMaAAClBAAglgIAAKYEACCcAgAAAQAgAAAAAAAFGgAAoAQAIBsAAKMEACCWAgAAoQQAIJcCAACiBAAgnAIAAAEAIAMaAACgBAAglgIAAKEEACCcAgAAAQAgAAAAAAACmQIBAAAABJ8CAQAAAAULGgAA9wMAMBsAAPwDADCWAgAA-AMAMJcCAAD5AwAwmAIAAPoDACCZAgAA-wMAMJoCAAD7AwAwmwIAAPsDADCcAgAA-wMAMJ0CAAD9AwAwngIAAP4DADALGgAA6wMAMBsAAPADADCWAgAA7AMAMJcCAADtAwAwmAIAAO4DACCZAgAA7wMAMJoCAADvAwAwmwIAAO8DADCcAgAA7wMAMJ0CAADxAwAwngIAAPIDADALGgAA3wMAMBsAAOQDADCWAgAA4AMAMJcCAADhAwAwmAIAAOIDACCZAgAA4wMAMJoCAADjAwAwmwIAAOMDADCcAgAA4wMAMJ0CAADlAwAwngIAAOYDADALGgAA0wMAMBsAANgDADCWAgAA1AMAMJcCAADVAwAwmAIAANYDACCZAgAA1wMAMJoCAADXAwAwmwIAANcDADCcAgAA1wMAMJ0CAADZAwAwngIAANoDADALGgAAxwMAMBsAAMwDADCWAgAAyAMAMJcCAADJAwAwmAIAAMoDACCZAgAAywMAMJoCAADLAwAwmwIAAMsDADCcAgAAywMAMJ0CAADNAwAwngIAAM4DADALGgAAuwMAMBsAAMADADCWAgAAvAMAMJcCAAC9AwAwmAIAAL4DACCZAgAAvwMAMJoCAAC_AwAwmwIAAL8DADCcAgAAvwMAMJ0CAADBAwAwngIAAMIDADALGgAArwMAMBsAALQDADCWAgAAsAMAMJcCAACxAwAwmAIAALIDACCZAgAAswMAMJoCAACzAwAwmwIAALMDADCcAgAAswMAMJ0CAAC1AwAwngIAALYDADALGgAAowMAMBsAAKgDADCWAgAApAMAMJcCAAClAwAwmAIAAKYDACCZAgAApwMAMJoCAACnAwAwmwIAAKcDADCcAgAApwMAMJ0CAACpAwAwngIAAKoDADALGgAAlwMAMBsAAJwDADCWAgAAmAMAMJcCAACZAwAwmAIAAJoDACCZAgAAmwMAMJoCAACbAwAwmwIAAJsDADCcAgAAmwMAMJ0CAACdAwAwngIAAJ4DADAHuQEBAAAAAbsBAQAAAAG8AQEAAAABvQEBAAAAAb4BAQAAAAG_AQEAAAABwAFAAAAAAQIAAAAlACAaAACiAwAgAwAAACUAIBoAAKIDACAbAAChAwAgARMAAJ8EADAMAwAAwAIAILYBAAC_AgAwtwEAACMAELgBAAC_AgAwuQEBAAAAAboBAQCvAgAhuwEBAK8CACG8AQEArwIAIb0BAQCvAgAhvgEBAK8CACG_AQEArwIAIcABQAC1AgAhAgAAACUAIBMAAKEDACACAAAAnwMAIBMAAKADACALtgEAAJ4DADC3AQAAnwMAELgBAACeAwAwuQEBAK8CACG6AQEArwIAIbsBAQCvAgAhvAEBAK8CACG9AQEArwIAIb4BAQCvAgAhvwEBAK8CACHAAUAAtQIAIQu2AQAAngMAMLcBAACfAwAQuAEAAJ4DADC5AQEArwIAIboBAQCvAgAhuwEBAK8CACG8AQEArwIAIb0BAQCvAgAhvgEBAK8CACG_AQEArwIAIcABQAC1AgAhB7kBAQDMAgAhuwEBAMwCACG8AQEAzAIAIb0BAQDMAgAhvgEBAMwCACG_AQEAzAIAIcABQADNAgAhB7kBAQDMAgAhuwEBAMwCACG8AQEAzAIAIb0BAQDMAgAhvgEBAMwCACG_AQEAzAIAIcABQADNAgAhB7kBAQAAAAG7AQEAAAABvAEBAAAAAb0BAQAAAAG-AQEAAAABvwEBAAAAAcABQAAAAAEFuQEBAAAAAcABQAAAAAHMAQEAAAABzQEBAAAAAc4BAQAAAAECAAAAIQAgGgAArgMAIAMAAAAhACAaAACuAwAgGwAArQMAIAETAACeBAAwCgMAAMACACC2AQAAwQIAMLcBAAAfABC4AQAAwQIAMLkBAQAAAAG6AQEArwIAIcABQAC1AgAhzAEBAK8CACHNAQEArwIAIc4BAQCvAgAhAgAAACEAIBMAAK0DACACAAAAqwMAIBMAAKwDACAJtgEAAKoDADC3AQAAqwMAELgBAACqAwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAhzAEBAK8CACHNAQEArwIAIc4BAQCvAgAhCbYBAACqAwAwtwEAAKsDABC4AQAAqgMAMLkBAQCvAgAhugEBAK8CACHAAUAAtQIAIcwBAQCvAgAhzQEBAK8CACHOAQEArwIAIQW5AQEAzAIAIcABQADNAgAhzAEBAMwCACHNAQEAzAIAIc4BAQDMAgAhBbkBAQDMAgAhwAFAAM0CACHMAQEAzAIAIc0BAQDMAgAhzgEBAMwCACEFuQEBAAAAAcABQAAAAAHMAQEAAAABzQEBAAAAAc4BAQAAAAEJuQEBAAAAAcABQAAAAAHPAQEAAAAB0AEBAAAAAdEBAQAAAAHSAUAAAAAB0wFAAAAAAdQBIAAAAAHVAQEAAAABAgAAAB0AIBoAALoDACADAAAAHQAgGgAAugMAIBsAALkDACABEwAAnQQAMA4DAADAAgAgtgEAAMICADC3AQAAGwAQuAEAAMICADC5AQEAAAABugEBAK8CACHAAUAAtQIAIc8BAQCvAgAh0AEBAK8CACHRAQEArwIAIdIBQAC1AgAh0wFAALQCACHUASAAswIAIdUBAQCyAgAhAgAAAB0AIBMAALkDACACAAAAtwMAIBMAALgDACANtgEAALYDADC3AQAAtwMAELgBAAC2AwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAhzwEBAK8CACHQAQEArwIAIdEBAQCvAgAh0gFAALUCACHTAUAAtAIAIdQBIACzAgAh1QEBALICACENtgEAALYDADC3AQAAtwMAELgBAAC2AwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAhzwEBAK8CACHQAQEArwIAIdEBAQCvAgAh0gFAALUCACHTAUAAtAIAIdQBIACzAgAh1QEBALICACEJuQEBAMwCACHAAUAAzQIAIc8BAQDMAgAh0AEBAMwCACHRAQEAzAIAIdIBQADNAgAh0wFAANkCACHUASAA2gIAIdUBAQDbAgAhCbkBAQDMAgAhwAFAAM0CACHPAQEAzAIAIdABAQDMAgAh0QEBAMwCACHSAUAAzQIAIdMBQADZAgAh1AEgANoCACHVAQEA2wIAIQm5AQEAAAABwAFAAAAAAc8BAQAAAAHQAQEAAAAB0QEBAAAAAdIBQAAAAAHTAUAAAAAB1AEgAAAAAdUBAQAAAAEKuQEBAAAAAcABQAAAAAHWAQIAAAAB1wEIAAAAAdgBCAAAAAHZAQgAAAAB2gEIAAAAAdsBCAAAAAHcAQgAAAAB3QEIAAAAAQIAAAAZACAaAADGAwAgAwAAABkAIBoAAMYDACAbAADFAwAgARMAAJwEADAPAwAAwAIAILYBAADDAgAwtwEAABcAELgBAADDAgAwuQEBAAAAAboBAQCvAgAhwAFAALUCACHWAQIAsQIAIdcBCACwAgAh2AEIALACACHZAQgAsAIAIdoBCACwAgAh2wEIALACACHcAQgAsAIAId0BCACwAgAhAgAAABkAIBMAAMUDACACAAAAwwMAIBMAAMQDACAOtgEAAMIDADC3AQAAwwMAELgBAADCAwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAh1gECALECACHXAQgAsAIAIdgBCACwAgAh2QEIALACACHaAQgAsAIAIdsBCACwAgAh3AEIALACACHdAQgAsAIAIQ62AQAAwgMAMLcBAADDAwAQuAEAAMIDADC5AQEArwIAIboBAQCvAgAhwAFAALUCACHWAQIAsQIAIdcBCACwAgAh2AEIALACACHZAQgAsAIAIdoBCACwAgAh2wEIALACACHcAQgAsAIAId0BCACwAgAhCrkBAQDMAgAhwAFAAM0CACHWAQIA4wIAIdcBCADkAgAh2AEIAOQCACHZAQgA5AIAIdoBCADkAgAh2wEIAOQCACHcAQgA5AIAId0BCADkAgAhCrkBAQDMAgAhwAFAAM0CACHWAQIA4wIAIdcBCADkAgAh2AEIAOQCACHZAQgA5AIAIdoBCADkAgAh2wEIAOQCACHcAQgA5AIAId0BCADkAgAhCrkBAQAAAAHAAUAAAAAB1gECAAAAAdcBCAAAAAHYAQgAAAAB2QEIAAAAAdoBCAAAAAHbAQgAAAAB3AEIAAAAAd0BCAAAAAEJuQEBAAAAAcABQAAAAAHeAQEAAAAB3wECAAAAAeABAgAAAAHhAQIAAAAB4gEIAAAAAeMBCAAAAAHkAQEAAAABAgAAABUAIBoAANIDACADAAAAFQAgGgAA0gMAIBsAANEDACABEwAAmwQAMA4DAADAAgAgtgEAAMQCADC3AQAAEwAQuAEAAMQCADC5AQEAAAABugEBAK8CACHAAUAAtQIAId4BAQCvAgAh3wECALECACHgAQIAsQIAIeEBAgCxAgAh4gEIALACACHjAQgAsAIAIeQBAQCvAgAhAgAAABUAIBMAANEDACACAAAAzwMAIBMAANADACANtgEAAM4DADC3AQAAzwMAELgBAADOAwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAh3gEBAK8CACHfAQIAsQIAIeABAgCxAgAh4QECALECACHiAQgAsAIAIeMBCACwAgAh5AEBAK8CACENtgEAAM4DADC3AQAAzwMAELgBAADOAwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAh3gEBAK8CACHfAQIAsQIAIeABAgCxAgAh4QECALECACHiAQgAsAIAIeMBCACwAgAh5AEBAK8CACEJuQEBAMwCACHAAUAAzQIAId4BAQDMAgAh3wECAOMCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHjAQgA5AIAIeQBAQDMAgAhCbkBAQDMAgAhwAFAAM0CACHeAQEAzAIAId8BAgDjAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh4wEIAOQCACHkAQEAzAIAIQm5AQEAAAABwAFAAAAAAd4BAQAAAAHfAQIAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB4wEIAAAAAeQBAQAAAAEHuQEBAAAAAeUBAQAAAAHmAQIAAAAB5wEIAAAAAegBCAAAAAHpAQIAAAAB6gFAAAAAAQIAAAARACAaAADeAwAgAwAAABEAIBoAAN4DACAbAADdAwAgARMAAJoEADAMAwAAwAIAILYBAADFAgAwtwEAAA8AELgBAADFAgAwuQEBAAAAAboBAQCvAgAh5QEBAK8CACHmAQIAsQIAIecBCACwAgAh6AEIALACACHpAQIAsQIAIeoBQAC1AgAhAgAAABEAIBMAAN0DACACAAAA2wMAIBMAANwDACALtgEAANoDADC3AQAA2wMAELgBAADaAwAwuQEBAK8CACG6AQEArwIAIeUBAQCvAgAh5gECALECACHnAQgAsAIAIegBCACwAgAh6QECALECACHqAUAAtQIAIQu2AQAA2gMAMLcBAADbAwAQuAEAANoDADC5AQEArwIAIboBAQCvAgAh5QEBAK8CACHmAQIAsQIAIecBCACwAgAh6AEIALACACHpAQIAsQIAIeoBQAC1AgAhB7kBAQDMAgAh5QEBAMwCACHmAQIA4wIAIecBCADkAgAh6AEIAOQCACHpAQIA4wIAIeoBQADNAgAhB7kBAQDMAgAh5QEBAMwCACHmAQIA4wIAIecBCADkAgAh6AEIAOQCACHpAQIA4wIAIeoBQADNAgAhB7kBAQAAAAHlAQEAAAAB5gECAAAAAecBCAAAAAHoAQgAAAAB6QECAAAAAeoBQAAAAAEKuQEBAAAAAb4BAQAAAAHAAUAAAAAB1AEgAAAAAesBAQAAAAHsAQIAAAAB7QEIAAAAAe4BCAAAAAHvAQEAAAAB8AFAAAAAAQIAAAANACAaAADqAwAgAwAAAA0AIBoAAOoDACAbAADpAwAgARMAAJkEADAPAwAAwAIAILYBAADGAgAwtwEAAAsAELgBAADGAgAwuQEBAAAAAboBAQCvAgAhvgEBAK8CACHAAUAAtQIAIdQBIACzAgAh6wEBAK8CACHsAQIAsQIAIe0BCACwAgAh7gEIALACACHvAQEArwIAIfABQAC1AgAhAgAAAA0AIBMAAOkDACACAAAA5wMAIBMAAOgDACAOtgEAAOYDADC3AQAA5wMAELgBAADmAwAwuQEBAK8CACG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHUASAAswIAIesBAQCvAgAh7AECALECACHtAQgAsAIAIe4BCACwAgAh7wEBAK8CACHwAUAAtQIAIQ62AQAA5gMAMLcBAADnAwAQuAEAAOYDADC5AQEArwIAIboBAQCvAgAhvgEBAK8CACHAAUAAtQIAIdQBIACzAgAh6wEBAK8CACHsAQIAsQIAIe0BCACwAgAh7gEIALACACHvAQEArwIAIfABQAC1AgAhCrkBAQDMAgAhvgEBAMwCACHAAUAAzQIAIdQBIADaAgAh6wEBAMwCACHsAQIA4wIAIe0BCADkAgAh7gEIAOQCACHvAQEAzAIAIfABQADNAgAhCrkBAQDMAgAhvgEBAMwCACHAAUAAzQIAIdQBIADaAgAh6wEBAMwCACHsAQIA4wIAIe0BCADkAgAh7gEIAOQCACHvAQEAzAIAIfABQADNAgAhCrkBAQAAAAG-AQEAAAABwAFAAAAAAdQBIAAAAAHrAQEAAAAB7AECAAAAAe0BCAAAAAHuAQgAAAAB7wEBAAAAAfABQAAAAAEEuQEBAAAAAcABQAAAAAHPAQEAAAAB1AEgAAAAAQIAAAAJACAaAAD2AwAgAwAAAAkAIBoAAPYDACAbAAD1AwAgARMAAJgEADAJAwAAwAIAILYBAADHAgAwtwEAAAcAELgBAADHAgAwuQEBAAAAAboBAQCvAgAhwAFAALUCACHPAQEArwIAIdQBIACzAgAhAgAAAAkAIBMAAPUDACACAAAA8wMAIBMAAPQDACAItgEAAPIDADC3AQAA8wMAELgBAADyAwAwuQEBAK8CACG6AQEArwIAIcABQAC1AgAhzwEBAK8CACHUASAAswIAIQi2AQAA8gMAMLcBAADzAwAQuAEAAPIDADC5AQEArwIAIboBAQCvAgAhwAFAALUCACHPAQEArwIAIdQBIACzAgAhBLkBAQDMAgAhwAFAAM0CACHPAQEAzAIAIdQBIADaAgAhBLkBAQDMAgAhwAFAAM0CACHPAQEAzAIAIdQBIADaAgAhBLkBAQAAAAHAAUAAAAABzwEBAAAAAdQBIAAAAAEFuQEBAAAAAb4BAQAAAAHAAUAAAAAB0AEBAAAAAfEBCAAAAAECAAAABQAgGgAAggQAIAMAAAAFACAaAACCBAAgGwAAgQQAIAETAACXBAAwCgMAAMACACC2AQAAyAIAMLcBAAADABC4AQAAyAIAMLkBAQAAAAG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHQAQEAsgIAIfEBCACwAgAhAgAAAAUAIBMAAIEEACACAAAA_wMAIBMAAIAEACAJtgEAAP4DADC3AQAA_wMAELgBAAD-AwAwuQEBAK8CACG6AQEArwIAIb4BAQCvAgAhwAFAALUCACHQAQEAsgIAIfEBCACwAgAhCbYBAAD-AwAwtwEAAP8DABC4AQAA_gMAMLkBAQCvAgAhugEBAK8CACG-AQEArwIAIcABQAC1AgAh0AEBALICACHxAQgAsAIAIQW5AQEAzAIAIb4BAQDMAgAhwAFAAM0CACHQAQEA2wIAIfEBCADkAgAhBbkBAQDMAgAhvgEBAMwCACHAAUAAzQIAIdABAQDbAgAh8QEIAOQCACEFuQEBAAAAAb4BAQAAAAHAAUAAAAAB0AEBAAAAAfEBCAAAAAEBmQIBAAAABAQaAAD3AwAwlgIAAPgDADCYAgAA-gMAIJwCAAD7AwAwBBoAAOsDADCWAgAA7AMAMJgCAADuAwAgnAIAAO8DADAEGgAA3wMAMJYCAADgAwAwmAIAAOIDACCcAgAA4wMAMAQaAADTAwAwlgIAANQDADCYAgAA1gMAIJwCAADXAwAwBBoAAMcDADCWAgAAyAMAMJgCAADKAwAgnAIAAMsDADAEGgAAuwMAMJYCAAC8AwAwmAIAAL4DACCcAgAAvwMAMAQaAACvAwAwlgIAALADADCYAgAAsgMAIJwCAACzAwAwBBoAAKMDADCWAgAApAMAMJgCAACmAwAgnAIAAKcDADAEGgAAlwMAMJYCAACYAwAwmAIAAJoDACCcAgAAmwMAMAAAAAAAAAAAAA4EAACNBAAgBQAAjgQAIAYAAI8EACAHAACQBAAgCAAAkQQAIAkAAJIEACAKAACTBAAgCwAAlAQAIAwAAJUEACD9AQAA1QIAIP4BAADVAgAg_wEAANUCACCIAgAA1QIAIIkCAADVAgAgBbkBAQAAAAG-AQEAAAABwAFAAAAAAdABAQAAAAHxAQgAAAABBLkBAQAAAAHAAUAAAAABzwEBAAAAAdQBIAAAAAEKuQEBAAAAAb4BAQAAAAHAAUAAAAAB1AEgAAAAAesBAQAAAAHsAQIAAAAB7QEIAAAAAe4BCAAAAAHvAQEAAAAB8AFAAAAAAQe5AQEAAAAB5QEBAAAAAeYBAgAAAAHnAQgAAAAB6AEIAAAAAekBAgAAAAHqAUAAAAABCbkBAQAAAAHAAUAAAAAB3gEBAAAAAd8BAgAAAAHgAQIAAAAB4QECAAAAAeIBCAAAAAHjAQgAAAAB5AEBAAAAAQq5AQEAAAABwAFAAAAAAdYBAgAAAAHXAQgAAAAB2AEIAAAAAdkBCAAAAAHaAQgAAAAB2wEIAAAAAdwBCAAAAAHdAQgAAAABCbkBAQAAAAHAAUAAAAABzwEBAAAAAdABAQAAAAHRAQEAAAAB0gFAAAAAAdMBQAAAAAHUASAAAAAB1QEBAAAAAQW5AQEAAAABwAFAAAAAAcwBAQAAAAHNAQEAAAABzgEBAAAAAQe5AQEAAAABuwEBAAAAAbwBAQAAAAG9AQEAAAABvgEBAAAAAb8BAQAAAAHAAUAAAAABLAUAAIUEACAGAACGBAAgBwAAhwQAIAgAAIgEACAJAACJBAAgCgAAigQAIAsAAIsEACAMAACMBAAguQEBAAAAAcABQAAAAAHeAQEAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB7wEBAAAAAfABQAAAAAHyAQEAAAAB8wEBAAAAAfQBAQAAAAH1AQgAAAAB9gEIAAAAAfcBAgAAAAH4AQIAAAAB-QEBAAAAAfoBAQAAAAH7AQEAAAAB_AEBAAAAAf0BAQAAAAH-AQEAAAAB_wEBAAAAAYACAACDBAAggQICAAAAAYICAgAAAAGDAgIAAAABhAICAAAAAYUCAgAAAAGGAiAAAAABhwICAAAAAYgCQAAAAAGJAkAAAAABigIgAAAAAYsCAQAAAAGMAggAAAABjQIBAAAAAQIAAAABACAaAACgBAAgAwAAADEAIBoAAKAEACAbAACkBAAgLgAAADEAIAUAAI8DACAGAACQAwAgBwAAkQMAIAgAAJIDACAJAACTAwAgCgAAlAMAIAsAAJUDACAMAACWAwAgEwAApAQAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAISwFAACPAwAgBgAAkAMAIAcAAJEDACAIAACSAwAgCQAAkwMAIAoAAJQDACALAACVAwAgDAAAlgMAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAISwEAACEBAAgBgAAhgQAIAcAAIcEACAIAACIBAAgCQAAiQQAIAoAAIoEACALAACLBAAgDAAAjAQAILkBAQAAAAHAAUAAAAAB3gEBAAAAAeABAgAAAAHhAQIAAAAB4gEIAAAAAe8BAQAAAAHwAUAAAAAB8gEBAAAAAfMBAQAAAAH0AQEAAAAB9QEIAAAAAfYBCAAAAAH3AQIAAAAB-AECAAAAAfkBAQAAAAH6AQEAAAAB-wEBAAAAAfwBAQAAAAH9AQEAAAAB_gEBAAAAAf8BAQAAAAGAAgAAgwQAIIECAgAAAAGCAgIAAAABgwICAAAAAYQCAgAAAAGFAgIAAAABhgIgAAAAAYcCAgAAAAGIAkAAAAABiQJAAAAAAYoCIAAAAAGLAgEAAAABjAIIAAAAAY0CAQAAAAECAAAAAQAgGgAApQQAIAMAAAAxACAaAAClBAAgGwAAqQQAIC4AAAAxACAEAACOAwAgBgAAkAMAIAcAAJEDACAIAACSAwAgCQAAkwMAIAoAAJQDACALAACVAwAgDAAAlgMAIBMAAKkEACC5AQEAzAIAIcABQADNAgAh3gEBAMwCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHvAQEAzAIAIfABQADNAgAh8gEBAMwCACHzAQEAzAIAIfQBAQDMAgAh9QEIAOQCACH2AQgA5AIAIfcBAgDjAgAh-AECAOMCACH5AQEAzAIAIfoBAQDMAgAh-wEBAMwCACH8AQEAzAIAIf0BAQDbAgAh_gEBANsCACH_AQEA2wIAIYACAACNAwAggQICAOMCACGCAgIA4wIAIYMCAgDjAgAhhAICAOMCACGFAgIA4wIAIYYCIADaAgAhhwICAOMCACGIAkAA2QIAIYkCQADZAgAhigIgANoCACGLAgEAzAIAIYwCCADkAgAhjQIBAMwCACEsBAAAjgMAIAYAAJADACAHAACRAwAgCAAAkgMAIAkAAJMDACAKAACUAwAgCwAAlQMAIAwAAJYDACC5AQEAzAIAIcABQADNAgAh3gEBAMwCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHvAQEAzAIAIfABQADNAgAh8gEBAMwCACHzAQEAzAIAIfQBAQDMAgAh9QEIAOQCACH2AQgA5AIAIfcBAgDjAgAh-AECAOMCACH5AQEAzAIAIfoBAQDMAgAh-wEBAMwCACH8AQEAzAIAIf0BAQDbAgAh_gEBANsCACH_AQEA2wIAIYACAACNAwAggQICAOMCACGCAgIA4wIAIYMCAgDjAgAhhAICAOMCACGFAgIA4wIAIYYCIADaAgAhhwICAOMCACGIAkAA2QIAIYkCQADZAgAhigIgANoCACGLAgEAzAIAIYwCCADkAgAhjQIBAMwCACEsBAAAhAQAIAUAAIUEACAHAACHBAAgCAAAiAQAIAkAAIkEACAKAACKBAAgCwAAiwQAIAwAAIwEACC5AQEAAAABwAFAAAAAAd4BAQAAAAHgAQIAAAAB4QECAAAAAeIBCAAAAAHvAQEAAAAB8AFAAAAAAfIBAQAAAAHzAQEAAAAB9AEBAAAAAfUBCAAAAAH2AQgAAAAB9wECAAAAAfgBAgAAAAH5AQEAAAAB-gEBAAAAAfsBAQAAAAH8AQEAAAAB_QEBAAAAAf4BAQAAAAH_AQEAAAABgAIAAIMEACCBAgIAAAABggICAAAAAYMCAgAAAAGEAgIAAAABhQICAAAAAYYCIAAAAAGHAgIAAAABiAJAAAAAAYkCQAAAAAGKAiAAAAABiwIBAAAAAYwCCAAAAAGNAgEAAAABAgAAAAEAIBoAAKoEACADAAAAMQAgGgAAqgQAIBsAAK4EACAuAAAAMQAgBAAAjgMAIAUAAI8DACAHAACRAwAgCAAAkgMAIAkAAJMDACAKAACUAwAgCwAAlQMAIAwAAJYDACATAACuBAAguQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhLAQAAI4DACAFAACPAwAgBwAAkQMAIAgAAJIDACAJAACTAwAgCgAAlAMAIAsAAJUDACAMAACWAwAguQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhLAQAAIQEACAFAACFBAAgBgAAhgQAIAgAAIgEACAJAACJBAAgCgAAigQAIAsAAIsEACAMAACMBAAguQEBAAAAAcABQAAAAAHeAQEAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB7wEBAAAAAfABQAAAAAHyAQEAAAAB8wEBAAAAAfQBAQAAAAH1AQgAAAAB9gEIAAAAAfcBAgAAAAH4AQIAAAAB-QEBAAAAAfoBAQAAAAH7AQEAAAAB_AEBAAAAAf0BAQAAAAH-AQEAAAAB_wEBAAAAAYACAACDBAAggQICAAAAAYICAgAAAAGDAgIAAAABhAICAAAAAYUCAgAAAAGGAiAAAAABhwICAAAAAYgCQAAAAAGJAkAAAAABigIgAAAAAYsCAQAAAAGMAggAAAABjQIBAAAAAQIAAAABACAaAACvBAAgAwAAADEAIBoAAK8EACAbAACzBAAgLgAAADEAIAQAAI4DACAFAACPAwAgBgAAkAMAIAgAAJIDACAJAACTAwAgCgAAlAMAIAsAAJUDACAMAACWAwAgEwAAswQAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAISwEAACOAwAgBQAAjwMAIAYAAJADACAIAACSAwAgCQAAkwMAIAoAAJQDACALAACVAwAgDAAAlgMAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAISwEAACEBAAgBQAAhQQAIAYAAIYEACAHAACHBAAgCQAAiQQAIAoAAIoEACALAACLBAAgDAAAjAQAILkBAQAAAAHAAUAAAAAB3gEBAAAAAeABAgAAAAHhAQIAAAAB4gEIAAAAAe8BAQAAAAHwAUAAAAAB8gEBAAAAAfMBAQAAAAH0AQEAAAAB9QEIAAAAAfYBCAAAAAH3AQIAAAAB-AECAAAAAfkBAQAAAAH6AQEAAAAB-wEBAAAAAfwBAQAAAAH9AQEAAAAB_gEBAAAAAf8BAQAAAAGAAgAAgwQAIIECAgAAAAGCAgIAAAABgwICAAAAAYQCAgAAAAGFAgIAAAABhgIgAAAAAYcCAgAAAAGIAkAAAAABiQJAAAAAAYoCIAAAAAGLAgEAAAABjAIIAAAAAY0CAQAAAAECAAAAAQAgGgAAtAQAIAMAAAAxACAaAAC0BAAgGwAAuAQAIC4AAAAxACAEAACOAwAgBQAAjwMAIAYAAJADACAHAACRAwAgCQAAkwMAIAoAAJQDACALAACVAwAgDAAAlgMAIBMAALgEACC5AQEAzAIAIcABQADNAgAh3gEBAMwCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHvAQEAzAIAIfABQADNAgAh8gEBAMwCACHzAQEAzAIAIfQBAQDMAgAh9QEIAOQCACH2AQgA5AIAIfcBAgDjAgAh-AECAOMCACH5AQEAzAIAIfoBAQDMAgAh-wEBAMwCACH8AQEAzAIAIf0BAQDbAgAh_gEBANsCACH_AQEA2wIAIYACAACNAwAggQICAOMCACGCAgIA4wIAIYMCAgDjAgAhhAICAOMCACGFAgIA4wIAIYYCIADaAgAhhwICAOMCACGIAkAA2QIAIYkCQADZAgAhigIgANoCACGLAgEAzAIAIYwCCADkAgAhjQIBAMwCACEsBAAAjgMAIAUAAI8DACAGAACQAwAgBwAAkQMAIAkAAJMDACAKAACUAwAgCwAAlQMAIAwAAJYDACC5AQEAzAIAIcABQADNAgAh3gEBAMwCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHvAQEAzAIAIfABQADNAgAh8gEBAMwCACHzAQEAzAIAIfQBAQDMAgAh9QEIAOQCACH2AQgA5AIAIfcBAgDjAgAh-AECAOMCACH5AQEAzAIAIfoBAQDMAgAh-wEBAMwCACH8AQEAzAIAIf0BAQDbAgAh_gEBANsCACH_AQEA2wIAIYACAACNAwAggQICAOMCACGCAgIA4wIAIYMCAgDjAgAhhAICAOMCACGFAgIA4wIAIYYCIADaAgAhhwICAOMCACGIAkAA2QIAIYkCQADZAgAhigIgANoCACGLAgEAzAIAIYwCCADkAgAhjQIBAMwCACEsBAAAhAQAIAUAAIUEACAGAACGBAAgBwAAhwQAIAgAAIgEACAKAACKBAAgCwAAiwQAIAwAAIwEACC5AQEAAAABwAFAAAAAAd4BAQAAAAHgAQIAAAAB4QECAAAAAeIBCAAAAAHvAQEAAAAB8AFAAAAAAfIBAQAAAAHzAQEAAAAB9AEBAAAAAfUBCAAAAAH2AQgAAAAB9wECAAAAAfgBAgAAAAH5AQEAAAAB-gEBAAAAAfsBAQAAAAH8AQEAAAAB_QEBAAAAAf4BAQAAAAH_AQEAAAABgAIAAIMEACCBAgIAAAABggICAAAAAYMCAgAAAAGEAgIAAAABhQICAAAAAYYCIAAAAAGHAgIAAAABiAJAAAAAAYkCQAAAAAGKAiAAAAABiwIBAAAAAYwCCAAAAAGNAgEAAAABAgAAAAEAIBoAALkEACADAAAAMQAgGgAAuQQAIBsAAL0EACAuAAAAMQAgBAAAjgMAIAUAAI8DACAGAACQAwAgBwAAkQMAIAgAAJIDACAKAACUAwAgCwAAlQMAIAwAAJYDACATAAC9BAAguQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhLAQAAI4DACAFAACPAwAgBgAAkAMAIAcAAJEDACAIAACSAwAgCgAAlAMAIAsAAJUDACAMAACWAwAguQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhLAQAAIQEACAFAACFBAAgBgAAhgQAIAcAAIcEACAIAACIBAAgCQAAiQQAIAsAAIsEACAMAACMBAAguQEBAAAAAcABQAAAAAHeAQEAAAAB4AECAAAAAeEBAgAAAAHiAQgAAAAB7wEBAAAAAfABQAAAAAHyAQEAAAAB8wEBAAAAAfQBAQAAAAH1AQgAAAAB9gEIAAAAAfcBAgAAAAH4AQIAAAAB-QEBAAAAAfoBAQAAAAH7AQEAAAAB_AEBAAAAAf0BAQAAAAH-AQEAAAAB_wEBAAAAAYACAACDBAAggQICAAAAAYICAgAAAAGDAgIAAAABhAICAAAAAYUCAgAAAAGGAiAAAAABhwICAAAAAYgCQAAAAAGJAkAAAAABigIgAAAAAYsCAQAAAAGMAggAAAABjQIBAAAAAQIAAAABACAaAAC-BAAgAwAAADEAIBoAAL4EACAbAADCBAAgLgAAADEAIAQAAI4DACAFAACPAwAgBgAAkAMAIAcAAJEDACAIAACSAwAgCQAAkwMAIAsAAJUDACAMAACWAwAgEwAAwgQAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAISwEAACOAwAgBQAAjwMAIAYAAJADACAHAACRAwAgCAAAkgMAIAkAAJMDACALAACVAwAgDAAAlgMAILkBAQDMAgAhwAFAAM0CACHeAQEAzAIAIeABAgDjAgAh4QECAOMCACHiAQgA5AIAIe8BAQDMAgAh8AFAAM0CACHyAQEAzAIAIfMBAQDMAgAh9AEBAMwCACH1AQgA5AIAIfYBCADkAgAh9wECAOMCACH4AQIA4wIAIfkBAQDMAgAh-gEBAMwCACH7AQEAzAIAIfwBAQDMAgAh_QEBANsCACH-AQEA2wIAIf8BAQDbAgAhgAIAAI0DACCBAgIA4wIAIYICAgDjAgAhgwICAOMCACGEAgIA4wIAIYUCAgDjAgAhhgIgANoCACGHAgIA4wIAIYgCQADZAgAhiQJAANkCACGKAiAA2gIAIYsCAQDMAgAhjAIIAOQCACGNAgEAzAIAISwEAACEBAAgBQAAhQQAIAYAAIYEACAHAACHBAAgCAAAiAQAIAkAAIkEACAKAACKBAAgDAAAjAQAILkBAQAAAAHAAUAAAAAB3gEBAAAAAeABAgAAAAHhAQIAAAAB4gEIAAAAAe8BAQAAAAHwAUAAAAAB8gEBAAAAAfMBAQAAAAH0AQEAAAAB9QEIAAAAAfYBCAAAAAH3AQIAAAAB-AECAAAAAfkBAQAAAAH6AQEAAAAB-wEBAAAAAfwBAQAAAAH9AQEAAAAB_gEBAAAAAf8BAQAAAAGAAgAAgwQAIIECAgAAAAGCAgIAAAABgwICAAAAAYQCAgAAAAGFAgIAAAABhgIgAAAAAYcCAgAAAAGIAkAAAAABiQJAAAAAAYoCIAAAAAGLAgEAAAABjAIIAAAAAY0CAQAAAAECAAAAAQAgGgAAwwQAIAMAAAAxACAaAADDBAAgGwAAxwQAIC4AAAAxACAEAACOAwAgBQAAjwMAIAYAAJADACAHAACRAwAgCAAAkgMAIAkAAJMDACAKAACUAwAgDAAAlgMAIBMAAMcEACC5AQEAzAIAIcABQADNAgAh3gEBAMwCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHvAQEAzAIAIfABQADNAgAh8gEBAMwCACHzAQEAzAIAIfQBAQDMAgAh9QEIAOQCACH2AQgA5AIAIfcBAgDjAgAh-AECAOMCACH5AQEAzAIAIfoBAQDMAgAh-wEBAMwCACH8AQEAzAIAIf0BAQDbAgAh_gEBANsCACH_AQEA2wIAIYACAACNAwAggQICAOMCACGCAgIA4wIAIYMCAgDjAgAhhAICAOMCACGFAgIA4wIAIYYCIADaAgAhhwICAOMCACGIAkAA2QIAIYkCQADZAgAhigIgANoCACGLAgEAzAIAIYwCCADkAgAhjQIBAMwCACEsBAAAjgMAIAUAAI8DACAGAACQAwAgBwAAkQMAIAgAAJIDACAJAACTAwAgCgAAlAMAIAwAAJYDACC5AQEAzAIAIcABQADNAgAh3gEBAMwCACHgAQIA4wIAIeEBAgDjAgAh4gEIAOQCACHvAQEAzAIAIfABQADNAgAh8gEBAMwCACHzAQEAzAIAIfQBAQDMAgAh9QEIAOQCACH2AQgA5AIAIfcBAgDjAgAh-AECAOMCACH5AQEAzAIAIfoBAQDMAgAh-wEBAMwCACH8AQEAzAIAIf0BAQDbAgAh_gEBANsCACH_AQEA2wIAIYACAACNAwAggQICAOMCACGCAgIA4wIAIYMCAgDjAgAhhAICAOMCACGFAgIA4wIAIYYCIADaAgAhhwICAOMCACGIAkAA2QIAIYkCQADZAgAhigIgANoCACGLAgEAzAIAIYwCCADkAgAhjQIBAMwCACEsBAAAhAQAIAUAAIUEACAGAACGBAAgBwAAhwQAIAgAAIgEACAJAACJBAAgCgAAigQAIAsAAIsEACC5AQEAAAABwAFAAAAAAd4BAQAAAAHgAQIAAAAB4QECAAAAAeIBCAAAAAHvAQEAAAAB8AFAAAAAAfIBAQAAAAHzAQEAAAAB9AEBAAAAAfUBCAAAAAH2AQgAAAAB9wECAAAAAfgBAgAAAAH5AQEAAAAB-gEBAAAAAfsBAQAAAAH8AQEAAAAB_QEBAAAAAf4BAQAAAAH_AQEAAAABgAIAAIMEACCBAgIAAAABggICAAAAAYMCAgAAAAGEAgIAAAABhQICAAAAAYYCIAAAAAGHAgIAAAABiAJAAAAAAYkCQAAAAAGKAiAAAAABiwIBAAAAAYwCCAAAAAGNAgEAAAABAgAAAAEAIBoAAMgEACADAAAAMQAgGgAAyAQAIBsAAMwEACAuAAAAMQAgBAAAjgMAIAUAAI8DACAGAACQAwAgBwAAkQMAIAgAAJIDACAJAACTAwAgCgAAlAMAIAsAAJUDACATAADMBAAguQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhLAQAAI4DACAFAACPAwAgBgAAkAMAIAcAAJEDACAIAACSAwAgCQAAkwMAIAoAAJQDACALAACVAwAguQEBAMwCACHAAUAAzQIAId4BAQDMAgAh4AECAOMCACHhAQIA4wIAIeIBCADkAgAh7wEBAMwCACHwAUAAzQIAIfIBAQDMAgAh8wEBAMwCACH0AQEAzAIAIfUBCADkAgAh9gEIAOQCACH3AQIA4wIAIfgBAgDjAgAh-QEBAMwCACH6AQEAzAIAIfsBAQDMAgAh_AEBAMwCACH9AQEA2wIAIf4BAQDbAgAh_wEBANsCACGAAgAAjQMAIIECAgDjAgAhggICAOMCACGDAgIA4wIAIYQCAgDjAgAhhQICAOMCACGGAiAA2gIAIYcCAgDjAgAhiAJAANkCACGJAkAA2QIAIYoCIADaAgAhiwIBAMwCACGMAggA5AIAIY0CAQDMAgAhCgQGAgUKAwYOBAcSBQgWBgkaBwoeCAsiCQwmCg0ACwEDAAEBAwABAQMAAQEDAAEBAwABAQMAAQEDAAEBAwABAQMAAQkEJwAFKAAGKQAHKgAIKwAJLAAKLQALLgAMLwAAAAAFDQAQIAARIQASIgATIwAUAAAAAAAFDQAQIAARIQASIgATIwAUAQMAAQEDAAEFDQAZIAAaIQAbIgAcIwAdAAAAAAAFDQAZIAAaIQAbIgAcIwAdAQMAAQEDAAEDDQAiIgAjIwAkAAAAAw0AIiIAIyMAJAEDAAEBAwABBQ0AKSAAKiEAKyIALCMALQAAAAAABQ0AKSAAKiEAKyIALCMALQEDAAEBAwABBQ0AMiAAMyEANCIANSMANgAAAAAABQ0AMiAAMyEANCIANSMANgEDAAEBAwABBQ0AOyAAPCEAPSIAPiMAPwAAAAAABQ0AOyAAPCEAPSIAPiMAPwEDAAEBAwABBQ0ARCAARSEARiIARyMASAAAAAAABQ0ARCAARSEARiIARyMASAEDAAEBAwABAw0ATSIATiMATwAAAAMNAE0iAE4jAE8BAwABAQMAAQMNAFQiAFUjAFYAAAADDQBUIgBVIwBWAQMAAQEDAAEDDQBbIgBcIwBdAAAAAw0AWyIAXCMAXQ4CAQ8wARAzARE0ARI1ARQ3ARU5DBY6DRc8ARg-DBk_DhxAAR1BAR5CDCRFDyVGFSZHAidIAihJAilKAipLAitNAixPDC1QFi5SAi9UDDBVFzFWAjJXAjNYDDRbGDVcHjZdAzdeAzhfAzlgAzphAztjAzxlDD1mHz5oAz9qDEBrIEFsA0JtA0NuDERxIUVyJUZzBEd0BEh1BEl2BEp3BEt5BEx7DE18Jk5-BE-AAQxQgQEnUYIBBFKDAQRThAEMVIcBKFWIAS5WiQEFV4oBBViLAQVZjAEFWo0BBVuPAQVckQEMXZIBL16UAQVflgEMYJcBMGGYAQVimQEFY5oBDGSdATFlngE3Zp8BBmegAQZooQEGaaIBBmqjAQZrpQEGbKcBDG2oAThuqgEGb6wBDHCtATlxrgEGcq8BBnOwAQx0swE6dbQBQHa1AQd3tgEHeLcBB3m4AQd6uQEHe7sBB3y9AQx9vgFBfsABB3_CAQyAAcMBQoEBxAEHggHFAQeDAcYBDIQByQFDhQHKAUmGAcsBCIcBzAEIiAHNAQiJAc4BCIoBzwEIiwHRAQiMAdMBDI0B1AFKjgHWAQiPAdgBDJAB2QFLkQHaAQiSAdsBCJMB3AEMlAHfAUyVAeABUJYB4QEJlwHiAQmYAeMBCZkB5AEJmgHlAQmbAecBCZwB6QEMnQHqAVGeAewBCZ8B7gEMoAHvAVKhAfABCaIB8QEJowHyAQykAfUBU6UB9gFXpgH3AQqnAfgBCqgB-QEKqQH6AQqqAfsBCqsB_QEKrAH_AQytAYACWK4BggIKrwGEAgywAYUCWbEBhgIKsgGHAgqzAYgCDLQBiwJatQGMAl4"
}

async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
  const { Buffer } = await import('node:buffer')
  const wasmArray = Buffer.from(wasmBase64, 'base64')
  return new WebAssembly.Module(wasmArray)
}

config.compilerWasm = {
  getRuntime: async () => await import("@prisma/client/runtime/query_compiler_fast_bg.postgresql.mjs"),

  getQueryCompilerWasmModule: async () => {
    const { wasm } = await import("@prisma/client/runtime/query_compiler_fast_bg.postgresql.wasm-base64.mjs")
    return await decodeBase64AsWasm(wasm)
  },

  importName: "./query_compiler_fast_bg.js"
}



export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   * 
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Properties
   * const properties = await prisma.property.findMany()
   * ```
   * 
   * Read more in our [docs](https://pris.ly/d/client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Properties
 * const properties = await prisma.property.findMany()
 * ```
 * 
 * Read more in our [docs](https://pris.ly/d/client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>

  $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.rehabItem`: Exposes CRUD operations for the **RehabItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RehabItems
    * const rehabItems = await prisma.rehabItem.findMany()
    * ```
    */
  get rehabItem(): Prisma.RehabItemDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.marketData`: Exposes CRUD operations for the **MarketData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketData
    * const marketData = await prisma.marketData.findMany()
    * ```
    */
  get marketData(): Prisma.MarketDataDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.rentComp`: Exposes CRUD operations for the **RentComp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentComps
    * const rentComps = await prisma.rentComp.findMany()
    * ```
    */
  get rentComp(): Prisma.RentCompDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.projection`: Exposes CRUD operations for the **Projection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projections
    * const projections = await prisma.projection.findMany()
    * ```
    */
  get projection(): Prisma.ProjectionDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.timelineEvent`: Exposes CRUD operations for the **TimelineEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimelineEvents
    * const timelineEvents = await prisma.timelineEvent.findMany()
    * ```
    */
  get timelineEvent(): Prisma.TimelineEventDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(): PrismaClientConstructor {
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}


[FILE_END: src\generated\internal\class.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\internal\prismaNamespace.ts
TYPE: TS
SIZE: 51506 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * 游띔 Under no circumstances should you import this file directly! 游띔
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.4.0
 * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.0",
  engine: "ab56fe763f921d033a6c195e7ddeb3e255bdbb57"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Property: 'Property',
  Expense: 'Expense',
  Task: 'Task',
  RehabItem: 'RehabItem',
  MarketData: 'MarketData',
  RentComp: 'RentComp',
  Projection: 'Projection',
  TimelineEvent: 'TimelineEvent',
  Comment: 'Comment',
  Document: 'Document'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "property" | "expense" | "task" | "rehabItem" | "marketData" | "rentComp" | "projection" | "timelineEvent" | "comment" | "document"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Property: {
      payload: Prisma.$PropertyPayload<ExtArgs>
      fields: Prisma.PropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findFirst: {
          args: Prisma.PropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findMany: {
          args: Prisma.PropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        create: {
          args: Prisma.PropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        createMany: {
          args: Prisma.PropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        delete: {
          args: Prisma.PropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        update: {
          args: Prisma.PropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        deleteMany: {
          args: Prisma.PropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        upsert: {
          args: Prisma.PropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        aggregate: {
          args: Prisma.PropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty>
        }
        groupBy: {
          args: Prisma.PropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCountAggregateOutputType> | number
        }
      }
    }
    Expense: {
      payload: Prisma.$ExpensePayload<ExtArgs>
      fields: Prisma.ExpenseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findFirst: {
          args: Prisma.ExpenseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findMany: {
          args: Prisma.ExpenseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        create: {
          args: Prisma.ExpenseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        createMany: {
          args: Prisma.ExpenseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        delete: {
          args: Prisma.ExpenseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        update: {
          args: Prisma.ExpenseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        deleteMany: {
          args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        upsert: {
          args: Prisma.ExpenseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        aggregate: {
          args: Prisma.ExpenseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpense>
        }
        groupBy: {
          args: Prisma.ExpenseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExpenseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCountAggregateOutputType> | number
        }
      }
    }
    Task: {
      payload: Prisma.$TaskPayload<ExtArgs>
      fields: Prisma.TaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findFirst: {
          args: Prisma.TaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findMany: {
          args: Prisma.TaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        create: {
          args: Prisma.TaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        createMany: {
          args: Prisma.TaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        delete: {
          args: Prisma.TaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        update: {
          args: Prisma.TaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        deleteMany: {
          args: Prisma.TaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        upsert: {
          args: Prisma.TaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        aggregate: {
          args: Prisma.TaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTask>
        }
        groupBy: {
          args: Prisma.TaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskCountAggregateOutputType> | number
        }
      }
    }
    RehabItem: {
      payload: Prisma.$RehabItemPayload<ExtArgs>
      fields: Prisma.RehabItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>
        }
        findFirst: {
          args: Prisma.RehabItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>
        }
        findMany: {
          args: Prisma.RehabItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>[]
        }
        create: {
          args: Prisma.RehabItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>
        }
        createMany: {
          args: Prisma.RehabItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>[]
        }
        delete: {
          args: Prisma.RehabItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>
        }
        update: {
          args: Prisma.RehabItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>
        }
        deleteMany: {
          args: Prisma.RehabItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>[]
        }
        upsert: {
          args: Prisma.RehabItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabItemPayload>
        }
        aggregate: {
          args: Prisma.RehabItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabItem>
        }
        groupBy: {
          args: Prisma.RehabItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabItemCountAggregateOutputType> | number
        }
      }
    }
    MarketData: {
      payload: Prisma.$MarketDataPayload<ExtArgs>
      fields: Prisma.MarketDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MarketDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MarketDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>
        }
        findFirst: {
          args: Prisma.MarketDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MarketDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>
        }
        findMany: {
          args: Prisma.MarketDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>[]
        }
        create: {
          args: Prisma.MarketDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>
        }
        createMany: {
          args: Prisma.MarketDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MarketDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>[]
        }
        delete: {
          args: Prisma.MarketDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>
        }
        update: {
          args: Prisma.MarketDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>
        }
        deleteMany: {
          args: Prisma.MarketDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MarketDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MarketDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>[]
        }
        upsert: {
          args: Prisma.MarketDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MarketDataPayload>
        }
        aggregate: {
          args: Prisma.MarketDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMarketData>
        }
        groupBy: {
          args: Prisma.MarketDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MarketDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.MarketDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MarketDataCountAggregateOutputType> | number
        }
      }
    }
    RentComp: {
      payload: Prisma.$RentCompPayload<ExtArgs>
      fields: Prisma.RentCompFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentCompFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentCompFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>
        }
        findFirst: {
          args: Prisma.RentCompFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentCompFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>
        }
        findMany: {
          args: Prisma.RentCompFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>[]
        }
        create: {
          args: Prisma.RentCompCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>
        }
        createMany: {
          args: Prisma.RentCompCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentCompCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>[]
        }
        delete: {
          args: Prisma.RentCompDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>
        }
        update: {
          args: Prisma.RentCompUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>
        }
        deleteMany: {
          args: Prisma.RentCompDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentCompUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentCompUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>[]
        }
        upsert: {
          args: Prisma.RentCompUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentCompPayload>
        }
        aggregate: {
          args: Prisma.RentCompAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentComp>
        }
        groupBy: {
          args: Prisma.RentCompGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentCompGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentCompCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentCompCountAggregateOutputType> | number
        }
      }
    }
    Projection: {
      payload: Prisma.$ProjectionPayload<ExtArgs>
      fields: Prisma.ProjectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>
        }
        findFirst: {
          args: Prisma.ProjectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>
        }
        findMany: {
          args: Prisma.ProjectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>[]
        }
        create: {
          args: Prisma.ProjectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>
        }
        createMany: {
          args: Prisma.ProjectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>[]
        }
        delete: {
          args: Prisma.ProjectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>
        }
        update: {
          args: Prisma.ProjectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>
        }
        deleteMany: {
          args: Prisma.ProjectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>[]
        }
        upsert: {
          args: Prisma.ProjectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectionPayload>
        }
        aggregate: {
          args: Prisma.ProjectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjection>
        }
        groupBy: {
          args: Prisma.ProjectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectionCountAggregateOutputType> | number
        }
      }
    }
    TimelineEvent: {
      payload: Prisma.$TimelineEventPayload<ExtArgs>
      fields: Prisma.TimelineEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimelineEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimelineEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>
        }
        findFirst: {
          args: Prisma.TimelineEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimelineEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>
        }
        findMany: {
          args: Prisma.TimelineEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
        }
        create: {
          args: Prisma.TimelineEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>
        }
        createMany: {
          args: Prisma.TimelineEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimelineEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
        }
        delete: {
          args: Prisma.TimelineEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>
        }
        update: {
          args: Prisma.TimelineEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>
        }
        deleteMany: {
          args: Prisma.TimelineEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimelineEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimelineEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>[]
        }
        upsert: {
          args: Prisma.TimelineEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelineEventPayload>
        }
        aggregate: {
          args: Prisma.TimelineEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimelineEvent>
        }
        groupBy: {
          args: Prisma.TimelineEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimelineEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimelineEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimelineEventCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    Document: {
      payload: Prisma.$DocumentPayload<ExtArgs>
      fields: Prisma.DocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findFirst: {
          args: Prisma.DocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findMany: {
          args: Prisma.DocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        create: {
          args: Prisma.DocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        createMany: {
          args: Prisma.DocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        delete: {
          args: Prisma.DocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        update: {
          args: Prisma.DocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        deleteMany: {
          args: Prisma.DocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        upsert: {
          args: Prisma.DocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        aggregate: {
          args: Prisma.DocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocument>
        }
        groupBy: {
          args: Prisma.DocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const PropertyScalarFieldEnum = {
  id: 'id',
  address: 'address',
  city: 'city',
  state: 'state',
  zip: 'zip',
  lat: 'lat',
  lng: 'lng',
  listPrice: 'listPrice',
  equityGap: 'equityGap',
  sqft: 'sqft',
  bedrooms: 'bedrooms',
  bathrooms: 'bathrooms',
  decision: 'decision',
  strategy: 'strategy',
  rationale: 'rationale',
  type: 'type',
  realtor: 'realtor',
  url: 'url',
  details: 'details',
  images: 'images',
  estimatedRent: 'estimatedRent',
  annualTaxes: 'annualTaxes',
  annualInsurance: 'annualInsurance',
  renovationBudget: 'renovationBudget',
  afterRepairValue: 'afterRepairValue',
  notes: 'notes',
  isOwned: 'isOwned',
  purchasePrice: 'purchasePrice',
  purchaseDate: 'purchaseDate',
  rehabCompleted: 'rehabCompleted',
  isFavorite: 'isFavorite',
  favoriteNotes: 'favoriteNotes',
  dealScore: 'dealScore',
  riskLevel: 'riskLevel',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


export const ExpenseScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  category: 'category',
  amount: 'amount',
  description: 'description',
  createdAt: 'createdAt'
} as const

export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


export const TaskScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  title: 'title',
  isCompleted: 'isCompleted',
  createdAt: 'createdAt'
} as const

export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


export const RehabItemScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  category: 'category',
  item: 'item',
  quantity: 'quantity',
  unitCost: 'unitCost',
  totalCost: 'totalCost',
  isCompleted: 'isCompleted',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabItemScalarFieldEnum = (typeof RehabItemScalarFieldEnum)[keyof typeof RehabItemScalarFieldEnum]


export const MarketDataScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  neighborhood: 'neighborhood',
  avgDaysOnMarket: 'avgDaysOnMarket',
  avgPricePerSqft: 'avgPricePerSqft',
  priceTrend: 'priceTrend',
  inventory: 'inventory',
  dataDate: 'dataDate'
} as const

export type MarketDataScalarFieldEnum = (typeof MarketDataScalarFieldEnum)[keyof typeof MarketDataScalarFieldEnum]


export const RentCompScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  address: 'address',
  rentAmount: 'rentAmount',
  sqft: 'sqft',
  bedrooms: 'bedrooms',
  bathrooms: 'bathrooms',
  distance: 'distance',
  source: 'source',
  createdAt: 'createdAt'
} as const

export type RentCompScalarFieldEnum = (typeof RentCompScalarFieldEnum)[keyof typeof RentCompScalarFieldEnum]


export const ProjectionScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  year: 'year',
  monthlyRent: 'monthlyRent',
  vacancyRate: 'vacancyRate',
  operatingExpenses: 'operatingExpenses',
  mortgagePayment: 'mortgagePayment',
  cashFlow: 'cashFlow',
  equityBuild: 'equityBuild',
  totalReturn: 'totalReturn',
  createdAt: 'createdAt'
} as const

export type ProjectionScalarFieldEnum = (typeof ProjectionScalarFieldEnum)[keyof typeof ProjectionScalarFieldEnum]


export const TimelineEventScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  title: 'title',
  description: 'description',
  eventType: 'eventType',
  startDate: 'startDate',
  endDate: 'endDate',
  isCompleted: 'isCompleted',
  assignedTo: 'assignedTo',
  createdAt: 'createdAt'
} as const

export type TimelineEventScalarFieldEnum = (typeof TimelineEventScalarFieldEnum)[keyof typeof TimelineEventScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  userId: 'userId',
  userName: 'userName',
  content: 'content',
  createdAt: 'createdAt'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const DocumentScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  fileName: 'fileName',
  fileUrl: 'fileUrl',
  fileType: 'fileType',
  category: 'category',
  uploadedBy: 'uploadedBy',
  createdAt: 'createdAt'
} as const

export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  property?: Prisma.PropertyOmit
  expense?: Prisma.ExpenseOmit
  task?: Prisma.TaskOmit
  rehabItem?: Prisma.RehabItemOmit
  marketData?: Prisma.MarketDataOmit
  rentComp?: Prisma.RentCompOmit
  projection?: Prisma.ProjectionOmit
  timelineEvent?: Prisma.TimelineEventOmit
  comment?: Prisma.CommentOmit
  document?: Prisma.DocumentOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>



[FILE_END: src\generated\internal\prismaNamespace.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\internal\prismaNamespaceBrowser.ts
TYPE: TS
SIZE: 7458 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * 游띔 Under no circumstances should you import this file directly! 游띔
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the browser.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/index-browser"

export type * from '../models'
export type * from './prismaNamespace'

export const Decimal = runtime.Decimal


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


export const ModelName = {
  Property: 'Property',
  Expense: 'Expense',
  Task: 'Task',
  RehabItem: 'RehabItem',
  MarketData: 'MarketData',
  RentComp: 'RentComp',
  Projection: 'Projection',
  TimelineEvent: 'TimelineEvent',
  Comment: 'Comment',
  Document: 'Document'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]

/*
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const PropertyScalarFieldEnum = {
  id: 'id',
  address: 'address',
  city: 'city',
  state: 'state',
  zip: 'zip',
  lat: 'lat',
  lng: 'lng',
  listPrice: 'listPrice',
  equityGap: 'equityGap',
  sqft: 'sqft',
  bedrooms: 'bedrooms',
  bathrooms: 'bathrooms',
  decision: 'decision',
  strategy: 'strategy',
  rationale: 'rationale',
  type: 'type',
  realtor: 'realtor',
  url: 'url',
  details: 'details',
  images: 'images',
  estimatedRent: 'estimatedRent',
  annualTaxes: 'annualTaxes',
  annualInsurance: 'annualInsurance',
  renovationBudget: 'renovationBudget',
  afterRepairValue: 'afterRepairValue',
  notes: 'notes',
  isOwned: 'isOwned',
  purchasePrice: 'purchasePrice',
  purchaseDate: 'purchaseDate',
  rehabCompleted: 'rehabCompleted',
  isFavorite: 'isFavorite',
  favoriteNotes: 'favoriteNotes',
  dealScore: 'dealScore',
  riskLevel: 'riskLevel',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


export const ExpenseScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  category: 'category',
  amount: 'amount',
  description: 'description',
  createdAt: 'createdAt'
} as const

export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


export const TaskScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  title: 'title',
  isCompleted: 'isCompleted',
  createdAt: 'createdAt'
} as const

export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


export const RehabItemScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  category: 'category',
  item: 'item',
  quantity: 'quantity',
  unitCost: 'unitCost',
  totalCost: 'totalCost',
  isCompleted: 'isCompleted',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabItemScalarFieldEnum = (typeof RehabItemScalarFieldEnum)[keyof typeof RehabItemScalarFieldEnum]


export const MarketDataScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  neighborhood: 'neighborhood',
  avgDaysOnMarket: 'avgDaysOnMarket',
  avgPricePerSqft: 'avgPricePerSqft',
  priceTrend: 'priceTrend',
  inventory: 'inventory',
  dataDate: 'dataDate'
} as const

export type MarketDataScalarFieldEnum = (typeof MarketDataScalarFieldEnum)[keyof typeof MarketDataScalarFieldEnum]


export const RentCompScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  address: 'address',
  rentAmount: 'rentAmount',
  sqft: 'sqft',
  bedrooms: 'bedrooms',
  bathrooms: 'bathrooms',
  distance: 'distance',
  source: 'source',
  createdAt: 'createdAt'
} as const

export type RentCompScalarFieldEnum = (typeof RentCompScalarFieldEnum)[keyof typeof RentCompScalarFieldEnum]


export const ProjectionScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  year: 'year',
  monthlyRent: 'monthlyRent',
  vacancyRate: 'vacancyRate',
  operatingExpenses: 'operatingExpenses',
  mortgagePayment: 'mortgagePayment',
  cashFlow: 'cashFlow',
  equityBuild: 'equityBuild',
  totalReturn: 'totalReturn',
  createdAt: 'createdAt'
} as const

export type ProjectionScalarFieldEnum = (typeof ProjectionScalarFieldEnum)[keyof typeof ProjectionScalarFieldEnum]


export const TimelineEventScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  title: 'title',
  description: 'description',
  eventType: 'eventType',
  startDate: 'startDate',
  endDate: 'endDate',
  isCompleted: 'isCompleted',
  assignedTo: 'assignedTo',
  createdAt: 'createdAt'
} as const

export type TimelineEventScalarFieldEnum = (typeof TimelineEventScalarFieldEnum)[keyof typeof TimelineEventScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  userId: 'userId',
  userName: 'userName',
  content: 'content',
  createdAt: 'createdAt'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const DocumentScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  fileName: 'fileName',
  fileUrl: 'fileUrl',
  fileType: 'fileType',
  category: 'category',
  uploadedBy: 'uploadedBy',
  createdAt: 'createdAt'
} as const

export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



[FILE_END: src\generated\internal\prismaNamespaceBrowser.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\Comment.ts
TYPE: TS
SIZE: 49694 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Comment` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Comment
 * 
 */
export type CommentModel = runtime.Types.Result.DefaultSelection<Prisma.$CommentPayload>

export type AggregateComment = {
  _count: CommentCountAggregateOutputType | null
  _min: CommentMinAggregateOutputType | null
  _max: CommentMaxAggregateOutputType | null
}

export type CommentMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  userId: string | null
  userName: string | null
  content: string | null
  createdAt: Date | null
}

export type CommentMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  userId: string | null
  userName: string | null
  content: string | null
  createdAt: Date | null
}

export type CommentCountAggregateOutputType = {
  id: number
  propertyId: number
  userId: number
  userName: number
  content: number
  createdAt: number
  _all: number
}


export type CommentMinAggregateInputType = {
  id?: true
  propertyId?: true
  userId?: true
  userName?: true
  content?: true
  createdAt?: true
}

export type CommentMaxAggregateInputType = {
  id?: true
  propertyId?: true
  userId?: true
  userName?: true
  content?: true
  createdAt?: true
}

export type CommentCountAggregateInputType = {
  id?: true
  propertyId?: true
  userId?: true
  userName?: true
  content?: true
  createdAt?: true
  _all?: true
}

export type CommentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Comment to aggregate.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Comments
  **/
  _count?: true | CommentCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CommentMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CommentMaxAggregateInputType
}

export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
      [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateComment[P]>
    : Prisma.GetScalarType<T[P], AggregateComment[P]>
}




export type CommentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentWhereInput
  orderBy?: Prisma.CommentOrderByWithAggregationInput | Prisma.CommentOrderByWithAggregationInput[]
  by: Prisma.CommentScalarFieldEnum[] | Prisma.CommentScalarFieldEnum
  having?: Prisma.CommentScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CommentCountAggregateInputType | true
  _min?: CommentMinAggregateInputType
  _max?: CommentMaxAggregateInputType
}

export type CommentGroupByOutputType = {
  id: string
  propertyId: string
  userId: string
  userName: string
  content: string
  createdAt: Date
  _count: CommentCountAggregateOutputType | null
  _min: CommentMinAggregateOutputType | null
  _max: CommentMaxAggregateOutputType | null
}

type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CommentGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CommentGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CommentGroupByOutputType[P]>
      }
    >
  >



export type CommentWhereInput = {
  AND?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  OR?: Prisma.CommentWhereInput[]
  NOT?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  id?: Prisma.StringFilter<"Comment"> | string
  propertyId?: Prisma.StringFilter<"Comment"> | string
  userId?: Prisma.StringFilter<"Comment"> | string
  userName?: Prisma.StringFilter<"Comment"> | string
  content?: Prisma.StringFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeFilter<"Comment"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type CommentOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  userName?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type CommentWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  OR?: Prisma.CommentWhereInput[]
  NOT?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  propertyId?: Prisma.StringFilter<"Comment"> | string
  userId?: Prisma.StringFilter<"Comment"> | string
  userName?: Prisma.StringFilter<"Comment"> | string
  content?: Prisma.StringFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeFilter<"Comment"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type CommentOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  userName?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.CommentCountOrderByAggregateInput
  _max?: Prisma.CommentMaxOrderByAggregateInput
  _min?: Prisma.CommentMinOrderByAggregateInput
}

export type CommentScalarWhereWithAggregatesInput = {
  AND?: Prisma.CommentScalarWhereWithAggregatesInput | Prisma.CommentScalarWhereWithAggregatesInput[]
  OR?: Prisma.CommentScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CommentScalarWhereWithAggregatesInput | Prisma.CommentScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Comment"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"Comment"> | string
  userId?: Prisma.StringWithAggregatesFilter<"Comment"> | string
  userName?: Prisma.StringWithAggregatesFilter<"Comment"> | string
  content?: Prisma.StringWithAggregatesFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Comment"> | Date | string
}

export type CommentCreateInput = {
  id?: string
  userId: string
  userName: string
  content: string
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutCommentsInput
}

export type CommentUncheckedCreateInput = {
  id?: string
  propertyId: string
  userId: string
  userName: string
  content: string
  createdAt?: Date | string
}

export type CommentUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutCommentsNestedInput
}

export type CommentUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentCreateManyInput = {
  id?: string
  propertyId: string
  userId: string
  userName: string
  content: string
  createdAt?: Date | string
}

export type CommentUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentListRelationFilter = {
  every?: Prisma.CommentWhereInput
  some?: Prisma.CommentWhereInput
  none?: Prisma.CommentWhereInput
}

export type CommentOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CommentCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  userName?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type CommentMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  userName?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type CommentMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  userName?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type CommentCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutPropertyInput, Prisma.CommentUncheckedCreateWithoutPropertyInput> | Prisma.CommentCreateWithoutPropertyInput[] | Prisma.CommentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutPropertyInput | Prisma.CommentCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.CommentCreateManyPropertyInputEnvelope
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
}

export type CommentUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutPropertyInput, Prisma.CommentUncheckedCreateWithoutPropertyInput> | Prisma.CommentCreateWithoutPropertyInput[] | Prisma.CommentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutPropertyInput | Prisma.CommentCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.CommentCreateManyPropertyInputEnvelope
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
}

export type CommentUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutPropertyInput, Prisma.CommentUncheckedCreateWithoutPropertyInput> | Prisma.CommentCreateWithoutPropertyInput[] | Prisma.CommentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutPropertyInput | Prisma.CommentCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.CommentUpsertWithWhereUniqueWithoutPropertyInput | Prisma.CommentUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.CommentCreateManyPropertyInputEnvelope
  set?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  disconnect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  delete?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  update?: Prisma.CommentUpdateWithWhereUniqueWithoutPropertyInput | Prisma.CommentUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.CommentUpdateManyWithWhereWithoutPropertyInput | Prisma.CommentUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
}

export type CommentUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutPropertyInput, Prisma.CommentUncheckedCreateWithoutPropertyInput> | Prisma.CommentCreateWithoutPropertyInput[] | Prisma.CommentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutPropertyInput | Prisma.CommentCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.CommentUpsertWithWhereUniqueWithoutPropertyInput | Prisma.CommentUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.CommentCreateManyPropertyInputEnvelope
  set?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  disconnect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  delete?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  update?: Prisma.CommentUpdateWithWhereUniqueWithoutPropertyInput | Prisma.CommentUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.CommentUpdateManyWithWhereWithoutPropertyInput | Prisma.CommentUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
}

export type CommentCreateWithoutPropertyInput = {
  id?: string
  userId: string
  userName: string
  content: string
  createdAt?: Date | string
}

export type CommentUncheckedCreateWithoutPropertyInput = {
  id?: string
  userId: string
  userName: string
  content: string
  createdAt?: Date | string
}

export type CommentCreateOrConnectWithoutPropertyInput = {
  where: Prisma.CommentWhereUniqueInput
  create: Prisma.XOR<Prisma.CommentCreateWithoutPropertyInput, Prisma.CommentUncheckedCreateWithoutPropertyInput>
}

export type CommentCreateManyPropertyInputEnvelope = {
  data: Prisma.CommentCreateManyPropertyInput | Prisma.CommentCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type CommentUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.CommentWhereUniqueInput
  update: Prisma.XOR<Prisma.CommentUpdateWithoutPropertyInput, Prisma.CommentUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.CommentCreateWithoutPropertyInput, Prisma.CommentUncheckedCreateWithoutPropertyInput>
}

export type CommentUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.CommentWhereUniqueInput
  data: Prisma.XOR<Prisma.CommentUpdateWithoutPropertyInput, Prisma.CommentUncheckedUpdateWithoutPropertyInput>
}

export type CommentUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.CommentScalarWhereInput
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyWithoutPropertyInput>
}

export type CommentScalarWhereInput = {
  AND?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
  OR?: Prisma.CommentScalarWhereInput[]
  NOT?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
  id?: Prisma.StringFilter<"Comment"> | string
  propertyId?: Prisma.StringFilter<"Comment"> | string
  userId?: Prisma.StringFilter<"Comment"> | string
  userName?: Prisma.StringFilter<"Comment"> | string
  content?: Prisma.StringFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeFilter<"Comment"> | Date | string
}

export type CommentCreateManyPropertyInput = {
  id?: string
  userId: string
  userName: string
  content: string
  createdAt?: Date | string
}

export type CommentUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  userName?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type CommentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  userId?: boolean
  userName?: boolean
  content?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["comment"]>

export type CommentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  userId?: boolean
  userName?: boolean
  content?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["comment"]>

export type CommentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  userId?: boolean
  userName?: boolean
  content?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["comment"]>

export type CommentSelectScalar = {
  id?: boolean
  propertyId?: boolean
  userId?: boolean
  userName?: boolean
  content?: boolean
  createdAt?: boolean
}

export type CommentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "userId" | "userName" | "content" | "createdAt", ExtArgs["result"]["comment"]>
export type CommentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type CommentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type CommentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $CommentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Comment"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    userId: string
    userName: string
    content: string
    createdAt: Date
  }, ExtArgs["result"]["comment"]>
  composites: {}
}

export type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CommentPayload, S>

export type CommentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CommentCountAggregateInputType | true
  }

export interface CommentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
  /**
   * Find zero or one Comment that matches the filter.
   * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CommentFindUniqueArgs>(args: Prisma.SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Comment that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentFindFirstArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CommentFindFirstArgs>(args?: Prisma.SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Comment that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Comments that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Comments
   * const comments = await prisma.comment.findMany()
   * 
   * // Get first 10 Comments
   * const comments = await prisma.comment.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CommentFindManyArgs>(args?: Prisma.SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Comment.
   * @param {CommentCreateArgs} args - Arguments to create a Comment.
   * @example
   * // Create one Comment
   * const Comment = await prisma.comment.create({
   *   data: {
   *     // ... data to create a Comment
   *   }
   * })
   * 
   */
  create<T extends CommentCreateArgs>(args: Prisma.SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Comments.
   * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
   * @example
   * // Create many Comments
   * const comment = await prisma.comment.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CommentCreateManyArgs>(args?: Prisma.SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Comments and returns the data saved in the database.
   * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
   * @example
   * // Create many Comments
   * const comment = await prisma.comment.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Comments and only return the `id`
   * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Comment.
   * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
   * @example
   * // Delete one Comment
   * const Comment = await prisma.comment.delete({
   *   where: {
   *     // ... filter to delete one Comment
   *   }
   * })
   * 
   */
  delete<T extends CommentDeleteArgs>(args: Prisma.SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Comment.
   * @param {CommentUpdateArgs} args - Arguments to update one Comment.
   * @example
   * // Update one Comment
   * const comment = await prisma.comment.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CommentUpdateArgs>(args: Prisma.SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Comments.
   * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
   * @example
   * // Delete a few Comments
   * const { count } = await prisma.comment.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CommentDeleteManyArgs>(args?: Prisma.SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Comments.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Comments
   * const comment = await prisma.comment.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CommentUpdateManyArgs>(args: Prisma.SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Comments and returns the data updated in the database.
   * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
   * @example
   * // Update many Comments
   * const comment = await prisma.comment.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Comments and only return the `id`
   * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Comment.
   * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
   * @example
   * // Update or create a Comment
   * const comment = await prisma.comment.upsert({
   *   create: {
   *     // ... data to create a Comment
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Comment we want to update
   *   }
   * })
   */
  upsert<T extends CommentUpsertArgs>(args: Prisma.SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Comments.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentCountArgs} args - Arguments to filter Comments to count.
   * @example
   * // Count the number of Comments
   * const count = await prisma.comment.count({
   *   where: {
   *     // ... the filter for the Comments we want to count
   *   }
   * })
  **/
  count<T extends CommentCountArgs>(
    args?: Prisma.Subset<T, CommentCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CommentCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Comment.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CommentAggregateArgs>(args: Prisma.Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

  /**
   * Group by Comment.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CommentGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CommentGroupByArgs['orderBy'] }
      : { orderBy?: CommentGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Comment model
 */
readonly fields: CommentFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Comment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CommentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Comment model
 */
export interface CommentFieldRefs {
  readonly id: Prisma.FieldRef<"Comment", 'String'>
  readonly propertyId: Prisma.FieldRef<"Comment", 'String'>
  readonly userId: Prisma.FieldRef<"Comment", 'String'>
  readonly userName: Prisma.FieldRef<"Comment", 'String'>
  readonly content: Prisma.FieldRef<"Comment", 'String'>
  readonly createdAt: Prisma.FieldRef<"Comment", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Comment findUnique
 */
export type CommentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment findUniqueOrThrow
 */
export type CommentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment findFirst
 */
export type CommentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Comments.
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Comments.
   */
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Comment findFirstOrThrow
 */
export type CommentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Comments.
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Comments.
   */
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Comment findMany
 */
export type CommentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comments to fetch.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Comments.
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Comment create
 */
export type CommentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * The data needed to create a Comment.
   */
  data: Prisma.XOR<Prisma.CommentCreateInput, Prisma.CommentUncheckedCreateInput>
}

/**
 * Comment createMany
 */
export type CommentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Comments.
   */
  data: Prisma.CommentCreateManyInput | Prisma.CommentCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Comment createManyAndReturn
 */
export type CommentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * The data used to create many Comments.
   */
  data: Prisma.CommentCreateManyInput | Prisma.CommentCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Comment update
 */
export type CommentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * The data needed to update a Comment.
   */
  data: Prisma.XOR<Prisma.CommentUpdateInput, Prisma.CommentUncheckedUpdateInput>
  /**
   * Choose, which Comment to update.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment updateMany
 */
export type CommentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Comments.
   */
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyInput>
  /**
   * Filter which Comments to update
   */
  where?: Prisma.CommentWhereInput
  /**
   * Limit how many Comments to update.
   */
  limit?: number
}

/**
 * Comment updateManyAndReturn
 */
export type CommentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * The data used to update Comments.
   */
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyInput>
  /**
   * Filter which Comments to update
   */
  where?: Prisma.CommentWhereInput
  /**
   * Limit how many Comments to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Comment upsert
 */
export type CommentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * The filter to search for the Comment to update in case it exists.
   */
  where: Prisma.CommentWhereUniqueInput
  /**
   * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
   */
  create: Prisma.XOR<Prisma.CommentCreateInput, Prisma.CommentUncheckedCreateInput>
  /**
   * In case the Comment was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CommentUpdateInput, Prisma.CommentUncheckedUpdateInput>
}

/**
 * Comment delete
 */
export type CommentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter which Comment to delete.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment deleteMany
 */
export type CommentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Comments to delete
   */
  where?: Prisma.CommentWhereInput
  /**
   * Limit how many Comments to delete.
   */
  limit?: number
}

/**
 * Comment without action
 */
export type CommentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\Comment.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\Document.ts
TYPE: TS
SIZE: 52921 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Document` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Document
 * 
 */
export type DocumentModel = runtime.Types.Result.DefaultSelection<Prisma.$DocumentPayload>

export type AggregateDocument = {
  _count: DocumentCountAggregateOutputType | null
  _min: DocumentMinAggregateOutputType | null
  _max: DocumentMaxAggregateOutputType | null
}

export type DocumentMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  fileName: string | null
  fileUrl: string | null
  fileType: string | null
  category: string | null
  uploadedBy: string | null
  createdAt: Date | null
}

export type DocumentMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  fileName: string | null
  fileUrl: string | null
  fileType: string | null
  category: string | null
  uploadedBy: string | null
  createdAt: Date | null
}

export type DocumentCountAggregateOutputType = {
  id: number
  propertyId: number
  fileName: number
  fileUrl: number
  fileType: number
  category: number
  uploadedBy: number
  createdAt: number
  _all: number
}


export type DocumentMinAggregateInputType = {
  id?: true
  propertyId?: true
  fileName?: true
  fileUrl?: true
  fileType?: true
  category?: true
  uploadedBy?: true
  createdAt?: true
}

export type DocumentMaxAggregateInputType = {
  id?: true
  propertyId?: true
  fileName?: true
  fileUrl?: true
  fileType?: true
  category?: true
  uploadedBy?: true
  createdAt?: true
}

export type DocumentCountAggregateInputType = {
  id?: true
  propertyId?: true
  fileName?: true
  fileUrl?: true
  fileType?: true
  category?: true
  uploadedBy?: true
  createdAt?: true
  _all?: true
}

export type DocumentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Document to aggregate.
   */
  where?: Prisma.DocumentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Documents to fetch.
   */
  orderBy?: Prisma.DocumentOrderByWithRelationInput | Prisma.DocumentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.DocumentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Documents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Documents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Documents
  **/
  _count?: true | DocumentCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: DocumentMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: DocumentMaxAggregateInputType
}

export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
      [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateDocument[P]>
    : Prisma.GetScalarType<T[P], AggregateDocument[P]>
}




export type DocumentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.DocumentWhereInput
  orderBy?: Prisma.DocumentOrderByWithAggregationInput | Prisma.DocumentOrderByWithAggregationInput[]
  by: Prisma.DocumentScalarFieldEnum[] | Prisma.DocumentScalarFieldEnum
  having?: Prisma.DocumentScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: DocumentCountAggregateInputType | true
  _min?: DocumentMinAggregateInputType
  _max?: DocumentMaxAggregateInputType
}

export type DocumentGroupByOutputType = {
  id: string
  propertyId: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt: Date
  _count: DocumentCountAggregateOutputType | null
  _min: DocumentMinAggregateOutputType | null
  _max: DocumentMaxAggregateOutputType | null
}

type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<DocumentGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], DocumentGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], DocumentGroupByOutputType[P]>
      }
    >
  >



export type DocumentWhereInput = {
  AND?: Prisma.DocumentWhereInput | Prisma.DocumentWhereInput[]
  OR?: Prisma.DocumentWhereInput[]
  NOT?: Prisma.DocumentWhereInput | Prisma.DocumentWhereInput[]
  id?: Prisma.StringFilter<"Document"> | string
  propertyId?: Prisma.StringFilter<"Document"> | string
  fileName?: Prisma.StringFilter<"Document"> | string
  fileUrl?: Prisma.StringFilter<"Document"> | string
  fileType?: Prisma.StringFilter<"Document"> | string
  category?: Prisma.StringFilter<"Document"> | string
  uploadedBy?: Prisma.StringFilter<"Document"> | string
  createdAt?: Prisma.DateTimeFilter<"Document"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type DocumentOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  fileUrl?: Prisma.SortOrder
  fileType?: Prisma.SortOrder
  category?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type DocumentWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.DocumentWhereInput | Prisma.DocumentWhereInput[]
  OR?: Prisma.DocumentWhereInput[]
  NOT?: Prisma.DocumentWhereInput | Prisma.DocumentWhereInput[]
  propertyId?: Prisma.StringFilter<"Document"> | string
  fileName?: Prisma.StringFilter<"Document"> | string
  fileUrl?: Prisma.StringFilter<"Document"> | string
  fileType?: Prisma.StringFilter<"Document"> | string
  category?: Prisma.StringFilter<"Document"> | string
  uploadedBy?: Prisma.StringFilter<"Document"> | string
  createdAt?: Prisma.DateTimeFilter<"Document"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type DocumentOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  fileUrl?: Prisma.SortOrder
  fileType?: Prisma.SortOrder
  category?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.DocumentCountOrderByAggregateInput
  _max?: Prisma.DocumentMaxOrderByAggregateInput
  _min?: Prisma.DocumentMinOrderByAggregateInput
}

export type DocumentScalarWhereWithAggregatesInput = {
  AND?: Prisma.DocumentScalarWhereWithAggregatesInput | Prisma.DocumentScalarWhereWithAggregatesInput[]
  OR?: Prisma.DocumentScalarWhereWithAggregatesInput[]
  NOT?: Prisma.DocumentScalarWhereWithAggregatesInput | Prisma.DocumentScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Document"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"Document"> | string
  fileName?: Prisma.StringWithAggregatesFilter<"Document"> | string
  fileUrl?: Prisma.StringWithAggregatesFilter<"Document"> | string
  fileType?: Prisma.StringWithAggregatesFilter<"Document"> | string
  category?: Prisma.StringWithAggregatesFilter<"Document"> | string
  uploadedBy?: Prisma.StringWithAggregatesFilter<"Document"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Document"> | Date | string
}

export type DocumentCreateInput = {
  id?: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutDocumentsInput
}

export type DocumentUncheckedCreateInput = {
  id?: string
  propertyId: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt?: Date | string
}

export type DocumentUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutDocumentsNestedInput
}

export type DocumentUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DocumentCreateManyInput = {
  id?: string
  propertyId: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt?: Date | string
}

export type DocumentUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DocumentUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DocumentListRelationFilter = {
  every?: Prisma.DocumentWhereInput
  some?: Prisma.DocumentWhereInput
  none?: Prisma.DocumentWhereInput
}

export type DocumentOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type DocumentCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  fileUrl?: Prisma.SortOrder
  fileType?: Prisma.SortOrder
  category?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DocumentMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  fileUrl?: Prisma.SortOrder
  fileType?: Prisma.SortOrder
  category?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DocumentMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  fileName?: Prisma.SortOrder
  fileUrl?: Prisma.SortOrder
  fileType?: Prisma.SortOrder
  category?: Prisma.SortOrder
  uploadedBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DocumentCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.DocumentCreateWithoutPropertyInput, Prisma.DocumentUncheckedCreateWithoutPropertyInput> | Prisma.DocumentCreateWithoutPropertyInput[] | Prisma.DocumentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.DocumentCreateOrConnectWithoutPropertyInput | Prisma.DocumentCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.DocumentCreateManyPropertyInputEnvelope
  connect?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
}

export type DocumentUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.DocumentCreateWithoutPropertyInput, Prisma.DocumentUncheckedCreateWithoutPropertyInput> | Prisma.DocumentCreateWithoutPropertyInput[] | Prisma.DocumentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.DocumentCreateOrConnectWithoutPropertyInput | Prisma.DocumentCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.DocumentCreateManyPropertyInputEnvelope
  connect?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
}

export type DocumentUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.DocumentCreateWithoutPropertyInput, Prisma.DocumentUncheckedCreateWithoutPropertyInput> | Prisma.DocumentCreateWithoutPropertyInput[] | Prisma.DocumentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.DocumentCreateOrConnectWithoutPropertyInput | Prisma.DocumentCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.DocumentUpsertWithWhereUniqueWithoutPropertyInput | Prisma.DocumentUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.DocumentCreateManyPropertyInputEnvelope
  set?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  disconnect?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  delete?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  connect?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  update?: Prisma.DocumentUpdateWithWhereUniqueWithoutPropertyInput | Prisma.DocumentUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.DocumentUpdateManyWithWhereWithoutPropertyInput | Prisma.DocumentUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.DocumentScalarWhereInput | Prisma.DocumentScalarWhereInput[]
}

export type DocumentUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.DocumentCreateWithoutPropertyInput, Prisma.DocumentUncheckedCreateWithoutPropertyInput> | Prisma.DocumentCreateWithoutPropertyInput[] | Prisma.DocumentUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.DocumentCreateOrConnectWithoutPropertyInput | Prisma.DocumentCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.DocumentUpsertWithWhereUniqueWithoutPropertyInput | Prisma.DocumentUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.DocumentCreateManyPropertyInputEnvelope
  set?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  disconnect?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  delete?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  connect?: Prisma.DocumentWhereUniqueInput | Prisma.DocumentWhereUniqueInput[]
  update?: Prisma.DocumentUpdateWithWhereUniqueWithoutPropertyInput | Prisma.DocumentUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.DocumentUpdateManyWithWhereWithoutPropertyInput | Prisma.DocumentUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.DocumentScalarWhereInput | Prisma.DocumentScalarWhereInput[]
}

export type DocumentCreateWithoutPropertyInput = {
  id?: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt?: Date | string
}

export type DocumentUncheckedCreateWithoutPropertyInput = {
  id?: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt?: Date | string
}

export type DocumentCreateOrConnectWithoutPropertyInput = {
  where: Prisma.DocumentWhereUniqueInput
  create: Prisma.XOR<Prisma.DocumentCreateWithoutPropertyInput, Prisma.DocumentUncheckedCreateWithoutPropertyInput>
}

export type DocumentCreateManyPropertyInputEnvelope = {
  data: Prisma.DocumentCreateManyPropertyInput | Prisma.DocumentCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type DocumentUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.DocumentWhereUniqueInput
  update: Prisma.XOR<Prisma.DocumentUpdateWithoutPropertyInput, Prisma.DocumentUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.DocumentCreateWithoutPropertyInput, Prisma.DocumentUncheckedCreateWithoutPropertyInput>
}

export type DocumentUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.DocumentWhereUniqueInput
  data: Prisma.XOR<Prisma.DocumentUpdateWithoutPropertyInput, Prisma.DocumentUncheckedUpdateWithoutPropertyInput>
}

export type DocumentUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.DocumentScalarWhereInput
  data: Prisma.XOR<Prisma.DocumentUpdateManyMutationInput, Prisma.DocumentUncheckedUpdateManyWithoutPropertyInput>
}

export type DocumentScalarWhereInput = {
  AND?: Prisma.DocumentScalarWhereInput | Prisma.DocumentScalarWhereInput[]
  OR?: Prisma.DocumentScalarWhereInput[]
  NOT?: Prisma.DocumentScalarWhereInput | Prisma.DocumentScalarWhereInput[]
  id?: Prisma.StringFilter<"Document"> | string
  propertyId?: Prisma.StringFilter<"Document"> | string
  fileName?: Prisma.StringFilter<"Document"> | string
  fileUrl?: Prisma.StringFilter<"Document"> | string
  fileType?: Prisma.StringFilter<"Document"> | string
  category?: Prisma.StringFilter<"Document"> | string
  uploadedBy?: Prisma.StringFilter<"Document"> | string
  createdAt?: Prisma.DateTimeFilter<"Document"> | Date | string
}

export type DocumentCreateManyPropertyInput = {
  id?: string
  fileName: string
  fileUrl: string
  fileType: string
  category: string
  uploadedBy: string
  createdAt?: Date | string
}

export type DocumentUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DocumentUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DocumentUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fileName?: Prisma.StringFieldUpdateOperationsInput | string
  fileUrl?: Prisma.StringFieldUpdateOperationsInput | string
  fileType?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  uploadedBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type DocumentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  fileName?: boolean
  fileUrl?: boolean
  fileType?: boolean
  category?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["document"]>

export type DocumentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  fileName?: boolean
  fileUrl?: boolean
  fileType?: boolean
  category?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["document"]>

export type DocumentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  fileName?: boolean
  fileUrl?: boolean
  fileType?: boolean
  category?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["document"]>

export type DocumentSelectScalar = {
  id?: boolean
  propertyId?: boolean
  fileName?: boolean
  fileUrl?: boolean
  fileType?: boolean
  category?: boolean
  uploadedBy?: boolean
  createdAt?: boolean
}

export type DocumentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "fileName" | "fileUrl" | "fileType" | "category" | "uploadedBy" | "createdAt", ExtArgs["result"]["document"]>
export type DocumentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type DocumentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $DocumentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    fileName: string
    fileUrl: string
    fileType: string
    category: string
    uploadedBy: string
    createdAt: Date
  }, ExtArgs["result"]["document"]>
  composites: {}
}

export type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$DocumentPayload, S>

export type DocumentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DocumentCountAggregateInputType | true
  }

export interface DocumentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
  /**
   * Find zero or one Document that matches the filter.
   * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
   * @example
   * // Get one Document
   * const document = await prisma.document.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends DocumentFindUniqueArgs>(args: Prisma.SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Document that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
   * @example
   * // Get one Document
   * const document = await prisma.document.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Document that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentFindFirstArgs} args - Arguments to find a Document
   * @example
   * // Get one Document
   * const document = await prisma.document.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends DocumentFindFirstArgs>(args?: Prisma.SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Document that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
   * @example
   * // Get one Document
   * const document = await prisma.document.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Documents that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Documents
   * const documents = await prisma.document.findMany()
   * 
   * // Get first 10 Documents
   * const documents = await prisma.document.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends DocumentFindManyArgs>(args?: Prisma.SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Document.
   * @param {DocumentCreateArgs} args - Arguments to create a Document.
   * @example
   * // Create one Document
   * const Document = await prisma.document.create({
   *   data: {
   *     // ... data to create a Document
   *   }
   * })
   * 
   */
  create<T extends DocumentCreateArgs>(args: Prisma.SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Documents.
   * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
   * @example
   * // Create many Documents
   * const document = await prisma.document.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends DocumentCreateManyArgs>(args?: Prisma.SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Documents and returns the data saved in the database.
   * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
   * @example
   * // Create many Documents
   * const document = await prisma.document.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Documents and only return the `id`
   * const documentWithIdOnly = await prisma.document.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Document.
   * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
   * @example
   * // Delete one Document
   * const Document = await prisma.document.delete({
   *   where: {
   *     // ... filter to delete one Document
   *   }
   * })
   * 
   */
  delete<T extends DocumentDeleteArgs>(args: Prisma.SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Document.
   * @param {DocumentUpdateArgs} args - Arguments to update one Document.
   * @example
   * // Update one Document
   * const document = await prisma.document.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends DocumentUpdateArgs>(args: Prisma.SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Documents.
   * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
   * @example
   * // Delete a few Documents
   * const { count } = await prisma.document.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends DocumentDeleteManyArgs>(args?: Prisma.SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Documents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Documents
   * const document = await prisma.document.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends DocumentUpdateManyArgs>(args: Prisma.SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Documents and returns the data updated in the database.
   * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
   * @example
   * // Update many Documents
   * const document = await prisma.document.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Documents and only return the `id`
   * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Document.
   * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
   * @example
   * // Update or create a Document
   * const document = await prisma.document.upsert({
   *   create: {
   *     // ... data to create a Document
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Document we want to update
   *   }
   * })
   */
  upsert<T extends DocumentUpsertArgs>(args: Prisma.SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma.Prisma__DocumentClient<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Documents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
   * @example
   * // Count the number of Documents
   * const count = await prisma.document.count({
   *   where: {
   *     // ... the filter for the Documents we want to count
   *   }
   * })
  **/
  count<T extends DocumentCountArgs>(
    args?: Prisma.Subset<T, DocumentCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], DocumentCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Document.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends DocumentAggregateArgs>(args: Prisma.Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

  /**
   * Group by Document.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DocumentGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends DocumentGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: DocumentGroupByArgs['orderBy'] }
      : { orderBy?: DocumentGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Document model
 */
readonly fields: DocumentFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Document.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Document model
 */
export interface DocumentFieldRefs {
  readonly id: Prisma.FieldRef<"Document", 'String'>
  readonly propertyId: Prisma.FieldRef<"Document", 'String'>
  readonly fileName: Prisma.FieldRef<"Document", 'String'>
  readonly fileUrl: Prisma.FieldRef<"Document", 'String'>
  readonly fileType: Prisma.FieldRef<"Document", 'String'>
  readonly category: Prisma.FieldRef<"Document", 'String'>
  readonly uploadedBy: Prisma.FieldRef<"Document", 'String'>
  readonly createdAt: Prisma.FieldRef<"Document", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Document findUnique
 */
export type DocumentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * Filter, which Document to fetch.
   */
  where: Prisma.DocumentWhereUniqueInput
}

/**
 * Document findUniqueOrThrow
 */
export type DocumentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * Filter, which Document to fetch.
   */
  where: Prisma.DocumentWhereUniqueInput
}

/**
 * Document findFirst
 */
export type DocumentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * Filter, which Document to fetch.
   */
  where?: Prisma.DocumentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Documents to fetch.
   */
  orderBy?: Prisma.DocumentOrderByWithRelationInput | Prisma.DocumentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Documents.
   */
  cursor?: Prisma.DocumentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Documents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Documents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Documents.
   */
  distinct?: Prisma.DocumentScalarFieldEnum | Prisma.DocumentScalarFieldEnum[]
}

/**
 * Document findFirstOrThrow
 */
export type DocumentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * Filter, which Document to fetch.
   */
  where?: Prisma.DocumentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Documents to fetch.
   */
  orderBy?: Prisma.DocumentOrderByWithRelationInput | Prisma.DocumentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Documents.
   */
  cursor?: Prisma.DocumentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Documents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Documents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Documents.
   */
  distinct?: Prisma.DocumentScalarFieldEnum | Prisma.DocumentScalarFieldEnum[]
}

/**
 * Document findMany
 */
export type DocumentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * Filter, which Documents to fetch.
   */
  where?: Prisma.DocumentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Documents to fetch.
   */
  orderBy?: Prisma.DocumentOrderByWithRelationInput | Prisma.DocumentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Documents.
   */
  cursor?: Prisma.DocumentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Documents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Documents.
   */
  skip?: number
  distinct?: Prisma.DocumentScalarFieldEnum | Prisma.DocumentScalarFieldEnum[]
}

/**
 * Document create
 */
export type DocumentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * The data needed to create a Document.
   */
  data: Prisma.XOR<Prisma.DocumentCreateInput, Prisma.DocumentUncheckedCreateInput>
}

/**
 * Document createMany
 */
export type DocumentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Documents.
   */
  data: Prisma.DocumentCreateManyInput | Prisma.DocumentCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Document createManyAndReturn
 */
export type DocumentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * The data used to create many Documents.
   */
  data: Prisma.DocumentCreateManyInput | Prisma.DocumentCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Document update
 */
export type DocumentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * The data needed to update a Document.
   */
  data: Prisma.XOR<Prisma.DocumentUpdateInput, Prisma.DocumentUncheckedUpdateInput>
  /**
   * Choose, which Document to update.
   */
  where: Prisma.DocumentWhereUniqueInput
}

/**
 * Document updateMany
 */
export type DocumentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Documents.
   */
  data: Prisma.XOR<Prisma.DocumentUpdateManyMutationInput, Prisma.DocumentUncheckedUpdateManyInput>
  /**
   * Filter which Documents to update
   */
  where?: Prisma.DocumentWhereInput
  /**
   * Limit how many Documents to update.
   */
  limit?: number
}

/**
 * Document updateManyAndReturn
 */
export type DocumentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * The data used to update Documents.
   */
  data: Prisma.XOR<Prisma.DocumentUpdateManyMutationInput, Prisma.DocumentUncheckedUpdateManyInput>
  /**
   * Filter which Documents to update
   */
  where?: Prisma.DocumentWhereInput
  /**
   * Limit how many Documents to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Document upsert
 */
export type DocumentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * The filter to search for the Document to update in case it exists.
   */
  where: Prisma.DocumentWhereUniqueInput
  /**
   * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
   */
  create: Prisma.XOR<Prisma.DocumentCreateInput, Prisma.DocumentUncheckedCreateInput>
  /**
   * In case the Document was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.DocumentUpdateInput, Prisma.DocumentUncheckedUpdateInput>
}

/**
 * Document delete
 */
export type DocumentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  /**
   * Filter which Document to delete.
   */
  where: Prisma.DocumentWhereUniqueInput
}

/**
 * Document deleteMany
 */
export type DocumentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Documents to delete
   */
  where?: Prisma.DocumentWhereInput
  /**
   * Limit how many Documents to delete.
   */
  limit?: number
}

/**
 * Document without action
 */
export type DocumentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\Document.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\Expense.ts
TYPE: TS
SIZE: 51273 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Expense` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Expense
 * 
 */
export type ExpenseModel = runtime.Types.Result.DefaultSelection<Prisma.$ExpensePayload>

export type AggregateExpense = {
  _count: ExpenseCountAggregateOutputType | null
  _avg: ExpenseAvgAggregateOutputType | null
  _sum: ExpenseSumAggregateOutputType | null
  _min: ExpenseMinAggregateOutputType | null
  _max: ExpenseMaxAggregateOutputType | null
}

export type ExpenseAvgAggregateOutputType = {
  amount: number | null
}

export type ExpenseSumAggregateOutputType = {
  amount: number | null
}

export type ExpenseMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  category: string | null
  amount: number | null
  description: string | null
  createdAt: Date | null
}

export type ExpenseMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  category: string | null
  amount: number | null
  description: string | null
  createdAt: Date | null
}

export type ExpenseCountAggregateOutputType = {
  id: number
  propertyId: number
  category: number
  amount: number
  description: number
  createdAt: number
  _all: number
}


export type ExpenseAvgAggregateInputType = {
  amount?: true
}

export type ExpenseSumAggregateInputType = {
  amount?: true
}

export type ExpenseMinAggregateInputType = {
  id?: true
  propertyId?: true
  category?: true
  amount?: true
  description?: true
  createdAt?: true
}

export type ExpenseMaxAggregateInputType = {
  id?: true
  propertyId?: true
  category?: true
  amount?: true
  description?: true
  createdAt?: true
}

export type ExpenseCountAggregateInputType = {
  id?: true
  propertyId?: true
  category?: true
  amount?: true
  description?: true
  createdAt?: true
  _all?: true
}

export type ExpenseAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Expense to aggregate.
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Expenses to fetch.
   */
  orderBy?: Prisma.ExpenseOrderByWithRelationInput | Prisma.ExpenseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ExpenseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Expenses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Expenses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Expenses
  **/
  _count?: true | ExpenseCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ExpenseAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ExpenseSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ExpenseMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ExpenseMaxAggregateInputType
}

export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
      [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateExpense[P]>
    : Prisma.GetScalarType<T[P], AggregateExpense[P]>
}




export type ExpenseGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ExpenseWhereInput
  orderBy?: Prisma.ExpenseOrderByWithAggregationInput | Prisma.ExpenseOrderByWithAggregationInput[]
  by: Prisma.ExpenseScalarFieldEnum[] | Prisma.ExpenseScalarFieldEnum
  having?: Prisma.ExpenseScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ExpenseCountAggregateInputType | true
  _avg?: ExpenseAvgAggregateInputType
  _sum?: ExpenseSumAggregateInputType
  _min?: ExpenseMinAggregateInputType
  _max?: ExpenseMaxAggregateInputType
}

export type ExpenseGroupByOutputType = {
  id: string
  propertyId: string
  category: string
  amount: number
  description: string | null
  createdAt: Date
  _count: ExpenseCountAggregateOutputType | null
  _avg: ExpenseAvgAggregateOutputType | null
  _sum: ExpenseSumAggregateOutputType | null
  _min: ExpenseMinAggregateOutputType | null
  _max: ExpenseMaxAggregateOutputType | null
}

type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ExpenseGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ExpenseGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ExpenseGroupByOutputType[P]>
      }
    >
  >



export type ExpenseWhereInput = {
  AND?: Prisma.ExpenseWhereInput | Prisma.ExpenseWhereInput[]
  OR?: Prisma.ExpenseWhereInput[]
  NOT?: Prisma.ExpenseWhereInput | Prisma.ExpenseWhereInput[]
  id?: Prisma.StringFilter<"Expense"> | string
  propertyId?: Prisma.StringFilter<"Expense"> | string
  category?: Prisma.StringFilter<"Expense"> | string
  amount?: Prisma.FloatFilter<"Expense"> | number
  description?: Prisma.StringNullableFilter<"Expense"> | string | null
  createdAt?: Prisma.DateTimeFilter<"Expense"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type ExpenseOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.ExpenseWhereInput | Prisma.ExpenseWhereInput[]
  OR?: Prisma.ExpenseWhereInput[]
  NOT?: Prisma.ExpenseWhereInput | Prisma.ExpenseWhereInput[]
  propertyId?: Prisma.StringFilter<"Expense"> | string
  category?: Prisma.StringFilter<"Expense"> | string
  amount?: Prisma.FloatFilter<"Expense"> | number
  description?: Prisma.StringNullableFilter<"Expense"> | string | null
  createdAt?: Prisma.DateTimeFilter<"Expense"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type ExpenseOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.ExpenseCountOrderByAggregateInput
  _avg?: Prisma.ExpenseAvgOrderByAggregateInput
  _max?: Prisma.ExpenseMaxOrderByAggregateInput
  _min?: Prisma.ExpenseMinOrderByAggregateInput
  _sum?: Prisma.ExpenseSumOrderByAggregateInput
}

export type ExpenseScalarWhereWithAggregatesInput = {
  AND?: Prisma.ExpenseScalarWhereWithAggregatesInput | Prisma.ExpenseScalarWhereWithAggregatesInput[]
  OR?: Prisma.ExpenseScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ExpenseScalarWhereWithAggregatesInput | Prisma.ExpenseScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Expense"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"Expense"> | string
  category?: Prisma.StringWithAggregatesFilter<"Expense"> | string
  amount?: Prisma.FloatWithAggregatesFilter<"Expense"> | number
  description?: Prisma.StringNullableWithAggregatesFilter<"Expense"> | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Expense"> | Date | string
}

export type ExpenseCreateInput = {
  id?: string
  category: string
  amount: number
  description?: string | null
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutExpensesInput
}

export type ExpenseUncheckedCreateInput = {
  id?: string
  propertyId: string
  category: string
  amount: number
  description?: string | null
  createdAt?: Date | string
}

export type ExpenseUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutExpensesNestedInput
}

export type ExpenseUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ExpenseCreateManyInput = {
  id?: string
  propertyId: string
  category: string
  amount: number
  description?: string | null
  createdAt?: Date | string
}

export type ExpenseUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ExpenseUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ExpenseListRelationFilter = {
  every?: Prisma.ExpenseWhereInput
  some?: Prisma.ExpenseWhereInput
  none?: Prisma.ExpenseWhereInput
}

export type ExpenseOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ExpenseCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  description?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ExpenseAvgOrderByAggregateInput = {
  amount?: Prisma.SortOrder
}

export type ExpenseMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  description?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ExpenseMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  description?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ExpenseSumOrderByAggregateInput = {
  amount?: Prisma.SortOrder
}

export type ExpenseCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.ExpenseCreateWithoutPropertyInput, Prisma.ExpenseUncheckedCreateWithoutPropertyInput> | Prisma.ExpenseCreateWithoutPropertyInput[] | Prisma.ExpenseUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ExpenseCreateOrConnectWithoutPropertyInput | Prisma.ExpenseCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.ExpenseCreateManyPropertyInputEnvelope
  connect?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
}

export type ExpenseUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.ExpenseCreateWithoutPropertyInput, Prisma.ExpenseUncheckedCreateWithoutPropertyInput> | Prisma.ExpenseCreateWithoutPropertyInput[] | Prisma.ExpenseUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ExpenseCreateOrConnectWithoutPropertyInput | Prisma.ExpenseCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.ExpenseCreateManyPropertyInputEnvelope
  connect?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
}

export type ExpenseUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.ExpenseCreateWithoutPropertyInput, Prisma.ExpenseUncheckedCreateWithoutPropertyInput> | Prisma.ExpenseCreateWithoutPropertyInput[] | Prisma.ExpenseUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ExpenseCreateOrConnectWithoutPropertyInput | Prisma.ExpenseCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.ExpenseUpsertWithWhereUniqueWithoutPropertyInput | Prisma.ExpenseUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.ExpenseCreateManyPropertyInputEnvelope
  set?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  disconnect?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  delete?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  connect?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  update?: Prisma.ExpenseUpdateWithWhereUniqueWithoutPropertyInput | Prisma.ExpenseUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.ExpenseUpdateManyWithWhereWithoutPropertyInput | Prisma.ExpenseUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.ExpenseScalarWhereInput | Prisma.ExpenseScalarWhereInput[]
}

export type ExpenseUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.ExpenseCreateWithoutPropertyInput, Prisma.ExpenseUncheckedCreateWithoutPropertyInput> | Prisma.ExpenseCreateWithoutPropertyInput[] | Prisma.ExpenseUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ExpenseCreateOrConnectWithoutPropertyInput | Prisma.ExpenseCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.ExpenseUpsertWithWhereUniqueWithoutPropertyInput | Prisma.ExpenseUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.ExpenseCreateManyPropertyInputEnvelope
  set?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  disconnect?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  delete?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  connect?: Prisma.ExpenseWhereUniqueInput | Prisma.ExpenseWhereUniqueInput[]
  update?: Prisma.ExpenseUpdateWithWhereUniqueWithoutPropertyInput | Prisma.ExpenseUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.ExpenseUpdateManyWithWhereWithoutPropertyInput | Prisma.ExpenseUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.ExpenseScalarWhereInput | Prisma.ExpenseScalarWhereInput[]
}

export type ExpenseCreateWithoutPropertyInput = {
  id?: string
  category: string
  amount: number
  description?: string | null
  createdAt?: Date | string
}

export type ExpenseUncheckedCreateWithoutPropertyInput = {
  id?: string
  category: string
  amount: number
  description?: string | null
  createdAt?: Date | string
}

export type ExpenseCreateOrConnectWithoutPropertyInput = {
  where: Prisma.ExpenseWhereUniqueInput
  create: Prisma.XOR<Prisma.ExpenseCreateWithoutPropertyInput, Prisma.ExpenseUncheckedCreateWithoutPropertyInput>
}

export type ExpenseCreateManyPropertyInputEnvelope = {
  data: Prisma.ExpenseCreateManyPropertyInput | Prisma.ExpenseCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type ExpenseUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.ExpenseWhereUniqueInput
  update: Prisma.XOR<Prisma.ExpenseUpdateWithoutPropertyInput, Prisma.ExpenseUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.ExpenseCreateWithoutPropertyInput, Prisma.ExpenseUncheckedCreateWithoutPropertyInput>
}

export type ExpenseUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.ExpenseWhereUniqueInput
  data: Prisma.XOR<Prisma.ExpenseUpdateWithoutPropertyInput, Prisma.ExpenseUncheckedUpdateWithoutPropertyInput>
}

export type ExpenseUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.ExpenseScalarWhereInput
  data: Prisma.XOR<Prisma.ExpenseUpdateManyMutationInput, Prisma.ExpenseUncheckedUpdateManyWithoutPropertyInput>
}

export type ExpenseScalarWhereInput = {
  AND?: Prisma.ExpenseScalarWhereInput | Prisma.ExpenseScalarWhereInput[]
  OR?: Prisma.ExpenseScalarWhereInput[]
  NOT?: Prisma.ExpenseScalarWhereInput | Prisma.ExpenseScalarWhereInput[]
  id?: Prisma.StringFilter<"Expense"> | string
  propertyId?: Prisma.StringFilter<"Expense"> | string
  category?: Prisma.StringFilter<"Expense"> | string
  amount?: Prisma.FloatFilter<"Expense"> | number
  description?: Prisma.StringNullableFilter<"Expense"> | string | null
  createdAt?: Prisma.DateTimeFilter<"Expense"> | Date | string
}

export type ExpenseCreateManyPropertyInput = {
  id?: string
  category: string
  amount: number
  description?: string | null
  createdAt?: Date | string
}

export type ExpenseUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ExpenseUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ExpenseUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.FloatFieldUpdateOperationsInput | number
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type ExpenseSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  category?: boolean
  amount?: boolean
  description?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["expense"]>

export type ExpenseSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  category?: boolean
  amount?: boolean
  description?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["expense"]>

export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  category?: boolean
  amount?: boolean
  description?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["expense"]>

export type ExpenseSelectScalar = {
  id?: boolean
  propertyId?: boolean
  category?: boolean
  amount?: boolean
  description?: boolean
  createdAt?: boolean
}

export type ExpenseOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "category" | "amount" | "description" | "createdAt", ExtArgs["result"]["expense"]>
export type ExpenseInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $ExpensePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Expense"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    category: string
    amount: number
    description: string | null
    createdAt: Date
  }, ExtArgs["result"]["expense"]>
  composites: {}
}

export type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ExpensePayload, S>

export type ExpenseCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ExpenseCountAggregateInputType | true
  }

export interface ExpenseDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
  /**
   * Find zero or one Expense that matches the filter.
   * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
   * @example
   * // Get one Expense
   * const expense = await prisma.expense.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ExpenseFindUniqueArgs>(args: Prisma.SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
   * @example
   * // Get one Expense
   * const expense = await prisma.expense.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Expense that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
   * @example
   * // Get one Expense
   * const expense = await prisma.expense.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ExpenseFindFirstArgs>(args?: Prisma.SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Expense that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
   * @example
   * // Get one Expense
   * const expense = await prisma.expense.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Expenses that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Expenses
   * const expenses = await prisma.expense.findMany()
   * 
   * // Get first 10 Expenses
   * const expenses = await prisma.expense.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ExpenseFindManyArgs>(args?: Prisma.SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Expense.
   * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
   * @example
   * // Create one Expense
   * const Expense = await prisma.expense.create({
   *   data: {
   *     // ... data to create a Expense
   *   }
   * })
   * 
   */
  create<T extends ExpenseCreateArgs>(args: Prisma.SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Expenses.
   * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
   * @example
   * // Create many Expenses
   * const expense = await prisma.expense.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ExpenseCreateManyArgs>(args?: Prisma.SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Expenses and returns the data saved in the database.
   * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
   * @example
   * // Create many Expenses
   * const expense = await prisma.expense.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Expenses and only return the `id`
   * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Expense.
   * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
   * @example
   * // Delete one Expense
   * const Expense = await prisma.expense.delete({
   *   where: {
   *     // ... filter to delete one Expense
   *   }
   * })
   * 
   */
  delete<T extends ExpenseDeleteArgs>(args: Prisma.SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Expense.
   * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
   * @example
   * // Update one Expense
   * const expense = await prisma.expense.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ExpenseUpdateArgs>(args: Prisma.SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Expenses.
   * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
   * @example
   * // Delete a few Expenses
   * const { count } = await prisma.expense.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ExpenseDeleteManyArgs>(args?: Prisma.SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Expenses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Expenses
   * const expense = await prisma.expense.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ExpenseUpdateManyArgs>(args: Prisma.SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Expenses and returns the data updated in the database.
   * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
   * @example
   * // Update many Expenses
   * const expense = await prisma.expense.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Expenses and only return the `id`
   * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Expense.
   * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
   * @example
   * // Update or create a Expense
   * const expense = await prisma.expense.upsert({
   *   create: {
   *     // ... data to create a Expense
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Expense we want to update
   *   }
   * })
   */
  upsert<T extends ExpenseUpsertArgs>(args: Prisma.SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma.Prisma__ExpenseClient<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Expenses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
   * @example
   * // Count the number of Expenses
   * const count = await prisma.expense.count({
   *   where: {
   *     // ... the filter for the Expenses we want to count
   *   }
   * })
  **/
  count<T extends ExpenseCountArgs>(
    args?: Prisma.Subset<T, ExpenseCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ExpenseCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Expense.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ExpenseAggregateArgs>(args: Prisma.Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

  /**
   * Group by Expense.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ExpenseGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ExpenseGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ExpenseGroupByArgs['orderBy'] }
      : { orderBy?: ExpenseGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Expense model
 */
readonly fields: ExpenseFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Expense.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Expense model
 */
export interface ExpenseFieldRefs {
  readonly id: Prisma.FieldRef<"Expense", 'String'>
  readonly propertyId: Prisma.FieldRef<"Expense", 'String'>
  readonly category: Prisma.FieldRef<"Expense", 'String'>
  readonly amount: Prisma.FieldRef<"Expense", 'Float'>
  readonly description: Prisma.FieldRef<"Expense", 'String'>
  readonly createdAt: Prisma.FieldRef<"Expense", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Expense findUnique
 */
export type ExpenseFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * Filter, which Expense to fetch.
   */
  where: Prisma.ExpenseWhereUniqueInput
}

/**
 * Expense findUniqueOrThrow
 */
export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * Filter, which Expense to fetch.
   */
  where: Prisma.ExpenseWhereUniqueInput
}

/**
 * Expense findFirst
 */
export type ExpenseFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * Filter, which Expense to fetch.
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Expenses to fetch.
   */
  orderBy?: Prisma.ExpenseOrderByWithRelationInput | Prisma.ExpenseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Expenses.
   */
  cursor?: Prisma.ExpenseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Expenses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Expenses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Expenses.
   */
  distinct?: Prisma.ExpenseScalarFieldEnum | Prisma.ExpenseScalarFieldEnum[]
}

/**
 * Expense findFirstOrThrow
 */
export type ExpenseFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * Filter, which Expense to fetch.
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Expenses to fetch.
   */
  orderBy?: Prisma.ExpenseOrderByWithRelationInput | Prisma.ExpenseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Expenses.
   */
  cursor?: Prisma.ExpenseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Expenses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Expenses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Expenses.
   */
  distinct?: Prisma.ExpenseScalarFieldEnum | Prisma.ExpenseScalarFieldEnum[]
}

/**
 * Expense findMany
 */
export type ExpenseFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * Filter, which Expenses to fetch.
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Expenses to fetch.
   */
  orderBy?: Prisma.ExpenseOrderByWithRelationInput | Prisma.ExpenseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Expenses.
   */
  cursor?: Prisma.ExpenseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Expenses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Expenses.
   */
  skip?: number
  distinct?: Prisma.ExpenseScalarFieldEnum | Prisma.ExpenseScalarFieldEnum[]
}

/**
 * Expense create
 */
export type ExpenseCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * The data needed to create a Expense.
   */
  data: Prisma.XOR<Prisma.ExpenseCreateInput, Prisma.ExpenseUncheckedCreateInput>
}

/**
 * Expense createMany
 */
export type ExpenseCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Expenses.
   */
  data: Prisma.ExpenseCreateManyInput | Prisma.ExpenseCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Expense createManyAndReturn
 */
export type ExpenseCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * The data used to create many Expenses.
   */
  data: Prisma.ExpenseCreateManyInput | Prisma.ExpenseCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Expense update
 */
export type ExpenseUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * The data needed to update a Expense.
   */
  data: Prisma.XOR<Prisma.ExpenseUpdateInput, Prisma.ExpenseUncheckedUpdateInput>
  /**
   * Choose, which Expense to update.
   */
  where: Prisma.ExpenseWhereUniqueInput
}

/**
 * Expense updateMany
 */
export type ExpenseUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Expenses.
   */
  data: Prisma.XOR<Prisma.ExpenseUpdateManyMutationInput, Prisma.ExpenseUncheckedUpdateManyInput>
  /**
   * Filter which Expenses to update
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * Limit how many Expenses to update.
   */
  limit?: number
}

/**
 * Expense updateManyAndReturn
 */
export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * The data used to update Expenses.
   */
  data: Prisma.XOR<Prisma.ExpenseUpdateManyMutationInput, Prisma.ExpenseUncheckedUpdateManyInput>
  /**
   * Filter which Expenses to update
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * Limit how many Expenses to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Expense upsert
 */
export type ExpenseUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * The filter to search for the Expense to update in case it exists.
   */
  where: Prisma.ExpenseWhereUniqueInput
  /**
   * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
   */
  create: Prisma.XOR<Prisma.ExpenseCreateInput, Prisma.ExpenseUncheckedCreateInput>
  /**
   * In case the Expense was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ExpenseUpdateInput, Prisma.ExpenseUncheckedUpdateInput>
}

/**
 * Expense delete
 */
export type ExpenseDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  /**
   * Filter which Expense to delete.
   */
  where: Prisma.ExpenseWhereUniqueInput
}

/**
 * Expense deleteMany
 */
export type ExpenseDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Expenses to delete
   */
  where?: Prisma.ExpenseWhereInput
  /**
   * Limit how many Expenses to delete.
   */
  limit?: number
}

/**
 * Expense without action
 */
export type ExpenseDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\Expense.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\MarketData.ts
TYPE: TS
SIZE: 56445 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `MarketData` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model MarketData
 * 
 */
export type MarketDataModel = runtime.Types.Result.DefaultSelection<Prisma.$MarketDataPayload>

export type AggregateMarketData = {
  _count: MarketDataCountAggregateOutputType | null
  _avg: MarketDataAvgAggregateOutputType | null
  _sum: MarketDataSumAggregateOutputType | null
  _min: MarketDataMinAggregateOutputType | null
  _max: MarketDataMaxAggregateOutputType | null
}

export type MarketDataAvgAggregateOutputType = {
  avgDaysOnMarket: number | null
  avgPricePerSqft: number | null
  priceTrend: number | null
  inventory: number | null
}

export type MarketDataSumAggregateOutputType = {
  avgDaysOnMarket: number | null
  avgPricePerSqft: number | null
  priceTrend: number | null
  inventory: number | null
}

export type MarketDataMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  neighborhood: string | null
  avgDaysOnMarket: number | null
  avgPricePerSqft: number | null
  priceTrend: number | null
  inventory: number | null
  dataDate: Date | null
}

export type MarketDataMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  neighborhood: string | null
  avgDaysOnMarket: number | null
  avgPricePerSqft: number | null
  priceTrend: number | null
  inventory: number | null
  dataDate: Date | null
}

export type MarketDataCountAggregateOutputType = {
  id: number
  propertyId: number
  neighborhood: number
  avgDaysOnMarket: number
  avgPricePerSqft: number
  priceTrend: number
  inventory: number
  dataDate: number
  _all: number
}


export type MarketDataAvgAggregateInputType = {
  avgDaysOnMarket?: true
  avgPricePerSqft?: true
  priceTrend?: true
  inventory?: true
}

export type MarketDataSumAggregateInputType = {
  avgDaysOnMarket?: true
  avgPricePerSqft?: true
  priceTrend?: true
  inventory?: true
}

export type MarketDataMinAggregateInputType = {
  id?: true
  propertyId?: true
  neighborhood?: true
  avgDaysOnMarket?: true
  avgPricePerSqft?: true
  priceTrend?: true
  inventory?: true
  dataDate?: true
}

export type MarketDataMaxAggregateInputType = {
  id?: true
  propertyId?: true
  neighborhood?: true
  avgDaysOnMarket?: true
  avgPricePerSqft?: true
  priceTrend?: true
  inventory?: true
  dataDate?: true
}

export type MarketDataCountAggregateInputType = {
  id?: true
  propertyId?: true
  neighborhood?: true
  avgDaysOnMarket?: true
  avgPricePerSqft?: true
  priceTrend?: true
  inventory?: true
  dataDate?: true
  _all?: true
}

export type MarketDataAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which MarketData to aggregate.
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MarketData to fetch.
   */
  orderBy?: Prisma.MarketDataOrderByWithRelationInput | Prisma.MarketDataOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.MarketDataWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` MarketData from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MarketData.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned MarketData
  **/
  _count?: true | MarketDataCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: MarketDataAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: MarketDataSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: MarketDataMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: MarketDataMaxAggregateInputType
}

export type GetMarketDataAggregateType<T extends MarketDataAggregateArgs> = {
      [P in keyof T & keyof AggregateMarketData]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateMarketData[P]>
    : Prisma.GetScalarType<T[P], AggregateMarketData[P]>
}




export type MarketDataGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.MarketDataWhereInput
  orderBy?: Prisma.MarketDataOrderByWithAggregationInput | Prisma.MarketDataOrderByWithAggregationInput[]
  by: Prisma.MarketDataScalarFieldEnum[] | Prisma.MarketDataScalarFieldEnum
  having?: Prisma.MarketDataScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: MarketDataCountAggregateInputType | true
  _avg?: MarketDataAvgAggregateInputType
  _sum?: MarketDataSumAggregateInputType
  _min?: MarketDataMinAggregateInputType
  _max?: MarketDataMaxAggregateInputType
}

export type MarketDataGroupByOutputType = {
  id: string
  propertyId: string
  neighborhood: string
  avgDaysOnMarket: number
  avgPricePerSqft: number
  priceTrend: number
  inventory: number
  dataDate: Date
  _count: MarketDataCountAggregateOutputType | null
  _avg: MarketDataAvgAggregateOutputType | null
  _sum: MarketDataSumAggregateOutputType | null
  _min: MarketDataMinAggregateOutputType | null
  _max: MarketDataMaxAggregateOutputType | null
}

type GetMarketDataGroupByPayload<T extends MarketDataGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<MarketDataGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof MarketDataGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], MarketDataGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], MarketDataGroupByOutputType[P]>
      }
    >
  >



export type MarketDataWhereInput = {
  AND?: Prisma.MarketDataWhereInput | Prisma.MarketDataWhereInput[]
  OR?: Prisma.MarketDataWhereInput[]
  NOT?: Prisma.MarketDataWhereInput | Prisma.MarketDataWhereInput[]
  id?: Prisma.StringFilter<"MarketData"> | string
  propertyId?: Prisma.StringFilter<"MarketData"> | string
  neighborhood?: Prisma.StringFilter<"MarketData"> | string
  avgDaysOnMarket?: Prisma.IntFilter<"MarketData"> | number
  avgPricePerSqft?: Prisma.FloatFilter<"MarketData"> | number
  priceTrend?: Prisma.FloatFilter<"MarketData"> | number
  inventory?: Prisma.IntFilter<"MarketData"> | number
  dataDate?: Prisma.DateTimeFilter<"MarketData"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type MarketDataOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  neighborhood?: Prisma.SortOrder
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
  dataDate?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type MarketDataWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.MarketDataWhereInput | Prisma.MarketDataWhereInput[]
  OR?: Prisma.MarketDataWhereInput[]
  NOT?: Prisma.MarketDataWhereInput | Prisma.MarketDataWhereInput[]
  propertyId?: Prisma.StringFilter<"MarketData"> | string
  neighborhood?: Prisma.StringFilter<"MarketData"> | string
  avgDaysOnMarket?: Prisma.IntFilter<"MarketData"> | number
  avgPricePerSqft?: Prisma.FloatFilter<"MarketData"> | number
  priceTrend?: Prisma.FloatFilter<"MarketData"> | number
  inventory?: Prisma.IntFilter<"MarketData"> | number
  dataDate?: Prisma.DateTimeFilter<"MarketData"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type MarketDataOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  neighborhood?: Prisma.SortOrder
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
  dataDate?: Prisma.SortOrder
  _count?: Prisma.MarketDataCountOrderByAggregateInput
  _avg?: Prisma.MarketDataAvgOrderByAggregateInput
  _max?: Prisma.MarketDataMaxOrderByAggregateInput
  _min?: Prisma.MarketDataMinOrderByAggregateInput
  _sum?: Prisma.MarketDataSumOrderByAggregateInput
}

export type MarketDataScalarWhereWithAggregatesInput = {
  AND?: Prisma.MarketDataScalarWhereWithAggregatesInput | Prisma.MarketDataScalarWhereWithAggregatesInput[]
  OR?: Prisma.MarketDataScalarWhereWithAggregatesInput[]
  NOT?: Prisma.MarketDataScalarWhereWithAggregatesInput | Prisma.MarketDataScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"MarketData"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"MarketData"> | string
  neighborhood?: Prisma.StringWithAggregatesFilter<"MarketData"> | string
  avgDaysOnMarket?: Prisma.IntWithAggregatesFilter<"MarketData"> | number
  avgPricePerSqft?: Prisma.FloatWithAggregatesFilter<"MarketData"> | number
  priceTrend?: Prisma.FloatWithAggregatesFilter<"MarketData"> | number
  inventory?: Prisma.IntWithAggregatesFilter<"MarketData"> | number
  dataDate?: Prisma.DateTimeWithAggregatesFilter<"MarketData"> | Date | string
}

export type MarketDataCreateInput = {
  id?: string
  neighborhood: string
  avgDaysOnMarket?: number
  avgPricePerSqft?: number
  priceTrend?: number
  inventory?: number
  dataDate?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutMarketDataInput
}

export type MarketDataUncheckedCreateInput = {
  id?: string
  propertyId: string
  neighborhood: string
  avgDaysOnMarket?: number
  avgPricePerSqft?: number
  priceTrend?: number
  inventory?: number
  dataDate?: Date | string
}

export type MarketDataUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutMarketDataNestedInput
}

export type MarketDataUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarketDataCreateManyInput = {
  id?: string
  propertyId: string
  neighborhood: string
  avgDaysOnMarket?: number
  avgPricePerSqft?: number
  priceTrend?: number
  inventory?: number
  dataDate?: Date | string
}

export type MarketDataUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarketDataUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarketDataListRelationFilter = {
  every?: Prisma.MarketDataWhereInput
  some?: Prisma.MarketDataWhereInput
  none?: Prisma.MarketDataWhereInput
}

export type MarketDataOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type MarketDataCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  neighborhood?: Prisma.SortOrder
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
  dataDate?: Prisma.SortOrder
}

export type MarketDataAvgOrderByAggregateInput = {
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
}

export type MarketDataMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  neighborhood?: Prisma.SortOrder
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
  dataDate?: Prisma.SortOrder
}

export type MarketDataMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  neighborhood?: Prisma.SortOrder
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
  dataDate?: Prisma.SortOrder
}

export type MarketDataSumOrderByAggregateInput = {
  avgDaysOnMarket?: Prisma.SortOrder
  avgPricePerSqft?: Prisma.SortOrder
  priceTrend?: Prisma.SortOrder
  inventory?: Prisma.SortOrder
}

export type MarketDataCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.MarketDataCreateWithoutPropertyInput, Prisma.MarketDataUncheckedCreateWithoutPropertyInput> | Prisma.MarketDataCreateWithoutPropertyInput[] | Prisma.MarketDataUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.MarketDataCreateOrConnectWithoutPropertyInput | Prisma.MarketDataCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.MarketDataCreateManyPropertyInputEnvelope
  connect?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
}

export type MarketDataUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.MarketDataCreateWithoutPropertyInput, Prisma.MarketDataUncheckedCreateWithoutPropertyInput> | Prisma.MarketDataCreateWithoutPropertyInput[] | Prisma.MarketDataUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.MarketDataCreateOrConnectWithoutPropertyInput | Prisma.MarketDataCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.MarketDataCreateManyPropertyInputEnvelope
  connect?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
}

export type MarketDataUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.MarketDataCreateWithoutPropertyInput, Prisma.MarketDataUncheckedCreateWithoutPropertyInput> | Prisma.MarketDataCreateWithoutPropertyInput[] | Prisma.MarketDataUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.MarketDataCreateOrConnectWithoutPropertyInput | Prisma.MarketDataCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.MarketDataUpsertWithWhereUniqueWithoutPropertyInput | Prisma.MarketDataUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.MarketDataCreateManyPropertyInputEnvelope
  set?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  disconnect?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  delete?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  connect?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  update?: Prisma.MarketDataUpdateWithWhereUniqueWithoutPropertyInput | Prisma.MarketDataUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.MarketDataUpdateManyWithWhereWithoutPropertyInput | Prisma.MarketDataUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.MarketDataScalarWhereInput | Prisma.MarketDataScalarWhereInput[]
}

export type MarketDataUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.MarketDataCreateWithoutPropertyInput, Prisma.MarketDataUncheckedCreateWithoutPropertyInput> | Prisma.MarketDataCreateWithoutPropertyInput[] | Prisma.MarketDataUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.MarketDataCreateOrConnectWithoutPropertyInput | Prisma.MarketDataCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.MarketDataUpsertWithWhereUniqueWithoutPropertyInput | Prisma.MarketDataUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.MarketDataCreateManyPropertyInputEnvelope
  set?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  disconnect?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  delete?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  connect?: Prisma.MarketDataWhereUniqueInput | Prisma.MarketDataWhereUniqueInput[]
  update?: Prisma.MarketDataUpdateWithWhereUniqueWithoutPropertyInput | Prisma.MarketDataUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.MarketDataUpdateManyWithWhereWithoutPropertyInput | Prisma.MarketDataUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.MarketDataScalarWhereInput | Prisma.MarketDataScalarWhereInput[]
}

export type MarketDataCreateWithoutPropertyInput = {
  id?: string
  neighborhood: string
  avgDaysOnMarket?: number
  avgPricePerSqft?: number
  priceTrend?: number
  inventory?: number
  dataDate?: Date | string
}

export type MarketDataUncheckedCreateWithoutPropertyInput = {
  id?: string
  neighborhood: string
  avgDaysOnMarket?: number
  avgPricePerSqft?: number
  priceTrend?: number
  inventory?: number
  dataDate?: Date | string
}

export type MarketDataCreateOrConnectWithoutPropertyInput = {
  where: Prisma.MarketDataWhereUniqueInput
  create: Prisma.XOR<Prisma.MarketDataCreateWithoutPropertyInput, Prisma.MarketDataUncheckedCreateWithoutPropertyInput>
}

export type MarketDataCreateManyPropertyInputEnvelope = {
  data: Prisma.MarketDataCreateManyPropertyInput | Prisma.MarketDataCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type MarketDataUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.MarketDataWhereUniqueInput
  update: Prisma.XOR<Prisma.MarketDataUpdateWithoutPropertyInput, Prisma.MarketDataUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.MarketDataCreateWithoutPropertyInput, Prisma.MarketDataUncheckedCreateWithoutPropertyInput>
}

export type MarketDataUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.MarketDataWhereUniqueInput
  data: Prisma.XOR<Prisma.MarketDataUpdateWithoutPropertyInput, Prisma.MarketDataUncheckedUpdateWithoutPropertyInput>
}

export type MarketDataUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.MarketDataScalarWhereInput
  data: Prisma.XOR<Prisma.MarketDataUpdateManyMutationInput, Prisma.MarketDataUncheckedUpdateManyWithoutPropertyInput>
}

export type MarketDataScalarWhereInput = {
  AND?: Prisma.MarketDataScalarWhereInput | Prisma.MarketDataScalarWhereInput[]
  OR?: Prisma.MarketDataScalarWhereInput[]
  NOT?: Prisma.MarketDataScalarWhereInput | Prisma.MarketDataScalarWhereInput[]
  id?: Prisma.StringFilter<"MarketData"> | string
  propertyId?: Prisma.StringFilter<"MarketData"> | string
  neighborhood?: Prisma.StringFilter<"MarketData"> | string
  avgDaysOnMarket?: Prisma.IntFilter<"MarketData"> | number
  avgPricePerSqft?: Prisma.FloatFilter<"MarketData"> | number
  priceTrend?: Prisma.FloatFilter<"MarketData"> | number
  inventory?: Prisma.IntFilter<"MarketData"> | number
  dataDate?: Prisma.DateTimeFilter<"MarketData"> | Date | string
}

export type MarketDataCreateManyPropertyInput = {
  id?: string
  neighborhood: string
  avgDaysOnMarket?: number
  avgPricePerSqft?: number
  priceTrend?: number
  inventory?: number
  dataDate?: Date | string
}

export type MarketDataUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarketDataUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarketDataUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  neighborhood?: Prisma.StringFieldUpdateOperationsInput | string
  avgDaysOnMarket?: Prisma.IntFieldUpdateOperationsInput | number
  avgPricePerSqft?: Prisma.FloatFieldUpdateOperationsInput | number
  priceTrend?: Prisma.FloatFieldUpdateOperationsInput | number
  inventory?: Prisma.IntFieldUpdateOperationsInput | number
  dataDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type MarketDataSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  neighborhood?: boolean
  avgDaysOnMarket?: boolean
  avgPricePerSqft?: boolean
  priceTrend?: boolean
  inventory?: boolean
  dataDate?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["marketData"]>

export type MarketDataSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  neighborhood?: boolean
  avgDaysOnMarket?: boolean
  avgPricePerSqft?: boolean
  priceTrend?: boolean
  inventory?: boolean
  dataDate?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["marketData"]>

export type MarketDataSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  neighborhood?: boolean
  avgDaysOnMarket?: boolean
  avgPricePerSqft?: boolean
  priceTrend?: boolean
  inventory?: boolean
  dataDate?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["marketData"]>

export type MarketDataSelectScalar = {
  id?: boolean
  propertyId?: boolean
  neighborhood?: boolean
  avgDaysOnMarket?: boolean
  avgPricePerSqft?: boolean
  priceTrend?: boolean
  inventory?: boolean
  dataDate?: boolean
}

export type MarketDataOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "neighborhood" | "avgDaysOnMarket" | "avgPricePerSqft" | "priceTrend" | "inventory" | "dataDate", ExtArgs["result"]["marketData"]>
export type MarketDataInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type MarketDataIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type MarketDataIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $MarketDataPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "MarketData"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    neighborhood: string
    avgDaysOnMarket: number
    avgPricePerSqft: number
    priceTrend: number
    inventory: number
    dataDate: Date
  }, ExtArgs["result"]["marketData"]>
  composites: {}
}

export type MarketDataGetPayload<S extends boolean | null | undefined | MarketDataDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$MarketDataPayload, S>

export type MarketDataCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<MarketDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MarketDataCountAggregateInputType | true
  }

export interface MarketDataDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketData'], meta: { name: 'MarketData' } }
  /**
   * Find zero or one MarketData that matches the filter.
   * @param {MarketDataFindUniqueArgs} args - Arguments to find a MarketData
   * @example
   * // Get one MarketData
   * const marketData = await prisma.marketData.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends MarketDataFindUniqueArgs>(args: Prisma.SelectSubset<T, MarketDataFindUniqueArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one MarketData that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {MarketDataFindUniqueOrThrowArgs} args - Arguments to find a MarketData
   * @example
   * // Get one MarketData
   * const marketData = await prisma.marketData.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends MarketDataFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, MarketDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MarketData that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataFindFirstArgs} args - Arguments to find a MarketData
   * @example
   * // Get one MarketData
   * const marketData = await prisma.marketData.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends MarketDataFindFirstArgs>(args?: Prisma.SelectSubset<T, MarketDataFindFirstArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MarketData that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataFindFirstOrThrowArgs} args - Arguments to find a MarketData
   * @example
   * // Get one MarketData
   * const marketData = await prisma.marketData.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends MarketDataFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, MarketDataFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more MarketData that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all MarketData
   * const marketData = await prisma.marketData.findMany()
   * 
   * // Get first 10 MarketData
   * const marketData = await prisma.marketData.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const marketDataWithIdOnly = await prisma.marketData.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends MarketDataFindManyArgs>(args?: Prisma.SelectSubset<T, MarketDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a MarketData.
   * @param {MarketDataCreateArgs} args - Arguments to create a MarketData.
   * @example
   * // Create one MarketData
   * const MarketData = await prisma.marketData.create({
   *   data: {
   *     // ... data to create a MarketData
   *   }
   * })
   * 
   */
  create<T extends MarketDataCreateArgs>(args: Prisma.SelectSubset<T, MarketDataCreateArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many MarketData.
   * @param {MarketDataCreateManyArgs} args - Arguments to create many MarketData.
   * @example
   * // Create many MarketData
   * const marketData = await prisma.marketData.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends MarketDataCreateManyArgs>(args?: Prisma.SelectSubset<T, MarketDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many MarketData and returns the data saved in the database.
   * @param {MarketDataCreateManyAndReturnArgs} args - Arguments to create many MarketData.
   * @example
   * // Create many MarketData
   * const marketData = await prisma.marketData.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many MarketData and only return the `id`
   * const marketDataWithIdOnly = await prisma.marketData.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends MarketDataCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, MarketDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a MarketData.
   * @param {MarketDataDeleteArgs} args - Arguments to delete one MarketData.
   * @example
   * // Delete one MarketData
   * const MarketData = await prisma.marketData.delete({
   *   where: {
   *     // ... filter to delete one MarketData
   *   }
   * })
   * 
   */
  delete<T extends MarketDataDeleteArgs>(args: Prisma.SelectSubset<T, MarketDataDeleteArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one MarketData.
   * @param {MarketDataUpdateArgs} args - Arguments to update one MarketData.
   * @example
   * // Update one MarketData
   * const marketData = await prisma.marketData.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends MarketDataUpdateArgs>(args: Prisma.SelectSubset<T, MarketDataUpdateArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more MarketData.
   * @param {MarketDataDeleteManyArgs} args - Arguments to filter MarketData to delete.
   * @example
   * // Delete a few MarketData
   * const { count } = await prisma.marketData.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends MarketDataDeleteManyArgs>(args?: Prisma.SelectSubset<T, MarketDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MarketData.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many MarketData
   * const marketData = await prisma.marketData.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends MarketDataUpdateManyArgs>(args: Prisma.SelectSubset<T, MarketDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MarketData and returns the data updated in the database.
   * @param {MarketDataUpdateManyAndReturnArgs} args - Arguments to update many MarketData.
   * @example
   * // Update many MarketData
   * const marketData = await prisma.marketData.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more MarketData and only return the `id`
   * const marketDataWithIdOnly = await prisma.marketData.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends MarketDataUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, MarketDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one MarketData.
   * @param {MarketDataUpsertArgs} args - Arguments to update or create a MarketData.
   * @example
   * // Update or create a MarketData
   * const marketData = await prisma.marketData.upsert({
   *   create: {
   *     // ... data to create a MarketData
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the MarketData we want to update
   *   }
   * })
   */
  upsert<T extends MarketDataUpsertArgs>(args: Prisma.SelectSubset<T, MarketDataUpsertArgs<ExtArgs>>): Prisma.Prisma__MarketDataClient<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of MarketData.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataCountArgs} args - Arguments to filter MarketData to count.
   * @example
   * // Count the number of MarketData
   * const count = await prisma.marketData.count({
   *   where: {
   *     // ... the filter for the MarketData we want to count
   *   }
   * })
  **/
  count<T extends MarketDataCountArgs>(
    args?: Prisma.Subset<T, MarketDataCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], MarketDataCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a MarketData.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends MarketDataAggregateArgs>(args: Prisma.Subset<T, MarketDataAggregateArgs>): Prisma.PrismaPromise<GetMarketDataAggregateType<T>>

  /**
   * Group by MarketData.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarketDataGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends MarketDataGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: MarketDataGroupByArgs['orderBy'] }
      : { orderBy?: MarketDataGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, MarketDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the MarketData model
 */
readonly fields: MarketDataFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for MarketData.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__MarketDataClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the MarketData model
 */
export interface MarketDataFieldRefs {
  readonly id: Prisma.FieldRef<"MarketData", 'String'>
  readonly propertyId: Prisma.FieldRef<"MarketData", 'String'>
  readonly neighborhood: Prisma.FieldRef<"MarketData", 'String'>
  readonly avgDaysOnMarket: Prisma.FieldRef<"MarketData", 'Int'>
  readonly avgPricePerSqft: Prisma.FieldRef<"MarketData", 'Float'>
  readonly priceTrend: Prisma.FieldRef<"MarketData", 'Float'>
  readonly inventory: Prisma.FieldRef<"MarketData", 'Int'>
  readonly dataDate: Prisma.FieldRef<"MarketData", 'DateTime'>
}
    

// Custom InputTypes
/**
 * MarketData findUnique
 */
export type MarketDataFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * Filter, which MarketData to fetch.
   */
  where: Prisma.MarketDataWhereUniqueInput
}

/**
 * MarketData findUniqueOrThrow
 */
export type MarketDataFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * Filter, which MarketData to fetch.
   */
  where: Prisma.MarketDataWhereUniqueInput
}

/**
 * MarketData findFirst
 */
export type MarketDataFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * Filter, which MarketData to fetch.
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MarketData to fetch.
   */
  orderBy?: Prisma.MarketDataOrderByWithRelationInput | Prisma.MarketDataOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for MarketData.
   */
  cursor?: Prisma.MarketDataWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` MarketData from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MarketData.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of MarketData.
   */
  distinct?: Prisma.MarketDataScalarFieldEnum | Prisma.MarketDataScalarFieldEnum[]
}

/**
 * MarketData findFirstOrThrow
 */
export type MarketDataFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * Filter, which MarketData to fetch.
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MarketData to fetch.
   */
  orderBy?: Prisma.MarketDataOrderByWithRelationInput | Prisma.MarketDataOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for MarketData.
   */
  cursor?: Prisma.MarketDataWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` MarketData from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MarketData.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of MarketData.
   */
  distinct?: Prisma.MarketDataScalarFieldEnum | Prisma.MarketDataScalarFieldEnum[]
}

/**
 * MarketData findMany
 */
export type MarketDataFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * Filter, which MarketData to fetch.
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MarketData to fetch.
   */
  orderBy?: Prisma.MarketDataOrderByWithRelationInput | Prisma.MarketDataOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing MarketData.
   */
  cursor?: Prisma.MarketDataWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` MarketData from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MarketData.
   */
  skip?: number
  distinct?: Prisma.MarketDataScalarFieldEnum | Prisma.MarketDataScalarFieldEnum[]
}

/**
 * MarketData create
 */
export type MarketDataCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * The data needed to create a MarketData.
   */
  data: Prisma.XOR<Prisma.MarketDataCreateInput, Prisma.MarketDataUncheckedCreateInput>
}

/**
 * MarketData createMany
 */
export type MarketDataCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many MarketData.
   */
  data: Prisma.MarketDataCreateManyInput | Prisma.MarketDataCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * MarketData createManyAndReturn
 */
export type MarketDataCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * The data used to create many MarketData.
   */
  data: Prisma.MarketDataCreateManyInput | Prisma.MarketDataCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * MarketData update
 */
export type MarketDataUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * The data needed to update a MarketData.
   */
  data: Prisma.XOR<Prisma.MarketDataUpdateInput, Prisma.MarketDataUncheckedUpdateInput>
  /**
   * Choose, which MarketData to update.
   */
  where: Prisma.MarketDataWhereUniqueInput
}

/**
 * MarketData updateMany
 */
export type MarketDataUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update MarketData.
   */
  data: Prisma.XOR<Prisma.MarketDataUpdateManyMutationInput, Prisma.MarketDataUncheckedUpdateManyInput>
  /**
   * Filter which MarketData to update
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * Limit how many MarketData to update.
   */
  limit?: number
}

/**
 * MarketData updateManyAndReturn
 */
export type MarketDataUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * The data used to update MarketData.
   */
  data: Prisma.XOR<Prisma.MarketDataUpdateManyMutationInput, Prisma.MarketDataUncheckedUpdateManyInput>
  /**
   * Filter which MarketData to update
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * Limit how many MarketData to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * MarketData upsert
 */
export type MarketDataUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * The filter to search for the MarketData to update in case it exists.
   */
  where: Prisma.MarketDataWhereUniqueInput
  /**
   * In case the MarketData found by the `where` argument doesn't exist, create a new MarketData with this data.
   */
  create: Prisma.XOR<Prisma.MarketDataCreateInput, Prisma.MarketDataUncheckedCreateInput>
  /**
   * In case the MarketData was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.MarketDataUpdateInput, Prisma.MarketDataUncheckedUpdateInput>
}

/**
 * MarketData delete
 */
export type MarketDataDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  /**
   * Filter which MarketData to delete.
   */
  where: Prisma.MarketDataWhereUniqueInput
}

/**
 * MarketData deleteMany
 */
export type MarketDataDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which MarketData to delete
   */
  where?: Prisma.MarketDataWhereInput
  /**
   * Limit how many MarketData to delete.
   */
  limit?: number
}

/**
 * MarketData without action
 */
export type MarketDataDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\MarketData.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\Projection.ts
TYPE: TS
SIZE: 61014 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Projection` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Projection
 * 
 */
export type ProjectionModel = runtime.Types.Result.DefaultSelection<Prisma.$ProjectionPayload>

export type AggregateProjection = {
  _count: ProjectionCountAggregateOutputType | null
  _avg: ProjectionAvgAggregateOutputType | null
  _sum: ProjectionSumAggregateOutputType | null
  _min: ProjectionMinAggregateOutputType | null
  _max: ProjectionMaxAggregateOutputType | null
}

export type ProjectionAvgAggregateOutputType = {
  year: number | null
  monthlyRent: number | null
  vacancyRate: number | null
  operatingExpenses: number | null
  mortgagePayment: number | null
  cashFlow: number | null
  equityBuild: number | null
  totalReturn: number | null
}

export type ProjectionSumAggregateOutputType = {
  year: number | null
  monthlyRent: number | null
  vacancyRate: number | null
  operatingExpenses: number | null
  mortgagePayment: number | null
  cashFlow: number | null
  equityBuild: number | null
  totalReturn: number | null
}

export type ProjectionMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  year: number | null
  monthlyRent: number | null
  vacancyRate: number | null
  operatingExpenses: number | null
  mortgagePayment: number | null
  cashFlow: number | null
  equityBuild: number | null
  totalReturn: number | null
  createdAt: Date | null
}

export type ProjectionMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  year: number | null
  monthlyRent: number | null
  vacancyRate: number | null
  operatingExpenses: number | null
  mortgagePayment: number | null
  cashFlow: number | null
  equityBuild: number | null
  totalReturn: number | null
  createdAt: Date | null
}

export type ProjectionCountAggregateOutputType = {
  id: number
  propertyId: number
  year: number
  monthlyRent: number
  vacancyRate: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt: number
  _all: number
}


export type ProjectionAvgAggregateInputType = {
  year?: true
  monthlyRent?: true
  vacancyRate?: true
  operatingExpenses?: true
  mortgagePayment?: true
  cashFlow?: true
  equityBuild?: true
  totalReturn?: true
}

export type ProjectionSumAggregateInputType = {
  year?: true
  monthlyRent?: true
  vacancyRate?: true
  operatingExpenses?: true
  mortgagePayment?: true
  cashFlow?: true
  equityBuild?: true
  totalReturn?: true
}

export type ProjectionMinAggregateInputType = {
  id?: true
  propertyId?: true
  year?: true
  monthlyRent?: true
  vacancyRate?: true
  operatingExpenses?: true
  mortgagePayment?: true
  cashFlow?: true
  equityBuild?: true
  totalReturn?: true
  createdAt?: true
}

export type ProjectionMaxAggregateInputType = {
  id?: true
  propertyId?: true
  year?: true
  monthlyRent?: true
  vacancyRate?: true
  operatingExpenses?: true
  mortgagePayment?: true
  cashFlow?: true
  equityBuild?: true
  totalReturn?: true
  createdAt?: true
}

export type ProjectionCountAggregateInputType = {
  id?: true
  propertyId?: true
  year?: true
  monthlyRent?: true
  vacancyRate?: true
  operatingExpenses?: true
  mortgagePayment?: true
  cashFlow?: true
  equityBuild?: true
  totalReturn?: true
  createdAt?: true
  _all?: true
}

export type ProjectionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Projection to aggregate.
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Projections to fetch.
   */
  orderBy?: Prisma.ProjectionOrderByWithRelationInput | Prisma.ProjectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ProjectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Projections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Projections.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Projections
  **/
  _count?: true | ProjectionCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ProjectionAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ProjectionSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ProjectionMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ProjectionMaxAggregateInputType
}

export type GetProjectionAggregateType<T extends ProjectionAggregateArgs> = {
      [P in keyof T & keyof AggregateProjection]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProjection[P]>
    : Prisma.GetScalarType<T[P], AggregateProjection[P]>
}




export type ProjectionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProjectionWhereInput
  orderBy?: Prisma.ProjectionOrderByWithAggregationInput | Prisma.ProjectionOrderByWithAggregationInput[]
  by: Prisma.ProjectionScalarFieldEnum[] | Prisma.ProjectionScalarFieldEnum
  having?: Prisma.ProjectionScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ProjectionCountAggregateInputType | true
  _avg?: ProjectionAvgAggregateInputType
  _sum?: ProjectionSumAggregateInputType
  _min?: ProjectionMinAggregateInputType
  _max?: ProjectionMaxAggregateInputType
}

export type ProjectionGroupByOutputType = {
  id: string
  propertyId: string
  year: number
  monthlyRent: number
  vacancyRate: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt: Date
  _count: ProjectionCountAggregateOutputType | null
  _avg: ProjectionAvgAggregateOutputType | null
  _sum: ProjectionSumAggregateOutputType | null
  _min: ProjectionMinAggregateOutputType | null
  _max: ProjectionMaxAggregateOutputType | null
}

type GetProjectionGroupByPayload<T extends ProjectionGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ProjectionGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ProjectionGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProjectionGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProjectionGroupByOutputType[P]>
      }
    >
  >



export type ProjectionWhereInput = {
  AND?: Prisma.ProjectionWhereInput | Prisma.ProjectionWhereInput[]
  OR?: Prisma.ProjectionWhereInput[]
  NOT?: Prisma.ProjectionWhereInput | Prisma.ProjectionWhereInput[]
  id?: Prisma.StringFilter<"Projection"> | string
  propertyId?: Prisma.StringFilter<"Projection"> | string
  year?: Prisma.IntFilter<"Projection"> | number
  monthlyRent?: Prisma.FloatFilter<"Projection"> | number
  vacancyRate?: Prisma.FloatFilter<"Projection"> | number
  operatingExpenses?: Prisma.FloatFilter<"Projection"> | number
  mortgagePayment?: Prisma.FloatFilter<"Projection"> | number
  cashFlow?: Prisma.FloatFilter<"Projection"> | number
  equityBuild?: Prisma.FloatFilter<"Projection"> | number
  totalReturn?: Prisma.FloatFilter<"Projection"> | number
  createdAt?: Prisma.DateTimeFilter<"Projection"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type ProjectionOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type ProjectionWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.ProjectionWhereInput | Prisma.ProjectionWhereInput[]
  OR?: Prisma.ProjectionWhereInput[]
  NOT?: Prisma.ProjectionWhereInput | Prisma.ProjectionWhereInput[]
  propertyId?: Prisma.StringFilter<"Projection"> | string
  year?: Prisma.IntFilter<"Projection"> | number
  monthlyRent?: Prisma.FloatFilter<"Projection"> | number
  vacancyRate?: Prisma.FloatFilter<"Projection"> | number
  operatingExpenses?: Prisma.FloatFilter<"Projection"> | number
  mortgagePayment?: Prisma.FloatFilter<"Projection"> | number
  cashFlow?: Prisma.FloatFilter<"Projection"> | number
  equityBuild?: Prisma.FloatFilter<"Projection"> | number
  totalReturn?: Prisma.FloatFilter<"Projection"> | number
  createdAt?: Prisma.DateTimeFilter<"Projection"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type ProjectionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.ProjectionCountOrderByAggregateInput
  _avg?: Prisma.ProjectionAvgOrderByAggregateInput
  _max?: Prisma.ProjectionMaxOrderByAggregateInput
  _min?: Prisma.ProjectionMinOrderByAggregateInput
  _sum?: Prisma.ProjectionSumOrderByAggregateInput
}

export type ProjectionScalarWhereWithAggregatesInput = {
  AND?: Prisma.ProjectionScalarWhereWithAggregatesInput | Prisma.ProjectionScalarWhereWithAggregatesInput[]
  OR?: Prisma.ProjectionScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ProjectionScalarWhereWithAggregatesInput | Prisma.ProjectionScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Projection"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"Projection"> | string
  year?: Prisma.IntWithAggregatesFilter<"Projection"> | number
  monthlyRent?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  vacancyRate?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  operatingExpenses?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  mortgagePayment?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  cashFlow?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  equityBuild?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  totalReturn?: Prisma.FloatWithAggregatesFilter<"Projection"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Projection"> | Date | string
}

export type ProjectionCreateInput = {
  id?: string
  year: number
  monthlyRent: number
  vacancyRate?: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutProjectionsInput
}

export type ProjectionUncheckedCreateInput = {
  id?: string
  propertyId: string
  year: number
  monthlyRent: number
  vacancyRate?: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt?: Date | string
}

export type ProjectionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutProjectionsNestedInput
}

export type ProjectionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectionCreateManyInput = {
  id?: string
  propertyId: string
  year: number
  monthlyRent: number
  vacancyRate?: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt?: Date | string
}

export type ProjectionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectionListRelationFilter = {
  every?: Prisma.ProjectionWhereInput
  some?: Prisma.ProjectionWhereInput
  none?: Prisma.ProjectionWhereInput
}

export type ProjectionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ProjectionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ProjectionAvgOrderByAggregateInput = {
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
}

export type ProjectionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ProjectionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type ProjectionSumOrderByAggregateInput = {
  year?: Prisma.SortOrder
  monthlyRent?: Prisma.SortOrder
  vacancyRate?: Prisma.SortOrder
  operatingExpenses?: Prisma.SortOrder
  mortgagePayment?: Prisma.SortOrder
  cashFlow?: Prisma.SortOrder
  equityBuild?: Prisma.SortOrder
  totalReturn?: Prisma.SortOrder
}

export type ProjectionCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.ProjectionCreateWithoutPropertyInput, Prisma.ProjectionUncheckedCreateWithoutPropertyInput> | Prisma.ProjectionCreateWithoutPropertyInput[] | Prisma.ProjectionUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ProjectionCreateOrConnectWithoutPropertyInput | Prisma.ProjectionCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.ProjectionCreateManyPropertyInputEnvelope
  connect?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
}

export type ProjectionUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.ProjectionCreateWithoutPropertyInput, Prisma.ProjectionUncheckedCreateWithoutPropertyInput> | Prisma.ProjectionCreateWithoutPropertyInput[] | Prisma.ProjectionUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ProjectionCreateOrConnectWithoutPropertyInput | Prisma.ProjectionCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.ProjectionCreateManyPropertyInputEnvelope
  connect?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
}

export type ProjectionUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.ProjectionCreateWithoutPropertyInput, Prisma.ProjectionUncheckedCreateWithoutPropertyInput> | Prisma.ProjectionCreateWithoutPropertyInput[] | Prisma.ProjectionUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ProjectionCreateOrConnectWithoutPropertyInput | Prisma.ProjectionCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.ProjectionUpsertWithWhereUniqueWithoutPropertyInput | Prisma.ProjectionUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.ProjectionCreateManyPropertyInputEnvelope
  set?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  disconnect?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  delete?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  connect?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  update?: Prisma.ProjectionUpdateWithWhereUniqueWithoutPropertyInput | Prisma.ProjectionUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.ProjectionUpdateManyWithWhereWithoutPropertyInput | Prisma.ProjectionUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.ProjectionScalarWhereInput | Prisma.ProjectionScalarWhereInput[]
}

export type ProjectionUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.ProjectionCreateWithoutPropertyInput, Prisma.ProjectionUncheckedCreateWithoutPropertyInput> | Prisma.ProjectionCreateWithoutPropertyInput[] | Prisma.ProjectionUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.ProjectionCreateOrConnectWithoutPropertyInput | Prisma.ProjectionCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.ProjectionUpsertWithWhereUniqueWithoutPropertyInput | Prisma.ProjectionUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.ProjectionCreateManyPropertyInputEnvelope
  set?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  disconnect?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  delete?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  connect?: Prisma.ProjectionWhereUniqueInput | Prisma.ProjectionWhereUniqueInput[]
  update?: Prisma.ProjectionUpdateWithWhereUniqueWithoutPropertyInput | Prisma.ProjectionUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.ProjectionUpdateManyWithWhereWithoutPropertyInput | Prisma.ProjectionUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.ProjectionScalarWhereInput | Prisma.ProjectionScalarWhereInput[]
}

export type ProjectionCreateWithoutPropertyInput = {
  id?: string
  year: number
  monthlyRent: number
  vacancyRate?: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt?: Date | string
}

export type ProjectionUncheckedCreateWithoutPropertyInput = {
  id?: string
  year: number
  monthlyRent: number
  vacancyRate?: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt?: Date | string
}

export type ProjectionCreateOrConnectWithoutPropertyInput = {
  where: Prisma.ProjectionWhereUniqueInput
  create: Prisma.XOR<Prisma.ProjectionCreateWithoutPropertyInput, Prisma.ProjectionUncheckedCreateWithoutPropertyInput>
}

export type ProjectionCreateManyPropertyInputEnvelope = {
  data: Prisma.ProjectionCreateManyPropertyInput | Prisma.ProjectionCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type ProjectionUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.ProjectionWhereUniqueInput
  update: Prisma.XOR<Prisma.ProjectionUpdateWithoutPropertyInput, Prisma.ProjectionUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.ProjectionCreateWithoutPropertyInput, Prisma.ProjectionUncheckedCreateWithoutPropertyInput>
}

export type ProjectionUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.ProjectionWhereUniqueInput
  data: Prisma.XOR<Prisma.ProjectionUpdateWithoutPropertyInput, Prisma.ProjectionUncheckedUpdateWithoutPropertyInput>
}

export type ProjectionUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.ProjectionScalarWhereInput
  data: Prisma.XOR<Prisma.ProjectionUpdateManyMutationInput, Prisma.ProjectionUncheckedUpdateManyWithoutPropertyInput>
}

export type ProjectionScalarWhereInput = {
  AND?: Prisma.ProjectionScalarWhereInput | Prisma.ProjectionScalarWhereInput[]
  OR?: Prisma.ProjectionScalarWhereInput[]
  NOT?: Prisma.ProjectionScalarWhereInput | Prisma.ProjectionScalarWhereInput[]
  id?: Prisma.StringFilter<"Projection"> | string
  propertyId?: Prisma.StringFilter<"Projection"> | string
  year?: Prisma.IntFilter<"Projection"> | number
  monthlyRent?: Prisma.FloatFilter<"Projection"> | number
  vacancyRate?: Prisma.FloatFilter<"Projection"> | number
  operatingExpenses?: Prisma.FloatFilter<"Projection"> | number
  mortgagePayment?: Prisma.FloatFilter<"Projection"> | number
  cashFlow?: Prisma.FloatFilter<"Projection"> | number
  equityBuild?: Prisma.FloatFilter<"Projection"> | number
  totalReturn?: Prisma.FloatFilter<"Projection"> | number
  createdAt?: Prisma.DateTimeFilter<"Projection"> | Date | string
}

export type ProjectionCreateManyPropertyInput = {
  id?: string
  year: number
  monthlyRent: number
  vacancyRate?: number
  operatingExpenses: number
  mortgagePayment: number
  cashFlow: number
  equityBuild: number
  totalReturn: number
  createdAt?: Date | string
}

export type ProjectionUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectionUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProjectionUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  year?: Prisma.IntFieldUpdateOperationsInput | number
  monthlyRent?: Prisma.FloatFieldUpdateOperationsInput | number
  vacancyRate?: Prisma.FloatFieldUpdateOperationsInput | number
  operatingExpenses?: Prisma.FloatFieldUpdateOperationsInput | number
  mortgagePayment?: Prisma.FloatFieldUpdateOperationsInput | number
  cashFlow?: Prisma.FloatFieldUpdateOperationsInput | number
  equityBuild?: Prisma.FloatFieldUpdateOperationsInput | number
  totalReturn?: Prisma.FloatFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type ProjectionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  year?: boolean
  monthlyRent?: boolean
  vacancyRate?: boolean
  operatingExpenses?: boolean
  mortgagePayment?: boolean
  cashFlow?: boolean
  equityBuild?: boolean
  totalReturn?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["projection"]>

export type ProjectionSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  year?: boolean
  monthlyRent?: boolean
  vacancyRate?: boolean
  operatingExpenses?: boolean
  mortgagePayment?: boolean
  cashFlow?: boolean
  equityBuild?: boolean
  totalReturn?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["projection"]>

export type ProjectionSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  year?: boolean
  monthlyRent?: boolean
  vacancyRate?: boolean
  operatingExpenses?: boolean
  mortgagePayment?: boolean
  cashFlow?: boolean
  equityBuild?: boolean
  totalReturn?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["projection"]>

export type ProjectionSelectScalar = {
  id?: boolean
  propertyId?: boolean
  year?: boolean
  monthlyRent?: boolean
  vacancyRate?: boolean
  operatingExpenses?: boolean
  mortgagePayment?: boolean
  cashFlow?: boolean
  equityBuild?: boolean
  totalReturn?: boolean
  createdAt?: boolean
}

export type ProjectionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "year" | "monthlyRent" | "vacancyRate" | "operatingExpenses" | "mortgagePayment" | "cashFlow" | "equityBuild" | "totalReturn" | "createdAt", ExtArgs["result"]["projection"]>
export type ProjectionInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type ProjectionIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type ProjectionIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $ProjectionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Projection"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    year: number
    monthlyRent: number
    vacancyRate: number
    operatingExpenses: number
    mortgagePayment: number
    cashFlow: number
    equityBuild: number
    totalReturn: number
    createdAt: Date
  }, ExtArgs["result"]["projection"]>
  composites: {}
}

export type ProjectionGetPayload<S extends boolean | null | undefined | ProjectionDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ProjectionPayload, S>

export type ProjectionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ProjectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProjectionCountAggregateInputType | true
  }

export interface ProjectionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Projection'], meta: { name: 'Projection' } }
  /**
   * Find zero or one Projection that matches the filter.
   * @param {ProjectionFindUniqueArgs} args - Arguments to find a Projection
   * @example
   * // Get one Projection
   * const projection = await prisma.projection.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProjectionFindUniqueArgs>(args: Prisma.SelectSubset<T, ProjectionFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Projection that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProjectionFindUniqueOrThrowArgs} args - Arguments to find a Projection
   * @example
   * // Get one Projection
   * const projection = await prisma.projection.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProjectionFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ProjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Projection that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionFindFirstArgs} args - Arguments to find a Projection
   * @example
   * // Get one Projection
   * const projection = await prisma.projection.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProjectionFindFirstArgs>(args?: Prisma.SelectSubset<T, ProjectionFindFirstArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Projection that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionFindFirstOrThrowArgs} args - Arguments to find a Projection
   * @example
   * // Get one Projection
   * const projection = await prisma.projection.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProjectionFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ProjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Projections that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Projections
   * const projections = await prisma.projection.findMany()
   * 
   * // Get first 10 Projections
   * const projections = await prisma.projection.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const projectionWithIdOnly = await prisma.projection.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ProjectionFindManyArgs>(args?: Prisma.SelectSubset<T, ProjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Projection.
   * @param {ProjectionCreateArgs} args - Arguments to create a Projection.
   * @example
   * // Create one Projection
   * const Projection = await prisma.projection.create({
   *   data: {
   *     // ... data to create a Projection
   *   }
   * })
   * 
   */
  create<T extends ProjectionCreateArgs>(args: Prisma.SelectSubset<T, ProjectionCreateArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Projections.
   * @param {ProjectionCreateManyArgs} args - Arguments to create many Projections.
   * @example
   * // Create many Projections
   * const projection = await prisma.projection.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ProjectionCreateManyArgs>(args?: Prisma.SelectSubset<T, ProjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Projections and returns the data saved in the database.
   * @param {ProjectionCreateManyAndReturnArgs} args - Arguments to create many Projections.
   * @example
   * // Create many Projections
   * const projection = await prisma.projection.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Projections and only return the `id`
   * const projectionWithIdOnly = await prisma.projection.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ProjectionCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ProjectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Projection.
   * @param {ProjectionDeleteArgs} args - Arguments to delete one Projection.
   * @example
   * // Delete one Projection
   * const Projection = await prisma.projection.delete({
   *   where: {
   *     // ... filter to delete one Projection
   *   }
   * })
   * 
   */
  delete<T extends ProjectionDeleteArgs>(args: Prisma.SelectSubset<T, ProjectionDeleteArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Projection.
   * @param {ProjectionUpdateArgs} args - Arguments to update one Projection.
   * @example
   * // Update one Projection
   * const projection = await prisma.projection.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ProjectionUpdateArgs>(args: Prisma.SelectSubset<T, ProjectionUpdateArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Projections.
   * @param {ProjectionDeleteManyArgs} args - Arguments to filter Projections to delete.
   * @example
   * // Delete a few Projections
   * const { count } = await prisma.projection.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ProjectionDeleteManyArgs>(args?: Prisma.SelectSubset<T, ProjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Projections.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Projections
   * const projection = await prisma.projection.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ProjectionUpdateManyArgs>(args: Prisma.SelectSubset<T, ProjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Projections and returns the data updated in the database.
   * @param {ProjectionUpdateManyAndReturnArgs} args - Arguments to update many Projections.
   * @example
   * // Update many Projections
   * const projection = await prisma.projection.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Projections and only return the `id`
   * const projectionWithIdOnly = await prisma.projection.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ProjectionUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ProjectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Projection.
   * @param {ProjectionUpsertArgs} args - Arguments to update or create a Projection.
   * @example
   * // Update or create a Projection
   * const projection = await prisma.projection.upsert({
   *   create: {
   *     // ... data to create a Projection
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Projection we want to update
   *   }
   * })
   */
  upsert<T extends ProjectionUpsertArgs>(args: Prisma.SelectSubset<T, ProjectionUpsertArgs<ExtArgs>>): Prisma.Prisma__ProjectionClient<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Projections.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionCountArgs} args - Arguments to filter Projections to count.
   * @example
   * // Count the number of Projections
   * const count = await prisma.projection.count({
   *   where: {
   *     // ... the filter for the Projections we want to count
   *   }
   * })
  **/
  count<T extends ProjectionCountArgs>(
    args?: Prisma.Subset<T, ProjectionCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ProjectionCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Projection.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ProjectionAggregateArgs>(args: Prisma.Subset<T, ProjectionAggregateArgs>): Prisma.PrismaPromise<GetProjectionAggregateType<T>>

  /**
   * Group by Projection.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProjectionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ProjectionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProjectionGroupByArgs['orderBy'] }
      : { orderBy?: ProjectionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ProjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Projection model
 */
readonly fields: ProjectionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Projection.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProjectionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Projection model
 */
export interface ProjectionFieldRefs {
  readonly id: Prisma.FieldRef<"Projection", 'String'>
  readonly propertyId: Prisma.FieldRef<"Projection", 'String'>
  readonly year: Prisma.FieldRef<"Projection", 'Int'>
  readonly monthlyRent: Prisma.FieldRef<"Projection", 'Float'>
  readonly vacancyRate: Prisma.FieldRef<"Projection", 'Float'>
  readonly operatingExpenses: Prisma.FieldRef<"Projection", 'Float'>
  readonly mortgagePayment: Prisma.FieldRef<"Projection", 'Float'>
  readonly cashFlow: Prisma.FieldRef<"Projection", 'Float'>
  readonly equityBuild: Prisma.FieldRef<"Projection", 'Float'>
  readonly totalReturn: Prisma.FieldRef<"Projection", 'Float'>
  readonly createdAt: Prisma.FieldRef<"Projection", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Projection findUnique
 */
export type ProjectionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * Filter, which Projection to fetch.
   */
  where: Prisma.ProjectionWhereUniqueInput
}

/**
 * Projection findUniqueOrThrow
 */
export type ProjectionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * Filter, which Projection to fetch.
   */
  where: Prisma.ProjectionWhereUniqueInput
}

/**
 * Projection findFirst
 */
export type ProjectionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * Filter, which Projection to fetch.
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Projections to fetch.
   */
  orderBy?: Prisma.ProjectionOrderByWithRelationInput | Prisma.ProjectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Projections.
   */
  cursor?: Prisma.ProjectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Projections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Projections.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Projections.
   */
  distinct?: Prisma.ProjectionScalarFieldEnum | Prisma.ProjectionScalarFieldEnum[]
}

/**
 * Projection findFirstOrThrow
 */
export type ProjectionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * Filter, which Projection to fetch.
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Projections to fetch.
   */
  orderBy?: Prisma.ProjectionOrderByWithRelationInput | Prisma.ProjectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Projections.
   */
  cursor?: Prisma.ProjectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Projections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Projections.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Projections.
   */
  distinct?: Prisma.ProjectionScalarFieldEnum | Prisma.ProjectionScalarFieldEnum[]
}

/**
 * Projection findMany
 */
export type ProjectionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * Filter, which Projections to fetch.
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Projections to fetch.
   */
  orderBy?: Prisma.ProjectionOrderByWithRelationInput | Prisma.ProjectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Projections.
   */
  cursor?: Prisma.ProjectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Projections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Projections.
   */
  skip?: number
  distinct?: Prisma.ProjectionScalarFieldEnum | Prisma.ProjectionScalarFieldEnum[]
}

/**
 * Projection create
 */
export type ProjectionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * The data needed to create a Projection.
   */
  data: Prisma.XOR<Prisma.ProjectionCreateInput, Prisma.ProjectionUncheckedCreateInput>
}

/**
 * Projection createMany
 */
export type ProjectionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Projections.
   */
  data: Prisma.ProjectionCreateManyInput | Prisma.ProjectionCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Projection createManyAndReturn
 */
export type ProjectionCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * The data used to create many Projections.
   */
  data: Prisma.ProjectionCreateManyInput | Prisma.ProjectionCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Projection update
 */
export type ProjectionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * The data needed to update a Projection.
   */
  data: Prisma.XOR<Prisma.ProjectionUpdateInput, Prisma.ProjectionUncheckedUpdateInput>
  /**
   * Choose, which Projection to update.
   */
  where: Prisma.ProjectionWhereUniqueInput
}

/**
 * Projection updateMany
 */
export type ProjectionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Projections.
   */
  data: Prisma.XOR<Prisma.ProjectionUpdateManyMutationInput, Prisma.ProjectionUncheckedUpdateManyInput>
  /**
   * Filter which Projections to update
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * Limit how many Projections to update.
   */
  limit?: number
}

/**
 * Projection updateManyAndReturn
 */
export type ProjectionUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * The data used to update Projections.
   */
  data: Prisma.XOR<Prisma.ProjectionUpdateManyMutationInput, Prisma.ProjectionUncheckedUpdateManyInput>
  /**
   * Filter which Projections to update
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * Limit how many Projections to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Projection upsert
 */
export type ProjectionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * The filter to search for the Projection to update in case it exists.
   */
  where: Prisma.ProjectionWhereUniqueInput
  /**
   * In case the Projection found by the `where` argument doesn't exist, create a new Projection with this data.
   */
  create: Prisma.XOR<Prisma.ProjectionCreateInput, Prisma.ProjectionUncheckedCreateInput>
  /**
   * In case the Projection was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ProjectionUpdateInput, Prisma.ProjectionUncheckedUpdateInput>
}

/**
 * Projection delete
 */
export type ProjectionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  /**
   * Filter which Projection to delete.
   */
  where: Prisma.ProjectionWhereUniqueInput
}

/**
 * Projection deleteMany
 */
export type ProjectionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Projections to delete
   */
  where?: Prisma.ProjectionWhereInput
  /**
   * Limit how many Projections to delete.
   */
  limit?: number
}

/**
 * Projection without action
 */
export type ProjectionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\Projection.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\Property.ts
TYPE: TS
SIZE: 189157 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Property` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Property
 * 
 */
export type PropertyModel = runtime.Types.Result.DefaultSelection<Prisma.$PropertyPayload>

export type AggregateProperty = {
  _count: PropertyCountAggregateOutputType | null
  _avg: PropertyAvgAggregateOutputType | null
  _sum: PropertySumAggregateOutputType | null
  _min: PropertyMinAggregateOutputType | null
  _max: PropertyMaxAggregateOutputType | null
}

export type PropertyAvgAggregateOutputType = {
  lat: number | null
  lng: number | null
  listPrice: number | null
  equityGap: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  estimatedRent: number | null
  annualTaxes: number | null
  annualInsurance: number | null
  renovationBudget: number | null
  afterRepairValue: number | null
  purchasePrice: number | null
  dealScore: number | null
}

export type PropertySumAggregateOutputType = {
  lat: number | null
  lng: number | null
  listPrice: number | null
  equityGap: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  estimatedRent: number | null
  annualTaxes: number | null
  annualInsurance: number | null
  renovationBudget: number | null
  afterRepairValue: number | null
  purchasePrice: number | null
  dealScore: number | null
}

export type PropertyMinAggregateOutputType = {
  id: string | null
  address: string | null
  city: string | null
  state: string | null
  zip: string | null
  lat: number | null
  lng: number | null
  listPrice: number | null
  equityGap: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  decision: string | null
  strategy: string | null
  rationale: string | null
  type: string | null
  realtor: string | null
  url: string | null
  details: string | null
  estimatedRent: number | null
  annualTaxes: number | null
  annualInsurance: number | null
  renovationBudget: number | null
  afterRepairValue: number | null
  notes: string | null
  isOwned: boolean | null
  purchasePrice: number | null
  purchaseDate: Date | null
  rehabCompleted: Date | null
  isFavorite: boolean | null
  favoriteNotes: string | null
  dealScore: number | null
  riskLevel: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type PropertyMaxAggregateOutputType = {
  id: string | null
  address: string | null
  city: string | null
  state: string | null
  zip: string | null
  lat: number | null
  lng: number | null
  listPrice: number | null
  equityGap: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  decision: string | null
  strategy: string | null
  rationale: string | null
  type: string | null
  realtor: string | null
  url: string | null
  details: string | null
  estimatedRent: number | null
  annualTaxes: number | null
  annualInsurance: number | null
  renovationBudget: number | null
  afterRepairValue: number | null
  notes: string | null
  isOwned: boolean | null
  purchasePrice: number | null
  purchaseDate: Date | null
  rehabCompleted: Date | null
  isFavorite: boolean | null
  favoriteNotes: string | null
  dealScore: number | null
  riskLevel: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type PropertyCountAggregateOutputType = {
  id: number
  address: number
  city: number
  state: number
  zip: number
  lat: number
  lng: number
  listPrice: number
  equityGap: number
  sqft: number
  bedrooms: number
  bathrooms: number
  decision: number
  strategy: number
  rationale: number
  type: number
  realtor: number
  url: number
  details: number
  images: number
  estimatedRent: number
  annualTaxes: number
  annualInsurance: number
  renovationBudget: number
  afterRepairValue: number
  notes: number
  isOwned: number
  purchasePrice: number
  purchaseDate: number
  rehabCompleted: number
  isFavorite: number
  favoriteNotes: number
  dealScore: number
  riskLevel: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type PropertyAvgAggregateInputType = {
  lat?: true
  lng?: true
  listPrice?: true
  equityGap?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  estimatedRent?: true
  annualTaxes?: true
  annualInsurance?: true
  renovationBudget?: true
  afterRepairValue?: true
  purchasePrice?: true
  dealScore?: true
}

export type PropertySumAggregateInputType = {
  lat?: true
  lng?: true
  listPrice?: true
  equityGap?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  estimatedRent?: true
  annualTaxes?: true
  annualInsurance?: true
  renovationBudget?: true
  afterRepairValue?: true
  purchasePrice?: true
  dealScore?: true
}

export type PropertyMinAggregateInputType = {
  id?: true
  address?: true
  city?: true
  state?: true
  zip?: true
  lat?: true
  lng?: true
  listPrice?: true
  equityGap?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  decision?: true
  strategy?: true
  rationale?: true
  type?: true
  realtor?: true
  url?: true
  details?: true
  estimatedRent?: true
  annualTaxes?: true
  annualInsurance?: true
  renovationBudget?: true
  afterRepairValue?: true
  notes?: true
  isOwned?: true
  purchasePrice?: true
  purchaseDate?: true
  rehabCompleted?: true
  isFavorite?: true
  favoriteNotes?: true
  dealScore?: true
  riskLevel?: true
  createdAt?: true
  updatedAt?: true
}

export type PropertyMaxAggregateInputType = {
  id?: true
  address?: true
  city?: true
  state?: true
  zip?: true
  lat?: true
  lng?: true
  listPrice?: true
  equityGap?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  decision?: true
  strategy?: true
  rationale?: true
  type?: true
  realtor?: true
  url?: true
  details?: true
  estimatedRent?: true
  annualTaxes?: true
  annualInsurance?: true
  renovationBudget?: true
  afterRepairValue?: true
  notes?: true
  isOwned?: true
  purchasePrice?: true
  purchaseDate?: true
  rehabCompleted?: true
  isFavorite?: true
  favoriteNotes?: true
  dealScore?: true
  riskLevel?: true
  createdAt?: true
  updatedAt?: true
}

export type PropertyCountAggregateInputType = {
  id?: true
  address?: true
  city?: true
  state?: true
  zip?: true
  lat?: true
  lng?: true
  listPrice?: true
  equityGap?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  decision?: true
  strategy?: true
  rationale?: true
  type?: true
  realtor?: true
  url?: true
  details?: true
  images?: true
  estimatedRent?: true
  annualTaxes?: true
  annualInsurance?: true
  renovationBudget?: true
  afterRepairValue?: true
  notes?: true
  isOwned?: true
  purchasePrice?: true
  purchaseDate?: true
  rehabCompleted?: true
  isFavorite?: true
  favoriteNotes?: true
  dealScore?: true
  riskLevel?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type PropertyAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Property to aggregate.
   */
  where?: Prisma.PropertyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Properties to fetch.
   */
  orderBy?: Prisma.PropertyOrderByWithRelationInput | Prisma.PropertyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PropertyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Properties from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Properties.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Properties
  **/
  _count?: true | PropertyCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: PropertyAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: PropertySumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PropertyMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PropertyMaxAggregateInputType
}

export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
      [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProperty[P]>
    : Prisma.GetScalarType<T[P], AggregateProperty[P]>
}




export type PropertyGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PropertyWhereInput
  orderBy?: Prisma.PropertyOrderByWithAggregationInput | Prisma.PropertyOrderByWithAggregationInput[]
  by: Prisma.PropertyScalarFieldEnum[] | Prisma.PropertyScalarFieldEnum
  having?: Prisma.PropertyScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PropertyCountAggregateInputType | true
  _avg?: PropertyAvgAggregateInputType
  _sum?: PropertySumAggregateInputType
  _min?: PropertyMinAggregateInputType
  _max?: PropertyMaxAggregateInputType
}

export type PropertyGroupByOutputType = {
  id: string
  address: string
  city: string
  state: string
  zip: string
  lat: number
  lng: number
  listPrice: number
  equityGap: number
  sqft: number
  bedrooms: number
  bathrooms: number
  decision: string
  strategy: string
  rationale: string
  type: string
  realtor: string | null
  url: string | null
  details: string | null
  images: string[]
  estimatedRent: number
  annualTaxes: number
  annualInsurance: number
  renovationBudget: number
  afterRepairValue: number
  notes: string
  isOwned: boolean
  purchasePrice: number
  purchaseDate: Date | null
  rehabCompleted: Date | null
  isFavorite: boolean
  favoriteNotes: string
  dealScore: number
  riskLevel: string
  createdAt: Date
  updatedAt: Date
  _count: PropertyCountAggregateOutputType | null
  _avg: PropertyAvgAggregateOutputType | null
  _sum: PropertySumAggregateOutputType | null
  _min: PropertyMinAggregateOutputType | null
  _max: PropertyMaxAggregateOutputType | null
}

type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PropertyGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PropertyGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PropertyGroupByOutputType[P]>
      }
    >
  >



export type PropertyWhereInput = {
  AND?: Prisma.PropertyWhereInput | Prisma.PropertyWhereInput[]
  OR?: Prisma.PropertyWhereInput[]
  NOT?: Prisma.PropertyWhereInput | Prisma.PropertyWhereInput[]
  id?: Prisma.StringFilter<"Property"> | string
  address?: Prisma.StringFilter<"Property"> | string
  city?: Prisma.StringFilter<"Property"> | string
  state?: Prisma.StringFilter<"Property"> | string
  zip?: Prisma.StringFilter<"Property"> | string
  lat?: Prisma.FloatFilter<"Property"> | number
  lng?: Prisma.FloatFilter<"Property"> | number
  listPrice?: Prisma.IntFilter<"Property"> | number
  equityGap?: Prisma.IntFilter<"Property"> | number
  sqft?: Prisma.IntFilter<"Property"> | number
  bedrooms?: Prisma.IntFilter<"Property"> | number
  bathrooms?: Prisma.FloatFilter<"Property"> | number
  decision?: Prisma.StringFilter<"Property"> | string
  strategy?: Prisma.StringFilter<"Property"> | string
  rationale?: Prisma.StringFilter<"Property"> | string
  type?: Prisma.StringFilter<"Property"> | string
  realtor?: Prisma.StringNullableFilter<"Property"> | string | null
  url?: Prisma.StringNullableFilter<"Property"> | string | null
  details?: Prisma.StringNullableFilter<"Property"> | string | null
  images?: Prisma.StringNullableListFilter<"Property">
  estimatedRent?: Prisma.IntFilter<"Property"> | number
  annualTaxes?: Prisma.IntFilter<"Property"> | number
  annualInsurance?: Prisma.IntFilter<"Property"> | number
  renovationBudget?: Prisma.IntFilter<"Property"> | number
  afterRepairValue?: Prisma.IntFilter<"Property"> | number
  notes?: Prisma.StringFilter<"Property"> | string
  isOwned?: Prisma.BoolFilter<"Property"> | boolean
  purchasePrice?: Prisma.IntFilter<"Property"> | number
  purchaseDate?: Prisma.DateTimeNullableFilter<"Property"> | Date | string | null
  rehabCompleted?: Prisma.DateTimeNullableFilter<"Property"> | Date | string | null
  isFavorite?: Prisma.BoolFilter<"Property"> | boolean
  favoriteNotes?: Prisma.StringFilter<"Property"> | string
  dealScore?: Prisma.FloatFilter<"Property"> | number
  riskLevel?: Prisma.StringFilter<"Property"> | string
  createdAt?: Prisma.DateTimeFilter<"Property"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Property"> | Date | string
  expenses?: Prisma.ExpenseListRelationFilter
  tasks?: Prisma.TaskListRelationFilter
  rehabItems?: Prisma.RehabItemListRelationFilter
  marketData?: Prisma.MarketDataListRelationFilter
  rentComps?: Prisma.RentCompListRelationFilter
  projections?: Prisma.ProjectionListRelationFilter
  timelineEvents?: Prisma.TimelineEventListRelationFilter
  comments?: Prisma.CommentListRelationFilter
  documents?: Prisma.DocumentListRelationFilter
}

export type PropertyOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  address?: Prisma.SortOrder
  city?: Prisma.SortOrder
  state?: Prisma.SortOrder
  zip?: Prisma.SortOrder
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  decision?: Prisma.SortOrder
  strategy?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  type?: Prisma.SortOrder
  realtor?: Prisma.SortOrderInput | Prisma.SortOrder
  url?: Prisma.SortOrderInput | Prisma.SortOrder
  details?: Prisma.SortOrderInput | Prisma.SortOrder
  images?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  isOwned?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  purchaseDate?: Prisma.SortOrderInput | Prisma.SortOrder
  rehabCompleted?: Prisma.SortOrderInput | Prisma.SortOrder
  isFavorite?: Prisma.SortOrder
  favoriteNotes?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
  riskLevel?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  expenses?: Prisma.ExpenseOrderByRelationAggregateInput
  tasks?: Prisma.TaskOrderByRelationAggregateInput
  rehabItems?: Prisma.RehabItemOrderByRelationAggregateInput
  marketData?: Prisma.MarketDataOrderByRelationAggregateInput
  rentComps?: Prisma.RentCompOrderByRelationAggregateInput
  projections?: Prisma.ProjectionOrderByRelationAggregateInput
  timelineEvents?: Prisma.TimelineEventOrderByRelationAggregateInput
  comments?: Prisma.CommentOrderByRelationAggregateInput
  documents?: Prisma.DocumentOrderByRelationAggregateInput
}

export type PropertyWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.PropertyWhereInput | Prisma.PropertyWhereInput[]
  OR?: Prisma.PropertyWhereInput[]
  NOT?: Prisma.PropertyWhereInput | Prisma.PropertyWhereInput[]
  address?: Prisma.StringFilter<"Property"> | string
  city?: Prisma.StringFilter<"Property"> | string
  state?: Prisma.StringFilter<"Property"> | string
  zip?: Prisma.StringFilter<"Property"> | string
  lat?: Prisma.FloatFilter<"Property"> | number
  lng?: Prisma.FloatFilter<"Property"> | number
  listPrice?: Prisma.IntFilter<"Property"> | number
  equityGap?: Prisma.IntFilter<"Property"> | number
  sqft?: Prisma.IntFilter<"Property"> | number
  bedrooms?: Prisma.IntFilter<"Property"> | number
  bathrooms?: Prisma.FloatFilter<"Property"> | number
  decision?: Prisma.StringFilter<"Property"> | string
  strategy?: Prisma.StringFilter<"Property"> | string
  rationale?: Prisma.StringFilter<"Property"> | string
  type?: Prisma.StringFilter<"Property"> | string
  realtor?: Prisma.StringNullableFilter<"Property"> | string | null
  url?: Prisma.StringNullableFilter<"Property"> | string | null
  details?: Prisma.StringNullableFilter<"Property"> | string | null
  images?: Prisma.StringNullableListFilter<"Property">
  estimatedRent?: Prisma.IntFilter<"Property"> | number
  annualTaxes?: Prisma.IntFilter<"Property"> | number
  annualInsurance?: Prisma.IntFilter<"Property"> | number
  renovationBudget?: Prisma.IntFilter<"Property"> | number
  afterRepairValue?: Prisma.IntFilter<"Property"> | number
  notes?: Prisma.StringFilter<"Property"> | string
  isOwned?: Prisma.BoolFilter<"Property"> | boolean
  purchasePrice?: Prisma.IntFilter<"Property"> | number
  purchaseDate?: Prisma.DateTimeNullableFilter<"Property"> | Date | string | null
  rehabCompleted?: Prisma.DateTimeNullableFilter<"Property"> | Date | string | null
  isFavorite?: Prisma.BoolFilter<"Property"> | boolean
  favoriteNotes?: Prisma.StringFilter<"Property"> | string
  dealScore?: Prisma.FloatFilter<"Property"> | number
  riskLevel?: Prisma.StringFilter<"Property"> | string
  createdAt?: Prisma.DateTimeFilter<"Property"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Property"> | Date | string
  expenses?: Prisma.ExpenseListRelationFilter
  tasks?: Prisma.TaskListRelationFilter
  rehabItems?: Prisma.RehabItemListRelationFilter
  marketData?: Prisma.MarketDataListRelationFilter
  rentComps?: Prisma.RentCompListRelationFilter
  projections?: Prisma.ProjectionListRelationFilter
  timelineEvents?: Prisma.TimelineEventListRelationFilter
  comments?: Prisma.CommentListRelationFilter
  documents?: Prisma.DocumentListRelationFilter
}, "id">

export type PropertyOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  address?: Prisma.SortOrder
  city?: Prisma.SortOrder
  state?: Prisma.SortOrder
  zip?: Prisma.SortOrder
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  decision?: Prisma.SortOrder
  strategy?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  type?: Prisma.SortOrder
  realtor?: Prisma.SortOrderInput | Prisma.SortOrder
  url?: Prisma.SortOrderInput | Prisma.SortOrder
  details?: Prisma.SortOrderInput | Prisma.SortOrder
  images?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  isOwned?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  purchaseDate?: Prisma.SortOrderInput | Prisma.SortOrder
  rehabCompleted?: Prisma.SortOrderInput | Prisma.SortOrder
  isFavorite?: Prisma.SortOrder
  favoriteNotes?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
  riskLevel?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.PropertyCountOrderByAggregateInput
  _avg?: Prisma.PropertyAvgOrderByAggregateInput
  _max?: Prisma.PropertyMaxOrderByAggregateInput
  _min?: Prisma.PropertyMinOrderByAggregateInput
  _sum?: Prisma.PropertySumOrderByAggregateInput
}

export type PropertyScalarWhereWithAggregatesInput = {
  AND?: Prisma.PropertyScalarWhereWithAggregatesInput | Prisma.PropertyScalarWhereWithAggregatesInput[]
  OR?: Prisma.PropertyScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PropertyScalarWhereWithAggregatesInput | Prisma.PropertyScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Property"> | string
  address?: Prisma.StringWithAggregatesFilter<"Property"> | string
  city?: Prisma.StringWithAggregatesFilter<"Property"> | string
  state?: Prisma.StringWithAggregatesFilter<"Property"> | string
  zip?: Prisma.StringWithAggregatesFilter<"Property"> | string
  lat?: Prisma.FloatWithAggregatesFilter<"Property"> | number
  lng?: Prisma.FloatWithAggregatesFilter<"Property"> | number
  listPrice?: Prisma.IntWithAggregatesFilter<"Property"> | number
  equityGap?: Prisma.IntWithAggregatesFilter<"Property"> | number
  sqft?: Prisma.IntWithAggregatesFilter<"Property"> | number
  bedrooms?: Prisma.IntWithAggregatesFilter<"Property"> | number
  bathrooms?: Prisma.FloatWithAggregatesFilter<"Property"> | number
  decision?: Prisma.StringWithAggregatesFilter<"Property"> | string
  strategy?: Prisma.StringWithAggregatesFilter<"Property"> | string
  rationale?: Prisma.StringWithAggregatesFilter<"Property"> | string
  type?: Prisma.StringWithAggregatesFilter<"Property"> | string
  realtor?: Prisma.StringNullableWithAggregatesFilter<"Property"> | string | null
  url?: Prisma.StringNullableWithAggregatesFilter<"Property"> | string | null
  details?: Prisma.StringNullableWithAggregatesFilter<"Property"> | string | null
  images?: Prisma.StringNullableListFilter<"Property">
  estimatedRent?: Prisma.IntWithAggregatesFilter<"Property"> | number
  annualTaxes?: Prisma.IntWithAggregatesFilter<"Property"> | number
  annualInsurance?: Prisma.IntWithAggregatesFilter<"Property"> | number
  renovationBudget?: Prisma.IntWithAggregatesFilter<"Property"> | number
  afterRepairValue?: Prisma.IntWithAggregatesFilter<"Property"> | number
  notes?: Prisma.StringWithAggregatesFilter<"Property"> | string
  isOwned?: Prisma.BoolWithAggregatesFilter<"Property"> | boolean
  purchasePrice?: Prisma.IntWithAggregatesFilter<"Property"> | number
  purchaseDate?: Prisma.DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
  rehabCompleted?: Prisma.DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
  isFavorite?: Prisma.BoolWithAggregatesFilter<"Property"> | boolean
  favoriteNotes?: Prisma.StringWithAggregatesFilter<"Property"> | string
  dealScore?: Prisma.FloatWithAggregatesFilter<"Property"> | number
  riskLevel?: Prisma.StringWithAggregatesFilter<"Property"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Property"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Property"> | Date | string
}

export type PropertyCreateInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateManyInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PropertyUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PropertyUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StringNullableListFilter<$PrismaModel = never> = {
  equals?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  has?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  hasEvery?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  hasSome?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  isEmpty?: boolean
}

export type PropertyCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  address?: Prisma.SortOrder
  city?: Prisma.SortOrder
  state?: Prisma.SortOrder
  zip?: Prisma.SortOrder
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  decision?: Prisma.SortOrder
  strategy?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  type?: Prisma.SortOrder
  realtor?: Prisma.SortOrder
  url?: Prisma.SortOrder
  details?: Prisma.SortOrder
  images?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  isOwned?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  purchaseDate?: Prisma.SortOrder
  rehabCompleted?: Prisma.SortOrder
  isFavorite?: Prisma.SortOrder
  favoriteNotes?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
  riskLevel?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PropertyAvgOrderByAggregateInput = {
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
}

export type PropertyMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  address?: Prisma.SortOrder
  city?: Prisma.SortOrder
  state?: Prisma.SortOrder
  zip?: Prisma.SortOrder
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  decision?: Prisma.SortOrder
  strategy?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  type?: Prisma.SortOrder
  realtor?: Prisma.SortOrder
  url?: Prisma.SortOrder
  details?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  isOwned?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  purchaseDate?: Prisma.SortOrder
  rehabCompleted?: Prisma.SortOrder
  isFavorite?: Prisma.SortOrder
  favoriteNotes?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
  riskLevel?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PropertyMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  address?: Prisma.SortOrder
  city?: Prisma.SortOrder
  state?: Prisma.SortOrder
  zip?: Prisma.SortOrder
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  decision?: Prisma.SortOrder
  strategy?: Prisma.SortOrder
  rationale?: Prisma.SortOrder
  type?: Prisma.SortOrder
  realtor?: Prisma.SortOrder
  url?: Prisma.SortOrder
  details?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  isOwned?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  purchaseDate?: Prisma.SortOrder
  rehabCompleted?: Prisma.SortOrder
  isFavorite?: Prisma.SortOrder
  favoriteNotes?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
  riskLevel?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PropertySumOrderByAggregateInput = {
  lat?: Prisma.SortOrder
  lng?: Prisma.SortOrder
  listPrice?: Prisma.SortOrder
  equityGap?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  estimatedRent?: Prisma.SortOrder
  annualTaxes?: Prisma.SortOrder
  annualInsurance?: Prisma.SortOrder
  renovationBudget?: Prisma.SortOrder
  afterRepairValue?: Prisma.SortOrder
  purchasePrice?: Prisma.SortOrder
  dealScore?: Prisma.SortOrder
}

export type PropertyScalarRelationFilter = {
  is?: Prisma.PropertyWhereInput
  isNot?: Prisma.PropertyWhereInput
}

export type PropertyCreateimagesInput = {
  set: string[]
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type PropertyUpdateimagesInput = {
  set?: string[]
  push?: string | string[]
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type PropertyCreateNestedOneWithoutExpensesInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutExpensesInput, Prisma.PropertyUncheckedCreateWithoutExpensesInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutExpensesInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutExpensesNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutExpensesInput, Prisma.PropertyUncheckedCreateWithoutExpensesInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutExpensesInput
  upsert?: Prisma.PropertyUpsertWithoutExpensesInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutExpensesInput, Prisma.PropertyUpdateWithoutExpensesInput>, Prisma.PropertyUncheckedUpdateWithoutExpensesInput>
}

export type PropertyCreateNestedOneWithoutTasksInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutTasksInput, Prisma.PropertyUncheckedCreateWithoutTasksInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutTasksInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutTasksNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutTasksInput, Prisma.PropertyUncheckedCreateWithoutTasksInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutTasksInput
  upsert?: Prisma.PropertyUpsertWithoutTasksInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutTasksInput, Prisma.PropertyUpdateWithoutTasksInput>, Prisma.PropertyUncheckedUpdateWithoutTasksInput>
}

export type PropertyCreateNestedOneWithoutRehabItemsInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutRehabItemsInput, Prisma.PropertyUncheckedCreateWithoutRehabItemsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutRehabItemsInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutRehabItemsNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutRehabItemsInput, Prisma.PropertyUncheckedCreateWithoutRehabItemsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutRehabItemsInput
  upsert?: Prisma.PropertyUpsertWithoutRehabItemsInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutRehabItemsInput, Prisma.PropertyUpdateWithoutRehabItemsInput>, Prisma.PropertyUncheckedUpdateWithoutRehabItemsInput>
}

export type PropertyCreateNestedOneWithoutMarketDataInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutMarketDataInput, Prisma.PropertyUncheckedCreateWithoutMarketDataInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutMarketDataInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutMarketDataNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutMarketDataInput, Prisma.PropertyUncheckedCreateWithoutMarketDataInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutMarketDataInput
  upsert?: Prisma.PropertyUpsertWithoutMarketDataInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutMarketDataInput, Prisma.PropertyUpdateWithoutMarketDataInput>, Prisma.PropertyUncheckedUpdateWithoutMarketDataInput>
}

export type PropertyCreateNestedOneWithoutRentCompsInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutRentCompsInput, Prisma.PropertyUncheckedCreateWithoutRentCompsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutRentCompsInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutRentCompsNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutRentCompsInput, Prisma.PropertyUncheckedCreateWithoutRentCompsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutRentCompsInput
  upsert?: Prisma.PropertyUpsertWithoutRentCompsInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutRentCompsInput, Prisma.PropertyUpdateWithoutRentCompsInput>, Prisma.PropertyUncheckedUpdateWithoutRentCompsInput>
}

export type PropertyCreateNestedOneWithoutProjectionsInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutProjectionsInput, Prisma.PropertyUncheckedCreateWithoutProjectionsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutProjectionsInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutProjectionsNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutProjectionsInput, Prisma.PropertyUncheckedCreateWithoutProjectionsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutProjectionsInput
  upsert?: Prisma.PropertyUpsertWithoutProjectionsInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutProjectionsInput, Prisma.PropertyUpdateWithoutProjectionsInput>, Prisma.PropertyUncheckedUpdateWithoutProjectionsInput>
}

export type PropertyCreateNestedOneWithoutTimelineEventsInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutTimelineEventsInput, Prisma.PropertyUncheckedCreateWithoutTimelineEventsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutTimelineEventsInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutTimelineEventsNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutTimelineEventsInput, Prisma.PropertyUncheckedCreateWithoutTimelineEventsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutTimelineEventsInput
  upsert?: Prisma.PropertyUpsertWithoutTimelineEventsInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutTimelineEventsInput, Prisma.PropertyUpdateWithoutTimelineEventsInput>, Prisma.PropertyUncheckedUpdateWithoutTimelineEventsInput>
}

export type PropertyCreateNestedOneWithoutCommentsInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutCommentsInput, Prisma.PropertyUncheckedCreateWithoutCommentsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutCommentsInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutCommentsNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutCommentsInput, Prisma.PropertyUncheckedCreateWithoutCommentsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutCommentsInput
  upsert?: Prisma.PropertyUpsertWithoutCommentsInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutCommentsInput, Prisma.PropertyUpdateWithoutCommentsInput>, Prisma.PropertyUncheckedUpdateWithoutCommentsInput>
}

export type PropertyCreateNestedOneWithoutDocumentsInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutDocumentsInput, Prisma.PropertyUncheckedCreateWithoutDocumentsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutDocumentsInput
  connect?: Prisma.PropertyWhereUniqueInput
}

export type PropertyUpdateOneRequiredWithoutDocumentsNestedInput = {
  create?: Prisma.XOR<Prisma.PropertyCreateWithoutDocumentsInput, Prisma.PropertyUncheckedCreateWithoutDocumentsInput>
  connectOrCreate?: Prisma.PropertyCreateOrConnectWithoutDocumentsInput
  upsert?: Prisma.PropertyUpsertWithoutDocumentsInput
  connect?: Prisma.PropertyWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PropertyUpdateToOneWithWhereWithoutDocumentsInput, Prisma.PropertyUpdateWithoutDocumentsInput>, Prisma.PropertyUncheckedUpdateWithoutDocumentsInput>
}

export type PropertyCreateWithoutExpensesInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutExpensesInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutExpensesInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutExpensesInput, Prisma.PropertyUncheckedCreateWithoutExpensesInput>
}

export type PropertyUpsertWithoutExpensesInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutExpensesInput, Prisma.PropertyUncheckedUpdateWithoutExpensesInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutExpensesInput, Prisma.PropertyUncheckedCreateWithoutExpensesInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutExpensesInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutExpensesInput, Prisma.PropertyUncheckedUpdateWithoutExpensesInput>
}

export type PropertyUpdateWithoutExpensesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutExpensesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutTasksInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutTasksInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutTasksInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutTasksInput, Prisma.PropertyUncheckedCreateWithoutTasksInput>
}

export type PropertyUpsertWithoutTasksInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutTasksInput, Prisma.PropertyUncheckedUpdateWithoutTasksInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutTasksInput, Prisma.PropertyUncheckedCreateWithoutTasksInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutTasksInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutTasksInput, Prisma.PropertyUncheckedUpdateWithoutTasksInput>
}

export type PropertyUpdateWithoutTasksInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutTasksInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutRehabItemsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutRehabItemsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutRehabItemsInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutRehabItemsInput, Prisma.PropertyUncheckedCreateWithoutRehabItemsInput>
}

export type PropertyUpsertWithoutRehabItemsInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutRehabItemsInput, Prisma.PropertyUncheckedUpdateWithoutRehabItemsInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutRehabItemsInput, Prisma.PropertyUncheckedCreateWithoutRehabItemsInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutRehabItemsInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutRehabItemsInput, Prisma.PropertyUncheckedUpdateWithoutRehabItemsInput>
}

export type PropertyUpdateWithoutRehabItemsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutRehabItemsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutMarketDataInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutMarketDataInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutMarketDataInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutMarketDataInput, Prisma.PropertyUncheckedCreateWithoutMarketDataInput>
}

export type PropertyUpsertWithoutMarketDataInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutMarketDataInput, Prisma.PropertyUncheckedUpdateWithoutMarketDataInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutMarketDataInput, Prisma.PropertyUncheckedCreateWithoutMarketDataInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutMarketDataInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutMarketDataInput, Prisma.PropertyUncheckedUpdateWithoutMarketDataInput>
}

export type PropertyUpdateWithoutMarketDataInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutMarketDataInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutRentCompsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutRentCompsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutRentCompsInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutRentCompsInput, Prisma.PropertyUncheckedCreateWithoutRentCompsInput>
}

export type PropertyUpsertWithoutRentCompsInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutRentCompsInput, Prisma.PropertyUncheckedUpdateWithoutRentCompsInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutRentCompsInput, Prisma.PropertyUncheckedCreateWithoutRentCompsInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutRentCompsInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutRentCompsInput, Prisma.PropertyUncheckedUpdateWithoutRentCompsInput>
}

export type PropertyUpdateWithoutRentCompsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutRentCompsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutProjectionsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutProjectionsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutProjectionsInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutProjectionsInput, Prisma.PropertyUncheckedCreateWithoutProjectionsInput>
}

export type PropertyUpsertWithoutProjectionsInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutProjectionsInput, Prisma.PropertyUncheckedUpdateWithoutProjectionsInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutProjectionsInput, Prisma.PropertyUncheckedCreateWithoutProjectionsInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutProjectionsInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutProjectionsInput, Prisma.PropertyUncheckedUpdateWithoutProjectionsInput>
}

export type PropertyUpdateWithoutProjectionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutProjectionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutTimelineEventsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutTimelineEventsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutTimelineEventsInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutTimelineEventsInput, Prisma.PropertyUncheckedCreateWithoutTimelineEventsInput>
}

export type PropertyUpsertWithoutTimelineEventsInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutTimelineEventsInput, Prisma.PropertyUncheckedUpdateWithoutTimelineEventsInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutTimelineEventsInput, Prisma.PropertyUncheckedCreateWithoutTimelineEventsInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutTimelineEventsInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutTimelineEventsInput, Prisma.PropertyUncheckedUpdateWithoutTimelineEventsInput>
}

export type PropertyUpdateWithoutTimelineEventsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutTimelineEventsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutCommentsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutCommentsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  documents?: Prisma.DocumentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutCommentsInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutCommentsInput, Prisma.PropertyUncheckedCreateWithoutCommentsInput>
}

export type PropertyUpsertWithoutCommentsInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutCommentsInput, Prisma.PropertyUncheckedUpdateWithoutCommentsInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutCommentsInput, Prisma.PropertyUncheckedCreateWithoutCommentsInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutCommentsInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutCommentsInput, Prisma.PropertyUncheckedUpdateWithoutCommentsInput>
}

export type PropertyUpdateWithoutCommentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutCommentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  documents?: Prisma.DocumentUncheckedUpdateManyWithoutPropertyNestedInput
}

export type PropertyCreateWithoutDocumentsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentCreateNestedManyWithoutPropertyInput
}

export type PropertyUncheckedCreateWithoutDocumentsInput = {
  id?: string
  address: string
  city: string
  state?: string
  zip?: string
  lat?: number
  lng?: number
  listPrice: number
  equityGap?: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  decision?: string
  strategy?: string
  rationale?: string
  type?: string
  realtor?: string | null
  url?: string | null
  details?: string | null
  images?: Prisma.PropertyCreateimagesInput | string[]
  estimatedRent?: number
  annualTaxes?: number
  annualInsurance?: number
  renovationBudget?: number
  afterRepairValue?: number
  notes?: string
  isOwned?: boolean
  purchasePrice?: number
  purchaseDate?: Date | string | null
  rehabCompleted?: Date | string | null
  isFavorite?: boolean
  favoriteNotes?: string
  dealScore?: number
  riskLevel?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  expenses?: Prisma.ExpenseUncheckedCreateNestedManyWithoutPropertyInput
  tasks?: Prisma.TaskUncheckedCreateNestedManyWithoutPropertyInput
  rehabItems?: Prisma.RehabItemUncheckedCreateNestedManyWithoutPropertyInput
  marketData?: Prisma.MarketDataUncheckedCreateNestedManyWithoutPropertyInput
  rentComps?: Prisma.RentCompUncheckedCreateNestedManyWithoutPropertyInput
  projections?: Prisma.ProjectionUncheckedCreateNestedManyWithoutPropertyInput
  timelineEvents?: Prisma.TimelineEventUncheckedCreateNestedManyWithoutPropertyInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPropertyInput
}

export type PropertyCreateOrConnectWithoutDocumentsInput = {
  where: Prisma.PropertyWhereUniqueInput
  create: Prisma.XOR<Prisma.PropertyCreateWithoutDocumentsInput, Prisma.PropertyUncheckedCreateWithoutDocumentsInput>
}

export type PropertyUpsertWithoutDocumentsInput = {
  update: Prisma.XOR<Prisma.PropertyUpdateWithoutDocumentsInput, Prisma.PropertyUncheckedUpdateWithoutDocumentsInput>
  create: Prisma.XOR<Prisma.PropertyCreateWithoutDocumentsInput, Prisma.PropertyUncheckedCreateWithoutDocumentsInput>
  where?: Prisma.PropertyWhereInput
}

export type PropertyUpdateToOneWithWhereWithoutDocumentsInput = {
  where?: Prisma.PropertyWhereInput
  data: Prisma.XOR<Prisma.PropertyUpdateWithoutDocumentsInput, Prisma.PropertyUncheckedUpdateWithoutDocumentsInput>
}

export type PropertyUpdateWithoutDocumentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUpdateManyWithoutPropertyNestedInput
}

export type PropertyUncheckedUpdateWithoutDocumentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  city?: Prisma.StringFieldUpdateOperationsInput | string
  state?: Prisma.StringFieldUpdateOperationsInput | string
  zip?: Prisma.StringFieldUpdateOperationsInput | string
  lat?: Prisma.FloatFieldUpdateOperationsInput | number
  lng?: Prisma.FloatFieldUpdateOperationsInput | number
  listPrice?: Prisma.IntFieldUpdateOperationsInput | number
  equityGap?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  decision?: Prisma.StringFieldUpdateOperationsInput | string
  strategy?: Prisma.StringFieldUpdateOperationsInput | string
  rationale?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  realtor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  url?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  details?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  images?: Prisma.PropertyUpdateimagesInput | string[]
  estimatedRent?: Prisma.IntFieldUpdateOperationsInput | number
  annualTaxes?: Prisma.IntFieldUpdateOperationsInput | number
  annualInsurance?: Prisma.IntFieldUpdateOperationsInput | number
  renovationBudget?: Prisma.IntFieldUpdateOperationsInput | number
  afterRepairValue?: Prisma.IntFieldUpdateOperationsInput | number
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  isOwned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  purchasePrice?: Prisma.IntFieldUpdateOperationsInput | number
  purchaseDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  rehabCompleted?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isFavorite?: Prisma.BoolFieldUpdateOperationsInput | boolean
  favoriteNotes?: Prisma.StringFieldUpdateOperationsInput | string
  dealScore?: Prisma.FloatFieldUpdateOperationsInput | number
  riskLevel?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expenses?: Prisma.ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
  tasks?: Prisma.TaskUncheckedUpdateManyWithoutPropertyNestedInput
  rehabItems?: Prisma.RehabItemUncheckedUpdateManyWithoutPropertyNestedInput
  marketData?: Prisma.MarketDataUncheckedUpdateManyWithoutPropertyNestedInput
  rentComps?: Prisma.RentCompUncheckedUpdateManyWithoutPropertyNestedInput
  projections?: Prisma.ProjectionUncheckedUpdateManyWithoutPropertyNestedInput
  timelineEvents?: Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutPropertyNestedInput
}


/**
 * Count Type PropertyCountOutputType
 */

export type PropertyCountOutputType = {
  expenses: number
  tasks: number
  rehabItems: number
  marketData: number
  rentComps: number
  projections: number
  timelineEvents: number
  comments: number
  documents: number
}

export type PropertyCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  expenses?: boolean | PropertyCountOutputTypeCountExpensesArgs
  tasks?: boolean | PropertyCountOutputTypeCountTasksArgs
  rehabItems?: boolean | PropertyCountOutputTypeCountRehabItemsArgs
  marketData?: boolean | PropertyCountOutputTypeCountMarketDataArgs
  rentComps?: boolean | PropertyCountOutputTypeCountRentCompsArgs
  projections?: boolean | PropertyCountOutputTypeCountProjectionsArgs
  timelineEvents?: boolean | PropertyCountOutputTypeCountTimelineEventsArgs
  comments?: boolean | PropertyCountOutputTypeCountCommentsArgs
  documents?: boolean | PropertyCountOutputTypeCountDocumentsArgs
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PropertyCountOutputType
   */
  select?: Prisma.PropertyCountOutputTypeSelect<ExtArgs> | null
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountExpensesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ExpenseWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountTasksArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TaskWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountRehabItemsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RehabItemWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountMarketDataArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.MarketDataWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountRentCompsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RentCompWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountProjectionsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProjectionWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountTimelineEventsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TimelineEventWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountCommentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentWhereInput
}

/**
 * PropertyCountOutputType without action
 */
export type PropertyCountOutputTypeCountDocumentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.DocumentWhereInput
}


export type PropertySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  address?: boolean
  city?: boolean
  state?: boolean
  zip?: boolean
  lat?: boolean
  lng?: boolean
  listPrice?: boolean
  equityGap?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  decision?: boolean
  strategy?: boolean
  rationale?: boolean
  type?: boolean
  realtor?: boolean
  url?: boolean
  details?: boolean
  images?: boolean
  estimatedRent?: boolean
  annualTaxes?: boolean
  annualInsurance?: boolean
  renovationBudget?: boolean
  afterRepairValue?: boolean
  notes?: boolean
  isOwned?: boolean
  purchasePrice?: boolean
  purchaseDate?: boolean
  rehabCompleted?: boolean
  isFavorite?: boolean
  favoriteNotes?: boolean
  dealScore?: boolean
  riskLevel?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  expenses?: boolean | Prisma.Property$expensesArgs<ExtArgs>
  tasks?: boolean | Prisma.Property$tasksArgs<ExtArgs>
  rehabItems?: boolean | Prisma.Property$rehabItemsArgs<ExtArgs>
  marketData?: boolean | Prisma.Property$marketDataArgs<ExtArgs>
  rentComps?: boolean | Prisma.Property$rentCompsArgs<ExtArgs>
  projections?: boolean | Prisma.Property$projectionsArgs<ExtArgs>
  timelineEvents?: boolean | Prisma.Property$timelineEventsArgs<ExtArgs>
  comments?: boolean | Prisma.Property$commentsArgs<ExtArgs>
  documents?: boolean | Prisma.Property$documentsArgs<ExtArgs>
  _count?: boolean | Prisma.PropertyCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["property"]>

export type PropertySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  address?: boolean
  city?: boolean
  state?: boolean
  zip?: boolean
  lat?: boolean
  lng?: boolean
  listPrice?: boolean
  equityGap?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  decision?: boolean
  strategy?: boolean
  rationale?: boolean
  type?: boolean
  realtor?: boolean
  url?: boolean
  details?: boolean
  images?: boolean
  estimatedRent?: boolean
  annualTaxes?: boolean
  annualInsurance?: boolean
  renovationBudget?: boolean
  afterRepairValue?: boolean
  notes?: boolean
  isOwned?: boolean
  purchasePrice?: boolean
  purchaseDate?: boolean
  rehabCompleted?: boolean
  isFavorite?: boolean
  favoriteNotes?: boolean
  dealScore?: boolean
  riskLevel?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}, ExtArgs["result"]["property"]>

export type PropertySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  address?: boolean
  city?: boolean
  state?: boolean
  zip?: boolean
  lat?: boolean
  lng?: boolean
  listPrice?: boolean
  equityGap?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  decision?: boolean
  strategy?: boolean
  rationale?: boolean
  type?: boolean
  realtor?: boolean
  url?: boolean
  details?: boolean
  images?: boolean
  estimatedRent?: boolean
  annualTaxes?: boolean
  annualInsurance?: boolean
  renovationBudget?: boolean
  afterRepairValue?: boolean
  notes?: boolean
  isOwned?: boolean
  purchasePrice?: boolean
  purchaseDate?: boolean
  rehabCompleted?: boolean
  isFavorite?: boolean
  favoriteNotes?: boolean
  dealScore?: boolean
  riskLevel?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}, ExtArgs["result"]["property"]>

export type PropertySelectScalar = {
  id?: boolean
  address?: boolean
  city?: boolean
  state?: boolean
  zip?: boolean
  lat?: boolean
  lng?: boolean
  listPrice?: boolean
  equityGap?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  decision?: boolean
  strategy?: boolean
  rationale?: boolean
  type?: boolean
  realtor?: boolean
  url?: boolean
  details?: boolean
  images?: boolean
  estimatedRent?: boolean
  annualTaxes?: boolean
  annualInsurance?: boolean
  renovationBudget?: boolean
  afterRepairValue?: boolean
  notes?: boolean
  isOwned?: boolean
  purchasePrice?: boolean
  purchaseDate?: boolean
  rehabCompleted?: boolean
  isFavorite?: boolean
  favoriteNotes?: boolean
  dealScore?: boolean
  riskLevel?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type PropertyOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "address" | "city" | "state" | "zip" | "lat" | "lng" | "listPrice" | "equityGap" | "sqft" | "bedrooms" | "bathrooms" | "decision" | "strategy" | "rationale" | "type" | "realtor" | "url" | "details" | "images" | "estimatedRent" | "annualTaxes" | "annualInsurance" | "renovationBudget" | "afterRepairValue" | "notes" | "isOwned" | "purchasePrice" | "purchaseDate" | "rehabCompleted" | "isFavorite" | "favoriteNotes" | "dealScore" | "riskLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["property"]>
export type PropertyInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  expenses?: boolean | Prisma.Property$expensesArgs<ExtArgs>
  tasks?: boolean | Prisma.Property$tasksArgs<ExtArgs>
  rehabItems?: boolean | Prisma.Property$rehabItemsArgs<ExtArgs>
  marketData?: boolean | Prisma.Property$marketDataArgs<ExtArgs>
  rentComps?: boolean | Prisma.Property$rentCompsArgs<ExtArgs>
  projections?: boolean | Prisma.Property$projectionsArgs<ExtArgs>
  timelineEvents?: boolean | Prisma.Property$timelineEventsArgs<ExtArgs>
  comments?: boolean | Prisma.Property$commentsArgs<ExtArgs>
  documents?: boolean | Prisma.Property$documentsArgs<ExtArgs>
  _count?: boolean | Prisma.PropertyCountOutputTypeDefaultArgs<ExtArgs>
}
export type PropertyIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $PropertyPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Property"
  objects: {
    expenses: Prisma.$ExpensePayload<ExtArgs>[]
    tasks: Prisma.$TaskPayload<ExtArgs>[]
    rehabItems: Prisma.$RehabItemPayload<ExtArgs>[]
    marketData: Prisma.$MarketDataPayload<ExtArgs>[]
    rentComps: Prisma.$RentCompPayload<ExtArgs>[]
    projections: Prisma.$ProjectionPayload<ExtArgs>[]
    timelineEvents: Prisma.$TimelineEventPayload<ExtArgs>[]
    comments: Prisma.$CommentPayload<ExtArgs>[]
    documents: Prisma.$DocumentPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    address: string
    city: string
    state: string
    zip: string
    lat: number
    lng: number
    listPrice: number
    equityGap: number
    sqft: number
    bedrooms: number
    bathrooms: number
    decision: string
    strategy: string
    rationale: string
    type: string
    realtor: string | null
    url: string | null
    details: string | null
    images: string[]
    estimatedRent: number
    annualTaxes: number
    annualInsurance: number
    renovationBudget: number
    afterRepairValue: number
    notes: string
    isOwned: boolean
    purchasePrice: number
    purchaseDate: Date | null
    rehabCompleted: Date | null
    isFavorite: boolean
    favoriteNotes: string
    dealScore: number
    riskLevel: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["property"]>
  composites: {}
}

export type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PropertyPayload, S>

export type PropertyCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PropertyCountAggregateInputType | true
  }

export interface PropertyDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
  /**
   * Find zero or one Property that matches the filter.
   * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
   * @example
   * // Get one Property
   * const property = await prisma.property.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PropertyFindUniqueArgs>(args: Prisma.SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Property that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
   * @example
   * // Get one Property
   * const property = await prisma.property.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Property that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyFindFirstArgs} args - Arguments to find a Property
   * @example
   * // Get one Property
   * const property = await prisma.property.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PropertyFindFirstArgs>(args?: Prisma.SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Property that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
   * @example
   * // Get one Property
   * const property = await prisma.property.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Properties that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Properties
   * const properties = await prisma.property.findMany()
   * 
   * // Get first 10 Properties
   * const properties = await prisma.property.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends PropertyFindManyArgs>(args?: Prisma.SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Property.
   * @param {PropertyCreateArgs} args - Arguments to create a Property.
   * @example
   * // Create one Property
   * const Property = await prisma.property.create({
   *   data: {
   *     // ... data to create a Property
   *   }
   * })
   * 
   */
  create<T extends PropertyCreateArgs>(args: Prisma.SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Properties.
   * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
   * @example
   * // Create many Properties
   * const property = await prisma.property.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PropertyCreateManyArgs>(args?: Prisma.SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Properties and returns the data saved in the database.
   * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
   * @example
   * // Create many Properties
   * const property = await prisma.property.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Properties and only return the `id`
   * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Property.
   * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
   * @example
   * // Delete one Property
   * const Property = await prisma.property.delete({
   *   where: {
   *     // ... filter to delete one Property
   *   }
   * })
   * 
   */
  delete<T extends PropertyDeleteArgs>(args: Prisma.SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Property.
   * @param {PropertyUpdateArgs} args - Arguments to update one Property.
   * @example
   * // Update one Property
   * const property = await prisma.property.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PropertyUpdateArgs>(args: Prisma.SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Properties.
   * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
   * @example
   * // Delete a few Properties
   * const { count } = await prisma.property.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PropertyDeleteManyArgs>(args?: Prisma.SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Properties.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Properties
   * const property = await prisma.property.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PropertyUpdateManyArgs>(args: Prisma.SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Properties and returns the data updated in the database.
   * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
   * @example
   * // Update many Properties
   * const property = await prisma.property.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Properties and only return the `id`
   * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Property.
   * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
   * @example
   * // Update or create a Property
   * const property = await prisma.property.upsert({
   *   create: {
   *     // ... data to create a Property
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Property we want to update
   *   }
   * })
   */
  upsert<T extends PropertyUpsertArgs>(args: Prisma.SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Properties.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
   * @example
   * // Count the number of Properties
   * const count = await prisma.property.count({
   *   where: {
   *     // ... the filter for the Properties we want to count
   *   }
   * })
  **/
  count<T extends PropertyCountArgs>(
    args?: Prisma.Subset<T, PropertyCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PropertyCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Property.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PropertyAggregateArgs>(args: Prisma.Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

  /**
   * Group by Property.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PropertyGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PropertyGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PropertyGroupByArgs['orderBy'] }
      : { orderBy?: PropertyGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Property model
 */
readonly fields: PropertyFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Property.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  expenses<T extends Prisma.Property$expensesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  tasks<T extends Prisma.Property$tasksArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  rehabItems<T extends Prisma.Property$rehabItemsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$rehabItemsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  marketData<T extends Prisma.Property$marketDataArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$marketDataArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MarketDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  rentComps<T extends Prisma.Property$rentCompsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$rentCompsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  projections<T extends Prisma.Property$projectionsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$projectionsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  timelineEvents<T extends Prisma.Property$timelineEventsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$timelineEventsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  comments<T extends Prisma.Property$commentsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  documents<T extends Prisma.Property$documentsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Property$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Property model
 */
export interface PropertyFieldRefs {
  readonly id: Prisma.FieldRef<"Property", 'String'>
  readonly address: Prisma.FieldRef<"Property", 'String'>
  readonly city: Prisma.FieldRef<"Property", 'String'>
  readonly state: Prisma.FieldRef<"Property", 'String'>
  readonly zip: Prisma.FieldRef<"Property", 'String'>
  readonly lat: Prisma.FieldRef<"Property", 'Float'>
  readonly lng: Prisma.FieldRef<"Property", 'Float'>
  readonly listPrice: Prisma.FieldRef<"Property", 'Int'>
  readonly equityGap: Prisma.FieldRef<"Property", 'Int'>
  readonly sqft: Prisma.FieldRef<"Property", 'Int'>
  readonly bedrooms: Prisma.FieldRef<"Property", 'Int'>
  readonly bathrooms: Prisma.FieldRef<"Property", 'Float'>
  readonly decision: Prisma.FieldRef<"Property", 'String'>
  readonly strategy: Prisma.FieldRef<"Property", 'String'>
  readonly rationale: Prisma.FieldRef<"Property", 'String'>
  readonly type: Prisma.FieldRef<"Property", 'String'>
  readonly realtor: Prisma.FieldRef<"Property", 'String'>
  readonly url: Prisma.FieldRef<"Property", 'String'>
  readonly details: Prisma.FieldRef<"Property", 'String'>
  readonly images: Prisma.FieldRef<"Property", 'String[]'>
  readonly estimatedRent: Prisma.FieldRef<"Property", 'Int'>
  readonly annualTaxes: Prisma.FieldRef<"Property", 'Int'>
  readonly annualInsurance: Prisma.FieldRef<"Property", 'Int'>
  readonly renovationBudget: Prisma.FieldRef<"Property", 'Int'>
  readonly afterRepairValue: Prisma.FieldRef<"Property", 'Int'>
  readonly notes: Prisma.FieldRef<"Property", 'String'>
  readonly isOwned: Prisma.FieldRef<"Property", 'Boolean'>
  readonly purchasePrice: Prisma.FieldRef<"Property", 'Int'>
  readonly purchaseDate: Prisma.FieldRef<"Property", 'DateTime'>
  readonly rehabCompleted: Prisma.FieldRef<"Property", 'DateTime'>
  readonly isFavorite: Prisma.FieldRef<"Property", 'Boolean'>
  readonly favoriteNotes: Prisma.FieldRef<"Property", 'String'>
  readonly dealScore: Prisma.FieldRef<"Property", 'Float'>
  readonly riskLevel: Prisma.FieldRef<"Property", 'String'>
  readonly createdAt: Prisma.FieldRef<"Property", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Property", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Property findUnique
 */
export type PropertyFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * Filter, which Property to fetch.
   */
  where: Prisma.PropertyWhereUniqueInput
}

/**
 * Property findUniqueOrThrow
 */
export type PropertyFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * Filter, which Property to fetch.
   */
  where: Prisma.PropertyWhereUniqueInput
}

/**
 * Property findFirst
 */
export type PropertyFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * Filter, which Property to fetch.
   */
  where?: Prisma.PropertyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Properties to fetch.
   */
  orderBy?: Prisma.PropertyOrderByWithRelationInput | Prisma.PropertyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Properties.
   */
  cursor?: Prisma.PropertyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Properties from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Properties.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Properties.
   */
  distinct?: Prisma.PropertyScalarFieldEnum | Prisma.PropertyScalarFieldEnum[]
}

/**
 * Property findFirstOrThrow
 */
export type PropertyFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * Filter, which Property to fetch.
   */
  where?: Prisma.PropertyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Properties to fetch.
   */
  orderBy?: Prisma.PropertyOrderByWithRelationInput | Prisma.PropertyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Properties.
   */
  cursor?: Prisma.PropertyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Properties from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Properties.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Properties.
   */
  distinct?: Prisma.PropertyScalarFieldEnum | Prisma.PropertyScalarFieldEnum[]
}

/**
 * Property findMany
 */
export type PropertyFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * Filter, which Properties to fetch.
   */
  where?: Prisma.PropertyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Properties to fetch.
   */
  orderBy?: Prisma.PropertyOrderByWithRelationInput | Prisma.PropertyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Properties.
   */
  cursor?: Prisma.PropertyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Properties from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Properties.
   */
  skip?: number
  distinct?: Prisma.PropertyScalarFieldEnum | Prisma.PropertyScalarFieldEnum[]
}

/**
 * Property create
 */
export type PropertyCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * The data needed to create a Property.
   */
  data: Prisma.XOR<Prisma.PropertyCreateInput, Prisma.PropertyUncheckedCreateInput>
}

/**
 * Property createMany
 */
export type PropertyCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Properties.
   */
  data: Prisma.PropertyCreateManyInput | Prisma.PropertyCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Property createManyAndReturn
 */
export type PropertyCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * The data used to create many Properties.
   */
  data: Prisma.PropertyCreateManyInput | Prisma.PropertyCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Property update
 */
export type PropertyUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * The data needed to update a Property.
   */
  data: Prisma.XOR<Prisma.PropertyUpdateInput, Prisma.PropertyUncheckedUpdateInput>
  /**
   * Choose, which Property to update.
   */
  where: Prisma.PropertyWhereUniqueInput
}

/**
 * Property updateMany
 */
export type PropertyUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Properties.
   */
  data: Prisma.XOR<Prisma.PropertyUpdateManyMutationInput, Prisma.PropertyUncheckedUpdateManyInput>
  /**
   * Filter which Properties to update
   */
  where?: Prisma.PropertyWhereInput
  /**
   * Limit how many Properties to update.
   */
  limit?: number
}

/**
 * Property updateManyAndReturn
 */
export type PropertyUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * The data used to update Properties.
   */
  data: Prisma.XOR<Prisma.PropertyUpdateManyMutationInput, Prisma.PropertyUncheckedUpdateManyInput>
  /**
   * Filter which Properties to update
   */
  where?: Prisma.PropertyWhereInput
  /**
   * Limit how many Properties to update.
   */
  limit?: number
}

/**
 * Property upsert
 */
export type PropertyUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * The filter to search for the Property to update in case it exists.
   */
  where: Prisma.PropertyWhereUniqueInput
  /**
   * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
   */
  create: Prisma.XOR<Prisma.PropertyCreateInput, Prisma.PropertyUncheckedCreateInput>
  /**
   * In case the Property was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PropertyUpdateInput, Prisma.PropertyUncheckedUpdateInput>
}

/**
 * Property delete
 */
export type PropertyDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
  /**
   * Filter which Property to delete.
   */
  where: Prisma.PropertyWhereUniqueInput
}

/**
 * Property deleteMany
 */
export type PropertyDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Properties to delete
   */
  where?: Prisma.PropertyWhereInput
  /**
   * Limit how many Properties to delete.
   */
  limit?: number
}

/**
 * Property.expenses
 */
export type Property$expensesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Expense
   */
  select?: Prisma.ExpenseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Expense
   */
  omit?: Prisma.ExpenseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExpenseInclude<ExtArgs> | null
  where?: Prisma.ExpenseWhereInput
  orderBy?: Prisma.ExpenseOrderByWithRelationInput | Prisma.ExpenseOrderByWithRelationInput[]
  cursor?: Prisma.ExpenseWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ExpenseScalarFieldEnum | Prisma.ExpenseScalarFieldEnum[]
}

/**
 * Property.tasks
 */
export type Property$tasksArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  where?: Prisma.TaskWhereInput
  orderBy?: Prisma.TaskOrderByWithRelationInput | Prisma.TaskOrderByWithRelationInput[]
  cursor?: Prisma.TaskWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.TaskScalarFieldEnum | Prisma.TaskScalarFieldEnum[]
}

/**
 * Property.rehabItems
 */
export type Property$rehabItemsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  where?: Prisma.RehabItemWhereInput
  orderBy?: Prisma.RehabItemOrderByWithRelationInput | Prisma.RehabItemOrderByWithRelationInput[]
  cursor?: Prisma.RehabItemWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.RehabItemScalarFieldEnum | Prisma.RehabItemScalarFieldEnum[]
}

/**
 * Property.marketData
 */
export type Property$marketDataArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MarketData
   */
  select?: Prisma.MarketDataSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MarketData
   */
  omit?: Prisma.MarketDataOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarketDataInclude<ExtArgs> | null
  where?: Prisma.MarketDataWhereInput
  orderBy?: Prisma.MarketDataOrderByWithRelationInput | Prisma.MarketDataOrderByWithRelationInput[]
  cursor?: Prisma.MarketDataWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.MarketDataScalarFieldEnum | Prisma.MarketDataScalarFieldEnum[]
}

/**
 * Property.rentComps
 */
export type Property$rentCompsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  where?: Prisma.RentCompWhereInput
  orderBy?: Prisma.RentCompOrderByWithRelationInput | Prisma.RentCompOrderByWithRelationInput[]
  cursor?: Prisma.RentCompWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.RentCompScalarFieldEnum | Prisma.RentCompScalarFieldEnum[]
}

/**
 * Property.projections
 */
export type Property$projectionsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Projection
   */
  select?: Prisma.ProjectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Projection
   */
  omit?: Prisma.ProjectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProjectionInclude<ExtArgs> | null
  where?: Prisma.ProjectionWhereInput
  orderBy?: Prisma.ProjectionOrderByWithRelationInput | Prisma.ProjectionOrderByWithRelationInput[]
  cursor?: Prisma.ProjectionWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ProjectionScalarFieldEnum | Prisma.ProjectionScalarFieldEnum[]
}

/**
 * Property.timelineEvents
 */
export type Property$timelineEventsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  where?: Prisma.TimelineEventWhereInput
  orderBy?: Prisma.TimelineEventOrderByWithRelationInput | Prisma.TimelineEventOrderByWithRelationInput[]
  cursor?: Prisma.TimelineEventWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.TimelineEventScalarFieldEnum | Prisma.TimelineEventScalarFieldEnum[]
}

/**
 * Property.comments
 */
export type Property$commentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  where?: Prisma.CommentWhereInput
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  cursor?: Prisma.CommentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Property.documents
 */
export type Property$documentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Document
   */
  select?: Prisma.DocumentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Document
   */
  omit?: Prisma.DocumentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentInclude<ExtArgs> | null
  where?: Prisma.DocumentWhereInput
  orderBy?: Prisma.DocumentOrderByWithRelationInput | Prisma.DocumentOrderByWithRelationInput[]
  cursor?: Prisma.DocumentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.DocumentScalarFieldEnum | Prisma.DocumentScalarFieldEnum[]
}

/**
 * Property without action
 */
export type PropertyDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Property
   */
  select?: Prisma.PropertySelect<ExtArgs> | null
  /**
   * Omit specific fields from the Property
   */
  omit?: Prisma.PropertyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PropertyInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\Property.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\RehabItem.ts
TYPE: TS
SIZE: 58787 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `RehabItem` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model RehabItem
 * 
 */
export type RehabItemModel = runtime.Types.Result.DefaultSelection<Prisma.$RehabItemPayload>

export type AggregateRehabItem = {
  _count: RehabItemCountAggregateOutputType | null
  _avg: RehabItemAvgAggregateOutputType | null
  _sum: RehabItemSumAggregateOutputType | null
  _min: RehabItemMinAggregateOutputType | null
  _max: RehabItemMaxAggregateOutputType | null
}

export type RehabItemAvgAggregateOutputType = {
  quantity: number | null
  unitCost: number | null
  totalCost: number | null
}

export type RehabItemSumAggregateOutputType = {
  quantity: number | null
  unitCost: number | null
  totalCost: number | null
}

export type RehabItemMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  category: string | null
  item: string | null
  quantity: number | null
  unitCost: number | null
  totalCost: number | null
  isCompleted: boolean | null
  notes: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type RehabItemMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  category: string | null
  item: string | null
  quantity: number | null
  unitCost: number | null
  totalCost: number | null
  isCompleted: boolean | null
  notes: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type RehabItemCountAggregateOutputType = {
  id: number
  propertyId: number
  category: number
  item: number
  quantity: number
  unitCost: number
  totalCost: number
  isCompleted: number
  notes: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type RehabItemAvgAggregateInputType = {
  quantity?: true
  unitCost?: true
  totalCost?: true
}

export type RehabItemSumAggregateInputType = {
  quantity?: true
  unitCost?: true
  totalCost?: true
}

export type RehabItemMinAggregateInputType = {
  id?: true
  propertyId?: true
  category?: true
  item?: true
  quantity?: true
  unitCost?: true
  totalCost?: true
  isCompleted?: true
  notes?: true
  createdAt?: true
  updatedAt?: true
}

export type RehabItemMaxAggregateInputType = {
  id?: true
  propertyId?: true
  category?: true
  item?: true
  quantity?: true
  unitCost?: true
  totalCost?: true
  isCompleted?: true
  notes?: true
  createdAt?: true
  updatedAt?: true
}

export type RehabItemCountAggregateInputType = {
  id?: true
  propertyId?: true
  category?: true
  item?: true
  quantity?: true
  unitCost?: true
  totalCost?: true
  isCompleted?: true
  notes?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type RehabItemAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RehabItem to aggregate.
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RehabItems to fetch.
   */
  orderBy?: Prisma.RehabItemOrderByWithRelationInput | Prisma.RehabItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.RehabItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RehabItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RehabItems.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned RehabItems
  **/
  _count?: true | RehabItemCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: RehabItemAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: RehabItemSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: RehabItemMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: RehabItemMaxAggregateInputType
}

export type GetRehabItemAggregateType<T extends RehabItemAggregateArgs> = {
      [P in keyof T & keyof AggregateRehabItem]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateRehabItem[P]>
    : Prisma.GetScalarType<T[P], AggregateRehabItem[P]>
}




export type RehabItemGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RehabItemWhereInput
  orderBy?: Prisma.RehabItemOrderByWithAggregationInput | Prisma.RehabItemOrderByWithAggregationInput[]
  by: Prisma.RehabItemScalarFieldEnum[] | Prisma.RehabItemScalarFieldEnum
  having?: Prisma.RehabItemScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: RehabItemCountAggregateInputType | true
  _avg?: RehabItemAvgAggregateInputType
  _sum?: RehabItemSumAggregateInputType
  _min?: RehabItemMinAggregateInputType
  _max?: RehabItemMaxAggregateInputType
}

export type RehabItemGroupByOutputType = {
  id: string
  propertyId: string
  category: string
  item: string
  quantity: number
  unitCost: number
  totalCost: number
  isCompleted: boolean
  notes: string
  createdAt: Date
  updatedAt: Date
  _count: RehabItemCountAggregateOutputType | null
  _avg: RehabItemAvgAggregateOutputType | null
  _sum: RehabItemSumAggregateOutputType | null
  _min: RehabItemMinAggregateOutputType | null
  _max: RehabItemMaxAggregateOutputType | null
}

type GetRehabItemGroupByPayload<T extends RehabItemGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<RehabItemGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof RehabItemGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], RehabItemGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], RehabItemGroupByOutputType[P]>
      }
    >
  >



export type RehabItemWhereInput = {
  AND?: Prisma.RehabItemWhereInput | Prisma.RehabItemWhereInput[]
  OR?: Prisma.RehabItemWhereInput[]
  NOT?: Prisma.RehabItemWhereInput | Prisma.RehabItemWhereInput[]
  id?: Prisma.StringFilter<"RehabItem"> | string
  propertyId?: Prisma.StringFilter<"RehabItem"> | string
  category?: Prisma.StringFilter<"RehabItem"> | string
  item?: Prisma.StringFilter<"RehabItem"> | string
  quantity?: Prisma.IntFilter<"RehabItem"> | number
  unitCost?: Prisma.FloatFilter<"RehabItem"> | number
  totalCost?: Prisma.FloatFilter<"RehabItem"> | number
  isCompleted?: Prisma.BoolFilter<"RehabItem"> | boolean
  notes?: Prisma.StringFilter<"RehabItem"> | string
  createdAt?: Prisma.DateTimeFilter<"RehabItem"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"RehabItem"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type RehabItemOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  item?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type RehabItemWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.RehabItemWhereInput | Prisma.RehabItemWhereInput[]
  OR?: Prisma.RehabItemWhereInput[]
  NOT?: Prisma.RehabItemWhereInput | Prisma.RehabItemWhereInput[]
  propertyId?: Prisma.StringFilter<"RehabItem"> | string
  category?: Prisma.StringFilter<"RehabItem"> | string
  item?: Prisma.StringFilter<"RehabItem"> | string
  quantity?: Prisma.IntFilter<"RehabItem"> | number
  unitCost?: Prisma.FloatFilter<"RehabItem"> | number
  totalCost?: Prisma.FloatFilter<"RehabItem"> | number
  isCompleted?: Prisma.BoolFilter<"RehabItem"> | boolean
  notes?: Prisma.StringFilter<"RehabItem"> | string
  createdAt?: Prisma.DateTimeFilter<"RehabItem"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"RehabItem"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type RehabItemOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  item?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.RehabItemCountOrderByAggregateInput
  _avg?: Prisma.RehabItemAvgOrderByAggregateInput
  _max?: Prisma.RehabItemMaxOrderByAggregateInput
  _min?: Prisma.RehabItemMinOrderByAggregateInput
  _sum?: Prisma.RehabItemSumOrderByAggregateInput
}

export type RehabItemScalarWhereWithAggregatesInput = {
  AND?: Prisma.RehabItemScalarWhereWithAggregatesInput | Prisma.RehabItemScalarWhereWithAggregatesInput[]
  OR?: Prisma.RehabItemScalarWhereWithAggregatesInput[]
  NOT?: Prisma.RehabItemScalarWhereWithAggregatesInput | Prisma.RehabItemScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"RehabItem"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"RehabItem"> | string
  category?: Prisma.StringWithAggregatesFilter<"RehabItem"> | string
  item?: Prisma.StringWithAggregatesFilter<"RehabItem"> | string
  quantity?: Prisma.IntWithAggregatesFilter<"RehabItem"> | number
  unitCost?: Prisma.FloatWithAggregatesFilter<"RehabItem"> | number
  totalCost?: Prisma.FloatWithAggregatesFilter<"RehabItem"> | number
  isCompleted?: Prisma.BoolWithAggregatesFilter<"RehabItem"> | boolean
  notes?: Prisma.StringWithAggregatesFilter<"RehabItem"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"RehabItem"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"RehabItem"> | Date | string
}

export type RehabItemCreateInput = {
  id?: string
  category: string
  item: string
  quantity?: number
  unitCost: number
  totalCost: number
  isCompleted?: boolean
  notes?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutRehabItemsInput
}

export type RehabItemUncheckedCreateInput = {
  id?: string
  propertyId: string
  category: string
  item: string
  quantity?: number
  unitCost: number
  totalCost: number
  isCompleted?: boolean
  notes?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type RehabItemUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutRehabItemsNestedInput
}

export type RehabItemUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RehabItemCreateManyInput = {
  id?: string
  propertyId: string
  category: string
  item: string
  quantity?: number
  unitCost: number
  totalCost: number
  isCompleted?: boolean
  notes?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type RehabItemUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RehabItemUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RehabItemListRelationFilter = {
  every?: Prisma.RehabItemWhereInput
  some?: Prisma.RehabItemWhereInput
  none?: Prisma.RehabItemWhereInput
}

export type RehabItemOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type RehabItemCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  item?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type RehabItemAvgOrderByAggregateInput = {
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
}

export type RehabItemMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  item?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type RehabItemMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  category?: Prisma.SortOrder
  item?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type RehabItemSumOrderByAggregateInput = {
  quantity?: Prisma.SortOrder
  unitCost?: Prisma.SortOrder
  totalCost?: Prisma.SortOrder
}

export type RehabItemCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.RehabItemCreateWithoutPropertyInput, Prisma.RehabItemUncheckedCreateWithoutPropertyInput> | Prisma.RehabItemCreateWithoutPropertyInput[] | Prisma.RehabItemUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RehabItemCreateOrConnectWithoutPropertyInput | Prisma.RehabItemCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.RehabItemCreateManyPropertyInputEnvelope
  connect?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
}

export type RehabItemUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.RehabItemCreateWithoutPropertyInput, Prisma.RehabItemUncheckedCreateWithoutPropertyInput> | Prisma.RehabItemCreateWithoutPropertyInput[] | Prisma.RehabItemUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RehabItemCreateOrConnectWithoutPropertyInput | Prisma.RehabItemCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.RehabItemCreateManyPropertyInputEnvelope
  connect?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
}

export type RehabItemUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.RehabItemCreateWithoutPropertyInput, Prisma.RehabItemUncheckedCreateWithoutPropertyInput> | Prisma.RehabItemCreateWithoutPropertyInput[] | Prisma.RehabItemUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RehabItemCreateOrConnectWithoutPropertyInput | Prisma.RehabItemCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.RehabItemUpsertWithWhereUniqueWithoutPropertyInput | Prisma.RehabItemUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.RehabItemCreateManyPropertyInputEnvelope
  set?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  disconnect?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  delete?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  connect?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  update?: Prisma.RehabItemUpdateWithWhereUniqueWithoutPropertyInput | Prisma.RehabItemUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.RehabItemUpdateManyWithWhereWithoutPropertyInput | Prisma.RehabItemUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.RehabItemScalarWhereInput | Prisma.RehabItemScalarWhereInput[]
}

export type RehabItemUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.RehabItemCreateWithoutPropertyInput, Prisma.RehabItemUncheckedCreateWithoutPropertyInput> | Prisma.RehabItemCreateWithoutPropertyInput[] | Prisma.RehabItemUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RehabItemCreateOrConnectWithoutPropertyInput | Prisma.RehabItemCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.RehabItemUpsertWithWhereUniqueWithoutPropertyInput | Prisma.RehabItemUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.RehabItemCreateManyPropertyInputEnvelope
  set?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  disconnect?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  delete?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  connect?: Prisma.RehabItemWhereUniqueInput | Prisma.RehabItemWhereUniqueInput[]
  update?: Prisma.RehabItemUpdateWithWhereUniqueWithoutPropertyInput | Prisma.RehabItemUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.RehabItemUpdateManyWithWhereWithoutPropertyInput | Prisma.RehabItemUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.RehabItemScalarWhereInput | Prisma.RehabItemScalarWhereInput[]
}

export type RehabItemCreateWithoutPropertyInput = {
  id?: string
  category: string
  item: string
  quantity?: number
  unitCost: number
  totalCost: number
  isCompleted?: boolean
  notes?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type RehabItemUncheckedCreateWithoutPropertyInput = {
  id?: string
  category: string
  item: string
  quantity?: number
  unitCost: number
  totalCost: number
  isCompleted?: boolean
  notes?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type RehabItemCreateOrConnectWithoutPropertyInput = {
  where: Prisma.RehabItemWhereUniqueInput
  create: Prisma.XOR<Prisma.RehabItemCreateWithoutPropertyInput, Prisma.RehabItemUncheckedCreateWithoutPropertyInput>
}

export type RehabItemCreateManyPropertyInputEnvelope = {
  data: Prisma.RehabItemCreateManyPropertyInput | Prisma.RehabItemCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type RehabItemUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.RehabItemWhereUniqueInput
  update: Prisma.XOR<Prisma.RehabItemUpdateWithoutPropertyInput, Prisma.RehabItemUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.RehabItemCreateWithoutPropertyInput, Prisma.RehabItemUncheckedCreateWithoutPropertyInput>
}

export type RehabItemUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.RehabItemWhereUniqueInput
  data: Prisma.XOR<Prisma.RehabItemUpdateWithoutPropertyInput, Prisma.RehabItemUncheckedUpdateWithoutPropertyInput>
}

export type RehabItemUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.RehabItemScalarWhereInput
  data: Prisma.XOR<Prisma.RehabItemUpdateManyMutationInput, Prisma.RehabItemUncheckedUpdateManyWithoutPropertyInput>
}

export type RehabItemScalarWhereInput = {
  AND?: Prisma.RehabItemScalarWhereInput | Prisma.RehabItemScalarWhereInput[]
  OR?: Prisma.RehabItemScalarWhereInput[]
  NOT?: Prisma.RehabItemScalarWhereInput | Prisma.RehabItemScalarWhereInput[]
  id?: Prisma.StringFilter<"RehabItem"> | string
  propertyId?: Prisma.StringFilter<"RehabItem"> | string
  category?: Prisma.StringFilter<"RehabItem"> | string
  item?: Prisma.StringFilter<"RehabItem"> | string
  quantity?: Prisma.IntFilter<"RehabItem"> | number
  unitCost?: Prisma.FloatFilter<"RehabItem"> | number
  totalCost?: Prisma.FloatFilter<"RehabItem"> | number
  isCompleted?: Prisma.BoolFilter<"RehabItem"> | boolean
  notes?: Prisma.StringFilter<"RehabItem"> | string
  createdAt?: Prisma.DateTimeFilter<"RehabItem"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"RehabItem"> | Date | string
}

export type RehabItemCreateManyPropertyInput = {
  id?: string
  category: string
  item: string
  quantity?: number
  unitCost: number
  totalCost: number
  isCompleted?: boolean
  notes?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type RehabItemUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RehabItemUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RehabItemUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  category?: Prisma.StringFieldUpdateOperationsInput | string
  item?: Prisma.StringFieldUpdateOperationsInput | string
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  unitCost?: Prisma.FloatFieldUpdateOperationsInput | number
  totalCost?: Prisma.FloatFieldUpdateOperationsInput | number
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  notes?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type RehabItemSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  category?: boolean
  item?: boolean
  quantity?: boolean
  unitCost?: boolean
  totalCost?: boolean
  isCompleted?: boolean
  notes?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["rehabItem"]>

export type RehabItemSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  category?: boolean
  item?: boolean
  quantity?: boolean
  unitCost?: boolean
  totalCost?: boolean
  isCompleted?: boolean
  notes?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["rehabItem"]>

export type RehabItemSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  category?: boolean
  item?: boolean
  quantity?: boolean
  unitCost?: boolean
  totalCost?: boolean
  isCompleted?: boolean
  notes?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["rehabItem"]>

export type RehabItemSelectScalar = {
  id?: boolean
  propertyId?: boolean
  category?: boolean
  item?: boolean
  quantity?: boolean
  unitCost?: boolean
  totalCost?: boolean
  isCompleted?: boolean
  notes?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type RehabItemOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "category" | "item" | "quantity" | "unitCost" | "totalCost" | "isCompleted" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["rehabItem"]>
export type RehabItemInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type RehabItemIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type RehabItemIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $RehabItemPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "RehabItem"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    category: string
    item: string
    quantity: number
    unitCost: number
    totalCost: number
    isCompleted: boolean
    notes: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["rehabItem"]>
  composites: {}
}

export type RehabItemGetPayload<S extends boolean | null | undefined | RehabItemDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$RehabItemPayload, S>

export type RehabItemCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<RehabItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RehabItemCountAggregateInputType | true
  }

export interface RehabItemDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RehabItem'], meta: { name: 'RehabItem' } }
  /**
   * Find zero or one RehabItem that matches the filter.
   * @param {RehabItemFindUniqueArgs} args - Arguments to find a RehabItem
   * @example
   * // Get one RehabItem
   * const rehabItem = await prisma.rehabItem.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends RehabItemFindUniqueArgs>(args: Prisma.SelectSubset<T, RehabItemFindUniqueArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one RehabItem that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {RehabItemFindUniqueOrThrowArgs} args - Arguments to find a RehabItem
   * @example
   * // Get one RehabItem
   * const rehabItem = await prisma.rehabItem.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends RehabItemFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, RehabItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RehabItem that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemFindFirstArgs} args - Arguments to find a RehabItem
   * @example
   * // Get one RehabItem
   * const rehabItem = await prisma.rehabItem.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends RehabItemFindFirstArgs>(args?: Prisma.SelectSubset<T, RehabItemFindFirstArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RehabItem that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemFindFirstOrThrowArgs} args - Arguments to find a RehabItem
   * @example
   * // Get one RehabItem
   * const rehabItem = await prisma.rehabItem.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends RehabItemFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, RehabItemFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more RehabItems that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all RehabItems
   * const rehabItems = await prisma.rehabItem.findMany()
   * 
   * // Get first 10 RehabItems
   * const rehabItems = await prisma.rehabItem.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const rehabItemWithIdOnly = await prisma.rehabItem.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends RehabItemFindManyArgs>(args?: Prisma.SelectSubset<T, RehabItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a RehabItem.
   * @param {RehabItemCreateArgs} args - Arguments to create a RehabItem.
   * @example
   * // Create one RehabItem
   * const RehabItem = await prisma.rehabItem.create({
   *   data: {
   *     // ... data to create a RehabItem
   *   }
   * })
   * 
   */
  create<T extends RehabItemCreateArgs>(args: Prisma.SelectSubset<T, RehabItemCreateArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many RehabItems.
   * @param {RehabItemCreateManyArgs} args - Arguments to create many RehabItems.
   * @example
   * // Create many RehabItems
   * const rehabItem = await prisma.rehabItem.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends RehabItemCreateManyArgs>(args?: Prisma.SelectSubset<T, RehabItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many RehabItems and returns the data saved in the database.
   * @param {RehabItemCreateManyAndReturnArgs} args - Arguments to create many RehabItems.
   * @example
   * // Create many RehabItems
   * const rehabItem = await prisma.rehabItem.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many RehabItems and only return the `id`
   * const rehabItemWithIdOnly = await prisma.rehabItem.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends RehabItemCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, RehabItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a RehabItem.
   * @param {RehabItemDeleteArgs} args - Arguments to delete one RehabItem.
   * @example
   * // Delete one RehabItem
   * const RehabItem = await prisma.rehabItem.delete({
   *   where: {
   *     // ... filter to delete one RehabItem
   *   }
   * })
   * 
   */
  delete<T extends RehabItemDeleteArgs>(args: Prisma.SelectSubset<T, RehabItemDeleteArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one RehabItem.
   * @param {RehabItemUpdateArgs} args - Arguments to update one RehabItem.
   * @example
   * // Update one RehabItem
   * const rehabItem = await prisma.rehabItem.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends RehabItemUpdateArgs>(args: Prisma.SelectSubset<T, RehabItemUpdateArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more RehabItems.
   * @param {RehabItemDeleteManyArgs} args - Arguments to filter RehabItems to delete.
   * @example
   * // Delete a few RehabItems
   * const { count } = await prisma.rehabItem.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends RehabItemDeleteManyArgs>(args?: Prisma.SelectSubset<T, RehabItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RehabItems.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many RehabItems
   * const rehabItem = await prisma.rehabItem.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends RehabItemUpdateManyArgs>(args: Prisma.SelectSubset<T, RehabItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RehabItems and returns the data updated in the database.
   * @param {RehabItemUpdateManyAndReturnArgs} args - Arguments to update many RehabItems.
   * @example
   * // Update many RehabItems
   * const rehabItem = await prisma.rehabItem.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more RehabItems and only return the `id`
   * const rehabItemWithIdOnly = await prisma.rehabItem.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends RehabItemUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, RehabItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one RehabItem.
   * @param {RehabItemUpsertArgs} args - Arguments to update or create a RehabItem.
   * @example
   * // Update or create a RehabItem
   * const rehabItem = await prisma.rehabItem.upsert({
   *   create: {
   *     // ... data to create a RehabItem
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the RehabItem we want to update
   *   }
   * })
   */
  upsert<T extends RehabItemUpsertArgs>(args: Prisma.SelectSubset<T, RehabItemUpsertArgs<ExtArgs>>): Prisma.Prisma__RehabItemClient<runtime.Types.Result.GetResult<Prisma.$RehabItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of RehabItems.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemCountArgs} args - Arguments to filter RehabItems to count.
   * @example
   * // Count the number of RehabItems
   * const count = await prisma.rehabItem.count({
   *   where: {
   *     // ... the filter for the RehabItems we want to count
   *   }
   * })
  **/
  count<T extends RehabItemCountArgs>(
    args?: Prisma.Subset<T, RehabItemCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], RehabItemCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a RehabItem.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends RehabItemAggregateArgs>(args: Prisma.Subset<T, RehabItemAggregateArgs>): Prisma.PrismaPromise<GetRehabItemAggregateType<T>>

  /**
   * Group by RehabItem.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RehabItemGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends RehabItemGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: RehabItemGroupByArgs['orderBy'] }
      : { orderBy?: RehabItemGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, RehabItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRehabItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the RehabItem model
 */
readonly fields: RehabItemFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for RehabItem.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__RehabItemClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the RehabItem model
 */
export interface RehabItemFieldRefs {
  readonly id: Prisma.FieldRef<"RehabItem", 'String'>
  readonly propertyId: Prisma.FieldRef<"RehabItem", 'String'>
  readonly category: Prisma.FieldRef<"RehabItem", 'String'>
  readonly item: Prisma.FieldRef<"RehabItem", 'String'>
  readonly quantity: Prisma.FieldRef<"RehabItem", 'Int'>
  readonly unitCost: Prisma.FieldRef<"RehabItem", 'Float'>
  readonly totalCost: Prisma.FieldRef<"RehabItem", 'Float'>
  readonly isCompleted: Prisma.FieldRef<"RehabItem", 'Boolean'>
  readonly notes: Prisma.FieldRef<"RehabItem", 'String'>
  readonly createdAt: Prisma.FieldRef<"RehabItem", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"RehabItem", 'DateTime'>
}
    

// Custom InputTypes
/**
 * RehabItem findUnique
 */
export type RehabItemFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * Filter, which RehabItem to fetch.
   */
  where: Prisma.RehabItemWhereUniqueInput
}

/**
 * RehabItem findUniqueOrThrow
 */
export type RehabItemFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * Filter, which RehabItem to fetch.
   */
  where: Prisma.RehabItemWhereUniqueInput
}

/**
 * RehabItem findFirst
 */
export type RehabItemFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * Filter, which RehabItem to fetch.
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RehabItems to fetch.
   */
  orderBy?: Prisma.RehabItemOrderByWithRelationInput | Prisma.RehabItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RehabItems.
   */
  cursor?: Prisma.RehabItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RehabItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RehabItems.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RehabItems.
   */
  distinct?: Prisma.RehabItemScalarFieldEnum | Prisma.RehabItemScalarFieldEnum[]
}

/**
 * RehabItem findFirstOrThrow
 */
export type RehabItemFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * Filter, which RehabItem to fetch.
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RehabItems to fetch.
   */
  orderBy?: Prisma.RehabItemOrderByWithRelationInput | Prisma.RehabItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RehabItems.
   */
  cursor?: Prisma.RehabItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RehabItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RehabItems.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RehabItems.
   */
  distinct?: Prisma.RehabItemScalarFieldEnum | Prisma.RehabItemScalarFieldEnum[]
}

/**
 * RehabItem findMany
 */
export type RehabItemFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * Filter, which RehabItems to fetch.
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RehabItems to fetch.
   */
  orderBy?: Prisma.RehabItemOrderByWithRelationInput | Prisma.RehabItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing RehabItems.
   */
  cursor?: Prisma.RehabItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RehabItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RehabItems.
   */
  skip?: number
  distinct?: Prisma.RehabItemScalarFieldEnum | Prisma.RehabItemScalarFieldEnum[]
}

/**
 * RehabItem create
 */
export type RehabItemCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * The data needed to create a RehabItem.
   */
  data: Prisma.XOR<Prisma.RehabItemCreateInput, Prisma.RehabItemUncheckedCreateInput>
}

/**
 * RehabItem createMany
 */
export type RehabItemCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many RehabItems.
   */
  data: Prisma.RehabItemCreateManyInput | Prisma.RehabItemCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * RehabItem createManyAndReturn
 */
export type RehabItemCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * The data used to create many RehabItems.
   */
  data: Prisma.RehabItemCreateManyInput | Prisma.RehabItemCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * RehabItem update
 */
export type RehabItemUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * The data needed to update a RehabItem.
   */
  data: Prisma.XOR<Prisma.RehabItemUpdateInput, Prisma.RehabItemUncheckedUpdateInput>
  /**
   * Choose, which RehabItem to update.
   */
  where: Prisma.RehabItemWhereUniqueInput
}

/**
 * RehabItem updateMany
 */
export type RehabItemUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update RehabItems.
   */
  data: Prisma.XOR<Prisma.RehabItemUpdateManyMutationInput, Prisma.RehabItemUncheckedUpdateManyInput>
  /**
   * Filter which RehabItems to update
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * Limit how many RehabItems to update.
   */
  limit?: number
}

/**
 * RehabItem updateManyAndReturn
 */
export type RehabItemUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * The data used to update RehabItems.
   */
  data: Prisma.XOR<Prisma.RehabItemUpdateManyMutationInput, Prisma.RehabItemUncheckedUpdateManyInput>
  /**
   * Filter which RehabItems to update
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * Limit how many RehabItems to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * RehabItem upsert
 */
export type RehabItemUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * The filter to search for the RehabItem to update in case it exists.
   */
  where: Prisma.RehabItemWhereUniqueInput
  /**
   * In case the RehabItem found by the `where` argument doesn't exist, create a new RehabItem with this data.
   */
  create: Prisma.XOR<Prisma.RehabItemCreateInput, Prisma.RehabItemUncheckedCreateInput>
  /**
   * In case the RehabItem was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.RehabItemUpdateInput, Prisma.RehabItemUncheckedUpdateInput>
}

/**
 * RehabItem delete
 */
export type RehabItemDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
  /**
   * Filter which RehabItem to delete.
   */
  where: Prisma.RehabItemWhereUniqueInput
}

/**
 * RehabItem deleteMany
 */
export type RehabItemDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RehabItems to delete
   */
  where?: Prisma.RehabItemWhereInput
  /**
   * Limit how many RehabItems to delete.
   */
  limit?: number
}

/**
 * RehabItem without action
 */
export type RehabItemDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RehabItem
   */
  select?: Prisma.RehabItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RehabItem
   */
  omit?: Prisma.RehabItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RehabItemInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\RehabItem.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\RentComp.ts
TYPE: TS
SIZE: 56917 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `RentComp` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model RentComp
 * 
 */
export type RentCompModel = runtime.Types.Result.DefaultSelection<Prisma.$RentCompPayload>

export type AggregateRentComp = {
  _count: RentCompCountAggregateOutputType | null
  _avg: RentCompAvgAggregateOutputType | null
  _sum: RentCompSumAggregateOutputType | null
  _min: RentCompMinAggregateOutputType | null
  _max: RentCompMaxAggregateOutputType | null
}

export type RentCompAvgAggregateOutputType = {
  rentAmount: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  distance: number | null
}

export type RentCompSumAggregateOutputType = {
  rentAmount: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  distance: number | null
}

export type RentCompMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  address: string | null
  rentAmount: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  distance: number | null
  source: string | null
  createdAt: Date | null
}

export type RentCompMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  address: string | null
  rentAmount: number | null
  sqft: number | null
  bedrooms: number | null
  bathrooms: number | null
  distance: number | null
  source: string | null
  createdAt: Date | null
}

export type RentCompCountAggregateOutputType = {
  id: number
  propertyId: number
  address: number
  rentAmount: number
  sqft: number
  bedrooms: number
  bathrooms: number
  distance: number
  source: number
  createdAt: number
  _all: number
}


export type RentCompAvgAggregateInputType = {
  rentAmount?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  distance?: true
}

export type RentCompSumAggregateInputType = {
  rentAmount?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  distance?: true
}

export type RentCompMinAggregateInputType = {
  id?: true
  propertyId?: true
  address?: true
  rentAmount?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  distance?: true
  source?: true
  createdAt?: true
}

export type RentCompMaxAggregateInputType = {
  id?: true
  propertyId?: true
  address?: true
  rentAmount?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  distance?: true
  source?: true
  createdAt?: true
}

export type RentCompCountAggregateInputType = {
  id?: true
  propertyId?: true
  address?: true
  rentAmount?: true
  sqft?: true
  bedrooms?: true
  bathrooms?: true
  distance?: true
  source?: true
  createdAt?: true
  _all?: true
}

export type RentCompAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RentComp to aggregate.
   */
  where?: Prisma.RentCompWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RentComps to fetch.
   */
  orderBy?: Prisma.RentCompOrderByWithRelationInput | Prisma.RentCompOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.RentCompWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RentComps from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RentComps.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned RentComps
  **/
  _count?: true | RentCompCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: RentCompAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: RentCompSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: RentCompMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: RentCompMaxAggregateInputType
}

export type GetRentCompAggregateType<T extends RentCompAggregateArgs> = {
      [P in keyof T & keyof AggregateRentComp]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateRentComp[P]>
    : Prisma.GetScalarType<T[P], AggregateRentComp[P]>
}




export type RentCompGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RentCompWhereInput
  orderBy?: Prisma.RentCompOrderByWithAggregationInput | Prisma.RentCompOrderByWithAggregationInput[]
  by: Prisma.RentCompScalarFieldEnum[] | Prisma.RentCompScalarFieldEnum
  having?: Prisma.RentCompScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: RentCompCountAggregateInputType | true
  _avg?: RentCompAvgAggregateInputType
  _sum?: RentCompSumAggregateInputType
  _min?: RentCompMinAggregateInputType
  _max?: RentCompMaxAggregateInputType
}

export type RentCompGroupByOutputType = {
  id: string
  propertyId: string
  address: string
  rentAmount: number
  sqft: number
  bedrooms: number
  bathrooms: number
  distance: number
  source: string
  createdAt: Date
  _count: RentCompCountAggregateOutputType | null
  _avg: RentCompAvgAggregateOutputType | null
  _sum: RentCompSumAggregateOutputType | null
  _min: RentCompMinAggregateOutputType | null
  _max: RentCompMaxAggregateOutputType | null
}

type GetRentCompGroupByPayload<T extends RentCompGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<RentCompGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof RentCompGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], RentCompGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], RentCompGroupByOutputType[P]>
      }
    >
  >



export type RentCompWhereInput = {
  AND?: Prisma.RentCompWhereInput | Prisma.RentCompWhereInput[]
  OR?: Prisma.RentCompWhereInput[]
  NOT?: Prisma.RentCompWhereInput | Prisma.RentCompWhereInput[]
  id?: Prisma.StringFilter<"RentComp"> | string
  propertyId?: Prisma.StringFilter<"RentComp"> | string
  address?: Prisma.StringFilter<"RentComp"> | string
  rentAmount?: Prisma.IntFilter<"RentComp"> | number
  sqft?: Prisma.IntFilter<"RentComp"> | number
  bedrooms?: Prisma.IntFilter<"RentComp"> | number
  bathrooms?: Prisma.FloatFilter<"RentComp"> | number
  distance?: Prisma.FloatFilter<"RentComp"> | number
  source?: Prisma.StringFilter<"RentComp"> | string
  createdAt?: Prisma.DateTimeFilter<"RentComp"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type RentCompOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  address?: Prisma.SortOrder
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  source?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type RentCompWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.RentCompWhereInput | Prisma.RentCompWhereInput[]
  OR?: Prisma.RentCompWhereInput[]
  NOT?: Prisma.RentCompWhereInput | Prisma.RentCompWhereInput[]
  propertyId?: Prisma.StringFilter<"RentComp"> | string
  address?: Prisma.StringFilter<"RentComp"> | string
  rentAmount?: Prisma.IntFilter<"RentComp"> | number
  sqft?: Prisma.IntFilter<"RentComp"> | number
  bedrooms?: Prisma.IntFilter<"RentComp"> | number
  bathrooms?: Prisma.FloatFilter<"RentComp"> | number
  distance?: Prisma.FloatFilter<"RentComp"> | number
  source?: Prisma.StringFilter<"RentComp"> | string
  createdAt?: Prisma.DateTimeFilter<"RentComp"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type RentCompOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  address?: Prisma.SortOrder
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  source?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.RentCompCountOrderByAggregateInput
  _avg?: Prisma.RentCompAvgOrderByAggregateInput
  _max?: Prisma.RentCompMaxOrderByAggregateInput
  _min?: Prisma.RentCompMinOrderByAggregateInput
  _sum?: Prisma.RentCompSumOrderByAggregateInput
}

export type RentCompScalarWhereWithAggregatesInput = {
  AND?: Prisma.RentCompScalarWhereWithAggregatesInput | Prisma.RentCompScalarWhereWithAggregatesInput[]
  OR?: Prisma.RentCompScalarWhereWithAggregatesInput[]
  NOT?: Prisma.RentCompScalarWhereWithAggregatesInput | Prisma.RentCompScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"RentComp"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"RentComp"> | string
  address?: Prisma.StringWithAggregatesFilter<"RentComp"> | string
  rentAmount?: Prisma.IntWithAggregatesFilter<"RentComp"> | number
  sqft?: Prisma.IntWithAggregatesFilter<"RentComp"> | number
  bedrooms?: Prisma.IntWithAggregatesFilter<"RentComp"> | number
  bathrooms?: Prisma.FloatWithAggregatesFilter<"RentComp"> | number
  distance?: Prisma.FloatWithAggregatesFilter<"RentComp"> | number
  source?: Prisma.StringWithAggregatesFilter<"RentComp"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"RentComp"> | Date | string
}

export type RentCompCreateInput = {
  id?: string
  address: string
  rentAmount: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  distance: number
  source?: string
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutRentCompsInput
}

export type RentCompUncheckedCreateInput = {
  id?: string
  propertyId: string
  address: string
  rentAmount: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  distance: number
  source?: string
  createdAt?: Date | string
}

export type RentCompUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutRentCompsNestedInput
}

export type RentCompUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RentCompCreateManyInput = {
  id?: string
  propertyId: string
  address: string
  rentAmount: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  distance: number
  source?: string
  createdAt?: Date | string
}

export type RentCompUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RentCompUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RentCompListRelationFilter = {
  every?: Prisma.RentCompWhereInput
  some?: Prisma.RentCompWhereInput
  none?: Prisma.RentCompWhereInput
}

export type RentCompOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type RentCompCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  address?: Prisma.SortOrder
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  source?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type RentCompAvgOrderByAggregateInput = {
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
}

export type RentCompMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  address?: Prisma.SortOrder
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  source?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type RentCompMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  address?: Prisma.SortOrder
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  source?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type RentCompSumOrderByAggregateInput = {
  rentAmount?: Prisma.SortOrder
  sqft?: Prisma.SortOrder
  bedrooms?: Prisma.SortOrder
  bathrooms?: Prisma.SortOrder
  distance?: Prisma.SortOrder
}

export type RentCompCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.RentCompCreateWithoutPropertyInput, Prisma.RentCompUncheckedCreateWithoutPropertyInput> | Prisma.RentCompCreateWithoutPropertyInput[] | Prisma.RentCompUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RentCompCreateOrConnectWithoutPropertyInput | Prisma.RentCompCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.RentCompCreateManyPropertyInputEnvelope
  connect?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
}

export type RentCompUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.RentCompCreateWithoutPropertyInput, Prisma.RentCompUncheckedCreateWithoutPropertyInput> | Prisma.RentCompCreateWithoutPropertyInput[] | Prisma.RentCompUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RentCompCreateOrConnectWithoutPropertyInput | Prisma.RentCompCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.RentCompCreateManyPropertyInputEnvelope
  connect?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
}

export type RentCompUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.RentCompCreateWithoutPropertyInput, Prisma.RentCompUncheckedCreateWithoutPropertyInput> | Prisma.RentCompCreateWithoutPropertyInput[] | Prisma.RentCompUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RentCompCreateOrConnectWithoutPropertyInput | Prisma.RentCompCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.RentCompUpsertWithWhereUniqueWithoutPropertyInput | Prisma.RentCompUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.RentCompCreateManyPropertyInputEnvelope
  set?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  disconnect?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  delete?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  connect?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  update?: Prisma.RentCompUpdateWithWhereUniqueWithoutPropertyInput | Prisma.RentCompUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.RentCompUpdateManyWithWhereWithoutPropertyInput | Prisma.RentCompUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.RentCompScalarWhereInput | Prisma.RentCompScalarWhereInput[]
}

export type RentCompUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.RentCompCreateWithoutPropertyInput, Prisma.RentCompUncheckedCreateWithoutPropertyInput> | Prisma.RentCompCreateWithoutPropertyInput[] | Prisma.RentCompUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.RentCompCreateOrConnectWithoutPropertyInput | Prisma.RentCompCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.RentCompUpsertWithWhereUniqueWithoutPropertyInput | Prisma.RentCompUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.RentCompCreateManyPropertyInputEnvelope
  set?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  disconnect?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  delete?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  connect?: Prisma.RentCompWhereUniqueInput | Prisma.RentCompWhereUniqueInput[]
  update?: Prisma.RentCompUpdateWithWhereUniqueWithoutPropertyInput | Prisma.RentCompUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.RentCompUpdateManyWithWhereWithoutPropertyInput | Prisma.RentCompUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.RentCompScalarWhereInput | Prisma.RentCompScalarWhereInput[]
}

export type RentCompCreateWithoutPropertyInput = {
  id?: string
  address: string
  rentAmount: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  distance: number
  source?: string
  createdAt?: Date | string
}

export type RentCompUncheckedCreateWithoutPropertyInput = {
  id?: string
  address: string
  rentAmount: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  distance: number
  source?: string
  createdAt?: Date | string
}

export type RentCompCreateOrConnectWithoutPropertyInput = {
  where: Prisma.RentCompWhereUniqueInput
  create: Prisma.XOR<Prisma.RentCompCreateWithoutPropertyInput, Prisma.RentCompUncheckedCreateWithoutPropertyInput>
}

export type RentCompCreateManyPropertyInputEnvelope = {
  data: Prisma.RentCompCreateManyPropertyInput | Prisma.RentCompCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type RentCompUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.RentCompWhereUniqueInput
  update: Prisma.XOR<Prisma.RentCompUpdateWithoutPropertyInput, Prisma.RentCompUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.RentCompCreateWithoutPropertyInput, Prisma.RentCompUncheckedCreateWithoutPropertyInput>
}

export type RentCompUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.RentCompWhereUniqueInput
  data: Prisma.XOR<Prisma.RentCompUpdateWithoutPropertyInput, Prisma.RentCompUncheckedUpdateWithoutPropertyInput>
}

export type RentCompUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.RentCompScalarWhereInput
  data: Prisma.XOR<Prisma.RentCompUpdateManyMutationInput, Prisma.RentCompUncheckedUpdateManyWithoutPropertyInput>
}

export type RentCompScalarWhereInput = {
  AND?: Prisma.RentCompScalarWhereInput | Prisma.RentCompScalarWhereInput[]
  OR?: Prisma.RentCompScalarWhereInput[]
  NOT?: Prisma.RentCompScalarWhereInput | Prisma.RentCompScalarWhereInput[]
  id?: Prisma.StringFilter<"RentComp"> | string
  propertyId?: Prisma.StringFilter<"RentComp"> | string
  address?: Prisma.StringFilter<"RentComp"> | string
  rentAmount?: Prisma.IntFilter<"RentComp"> | number
  sqft?: Prisma.IntFilter<"RentComp"> | number
  bedrooms?: Prisma.IntFilter<"RentComp"> | number
  bathrooms?: Prisma.FloatFilter<"RentComp"> | number
  distance?: Prisma.FloatFilter<"RentComp"> | number
  source?: Prisma.StringFilter<"RentComp"> | string
  createdAt?: Prisma.DateTimeFilter<"RentComp"> | Date | string
}

export type RentCompCreateManyPropertyInput = {
  id?: string
  address: string
  rentAmount: number
  sqft?: number
  bedrooms?: number
  bathrooms?: number
  distance: number
  source?: string
  createdAt?: Date | string
}

export type RentCompUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RentCompUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RentCompUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  address?: Prisma.StringFieldUpdateOperationsInput | string
  rentAmount?: Prisma.IntFieldUpdateOperationsInput | number
  sqft?: Prisma.IntFieldUpdateOperationsInput | number
  bedrooms?: Prisma.IntFieldUpdateOperationsInput | number
  bathrooms?: Prisma.FloatFieldUpdateOperationsInput | number
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  source?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type RentCompSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  address?: boolean
  rentAmount?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  distance?: boolean
  source?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["rentComp"]>

export type RentCompSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  address?: boolean
  rentAmount?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  distance?: boolean
  source?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["rentComp"]>

export type RentCompSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  address?: boolean
  rentAmount?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  distance?: boolean
  source?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["rentComp"]>

export type RentCompSelectScalar = {
  id?: boolean
  propertyId?: boolean
  address?: boolean
  rentAmount?: boolean
  sqft?: boolean
  bedrooms?: boolean
  bathrooms?: boolean
  distance?: boolean
  source?: boolean
  createdAt?: boolean
}

export type RentCompOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "address" | "rentAmount" | "sqft" | "bedrooms" | "bathrooms" | "distance" | "source" | "createdAt", ExtArgs["result"]["rentComp"]>
export type RentCompInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type RentCompIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type RentCompIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $RentCompPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "RentComp"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    address: string
    rentAmount: number
    sqft: number
    bedrooms: number
    bathrooms: number
    distance: number
    source: string
    createdAt: Date
  }, ExtArgs["result"]["rentComp"]>
  composites: {}
}

export type RentCompGetPayload<S extends boolean | null | undefined | RentCompDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$RentCompPayload, S>

export type RentCompCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<RentCompFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RentCompCountAggregateInputType | true
  }

export interface RentCompDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentComp'], meta: { name: 'RentComp' } }
  /**
   * Find zero or one RentComp that matches the filter.
   * @param {RentCompFindUniqueArgs} args - Arguments to find a RentComp
   * @example
   * // Get one RentComp
   * const rentComp = await prisma.rentComp.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends RentCompFindUniqueArgs>(args: Prisma.SelectSubset<T, RentCompFindUniqueArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one RentComp that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {RentCompFindUniqueOrThrowArgs} args - Arguments to find a RentComp
   * @example
   * // Get one RentComp
   * const rentComp = await prisma.rentComp.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends RentCompFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, RentCompFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RentComp that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompFindFirstArgs} args - Arguments to find a RentComp
   * @example
   * // Get one RentComp
   * const rentComp = await prisma.rentComp.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends RentCompFindFirstArgs>(args?: Prisma.SelectSubset<T, RentCompFindFirstArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RentComp that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompFindFirstOrThrowArgs} args - Arguments to find a RentComp
   * @example
   * // Get one RentComp
   * const rentComp = await prisma.rentComp.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends RentCompFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, RentCompFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more RentComps that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all RentComps
   * const rentComps = await prisma.rentComp.findMany()
   * 
   * // Get first 10 RentComps
   * const rentComps = await prisma.rentComp.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const rentCompWithIdOnly = await prisma.rentComp.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends RentCompFindManyArgs>(args?: Prisma.SelectSubset<T, RentCompFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a RentComp.
   * @param {RentCompCreateArgs} args - Arguments to create a RentComp.
   * @example
   * // Create one RentComp
   * const RentComp = await prisma.rentComp.create({
   *   data: {
   *     // ... data to create a RentComp
   *   }
   * })
   * 
   */
  create<T extends RentCompCreateArgs>(args: Prisma.SelectSubset<T, RentCompCreateArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many RentComps.
   * @param {RentCompCreateManyArgs} args - Arguments to create many RentComps.
   * @example
   * // Create many RentComps
   * const rentComp = await prisma.rentComp.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends RentCompCreateManyArgs>(args?: Prisma.SelectSubset<T, RentCompCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many RentComps and returns the data saved in the database.
   * @param {RentCompCreateManyAndReturnArgs} args - Arguments to create many RentComps.
   * @example
   * // Create many RentComps
   * const rentComp = await prisma.rentComp.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many RentComps and only return the `id`
   * const rentCompWithIdOnly = await prisma.rentComp.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends RentCompCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, RentCompCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a RentComp.
   * @param {RentCompDeleteArgs} args - Arguments to delete one RentComp.
   * @example
   * // Delete one RentComp
   * const RentComp = await prisma.rentComp.delete({
   *   where: {
   *     // ... filter to delete one RentComp
   *   }
   * })
   * 
   */
  delete<T extends RentCompDeleteArgs>(args: Prisma.SelectSubset<T, RentCompDeleteArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one RentComp.
   * @param {RentCompUpdateArgs} args - Arguments to update one RentComp.
   * @example
   * // Update one RentComp
   * const rentComp = await prisma.rentComp.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends RentCompUpdateArgs>(args: Prisma.SelectSubset<T, RentCompUpdateArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more RentComps.
   * @param {RentCompDeleteManyArgs} args - Arguments to filter RentComps to delete.
   * @example
   * // Delete a few RentComps
   * const { count } = await prisma.rentComp.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends RentCompDeleteManyArgs>(args?: Prisma.SelectSubset<T, RentCompDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RentComps.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many RentComps
   * const rentComp = await prisma.rentComp.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends RentCompUpdateManyArgs>(args: Prisma.SelectSubset<T, RentCompUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RentComps and returns the data updated in the database.
   * @param {RentCompUpdateManyAndReturnArgs} args - Arguments to update many RentComps.
   * @example
   * // Update many RentComps
   * const rentComp = await prisma.rentComp.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more RentComps and only return the `id`
   * const rentCompWithIdOnly = await prisma.rentComp.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends RentCompUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, RentCompUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one RentComp.
   * @param {RentCompUpsertArgs} args - Arguments to update or create a RentComp.
   * @example
   * // Update or create a RentComp
   * const rentComp = await prisma.rentComp.upsert({
   *   create: {
   *     // ... data to create a RentComp
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the RentComp we want to update
   *   }
   * })
   */
  upsert<T extends RentCompUpsertArgs>(args: Prisma.SelectSubset<T, RentCompUpsertArgs<ExtArgs>>): Prisma.Prisma__RentCompClient<runtime.Types.Result.GetResult<Prisma.$RentCompPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of RentComps.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompCountArgs} args - Arguments to filter RentComps to count.
   * @example
   * // Count the number of RentComps
   * const count = await prisma.rentComp.count({
   *   where: {
   *     // ... the filter for the RentComps we want to count
   *   }
   * })
  **/
  count<T extends RentCompCountArgs>(
    args?: Prisma.Subset<T, RentCompCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], RentCompCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a RentComp.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends RentCompAggregateArgs>(args: Prisma.Subset<T, RentCompAggregateArgs>): Prisma.PrismaPromise<GetRentCompAggregateType<T>>

  /**
   * Group by RentComp.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RentCompGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends RentCompGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: RentCompGroupByArgs['orderBy'] }
      : { orderBy?: RentCompGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, RentCompGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentCompGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the RentComp model
 */
readonly fields: RentCompFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for RentComp.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__RentCompClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the RentComp model
 */
export interface RentCompFieldRefs {
  readonly id: Prisma.FieldRef<"RentComp", 'String'>
  readonly propertyId: Prisma.FieldRef<"RentComp", 'String'>
  readonly address: Prisma.FieldRef<"RentComp", 'String'>
  readonly rentAmount: Prisma.FieldRef<"RentComp", 'Int'>
  readonly sqft: Prisma.FieldRef<"RentComp", 'Int'>
  readonly bedrooms: Prisma.FieldRef<"RentComp", 'Int'>
  readonly bathrooms: Prisma.FieldRef<"RentComp", 'Float'>
  readonly distance: Prisma.FieldRef<"RentComp", 'Float'>
  readonly source: Prisma.FieldRef<"RentComp", 'String'>
  readonly createdAt: Prisma.FieldRef<"RentComp", 'DateTime'>
}
    

// Custom InputTypes
/**
 * RentComp findUnique
 */
export type RentCompFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * Filter, which RentComp to fetch.
   */
  where: Prisma.RentCompWhereUniqueInput
}

/**
 * RentComp findUniqueOrThrow
 */
export type RentCompFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * Filter, which RentComp to fetch.
   */
  where: Prisma.RentCompWhereUniqueInput
}

/**
 * RentComp findFirst
 */
export type RentCompFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * Filter, which RentComp to fetch.
   */
  where?: Prisma.RentCompWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RentComps to fetch.
   */
  orderBy?: Prisma.RentCompOrderByWithRelationInput | Prisma.RentCompOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RentComps.
   */
  cursor?: Prisma.RentCompWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RentComps from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RentComps.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RentComps.
   */
  distinct?: Prisma.RentCompScalarFieldEnum | Prisma.RentCompScalarFieldEnum[]
}

/**
 * RentComp findFirstOrThrow
 */
export type RentCompFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * Filter, which RentComp to fetch.
   */
  where?: Prisma.RentCompWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RentComps to fetch.
   */
  orderBy?: Prisma.RentCompOrderByWithRelationInput | Prisma.RentCompOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RentComps.
   */
  cursor?: Prisma.RentCompWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RentComps from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RentComps.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RentComps.
   */
  distinct?: Prisma.RentCompScalarFieldEnum | Prisma.RentCompScalarFieldEnum[]
}

/**
 * RentComp findMany
 */
export type RentCompFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * Filter, which RentComps to fetch.
   */
  where?: Prisma.RentCompWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RentComps to fetch.
   */
  orderBy?: Prisma.RentCompOrderByWithRelationInput | Prisma.RentCompOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing RentComps.
   */
  cursor?: Prisma.RentCompWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` RentComps from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RentComps.
   */
  skip?: number
  distinct?: Prisma.RentCompScalarFieldEnum | Prisma.RentCompScalarFieldEnum[]
}

/**
 * RentComp create
 */
export type RentCompCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * The data needed to create a RentComp.
   */
  data: Prisma.XOR<Prisma.RentCompCreateInput, Prisma.RentCompUncheckedCreateInput>
}

/**
 * RentComp createMany
 */
export type RentCompCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many RentComps.
   */
  data: Prisma.RentCompCreateManyInput | Prisma.RentCompCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * RentComp createManyAndReturn
 */
export type RentCompCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * The data used to create many RentComps.
   */
  data: Prisma.RentCompCreateManyInput | Prisma.RentCompCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * RentComp update
 */
export type RentCompUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * The data needed to update a RentComp.
   */
  data: Prisma.XOR<Prisma.RentCompUpdateInput, Prisma.RentCompUncheckedUpdateInput>
  /**
   * Choose, which RentComp to update.
   */
  where: Prisma.RentCompWhereUniqueInput
}

/**
 * RentComp updateMany
 */
export type RentCompUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update RentComps.
   */
  data: Prisma.XOR<Prisma.RentCompUpdateManyMutationInput, Prisma.RentCompUncheckedUpdateManyInput>
  /**
   * Filter which RentComps to update
   */
  where?: Prisma.RentCompWhereInput
  /**
   * Limit how many RentComps to update.
   */
  limit?: number
}

/**
 * RentComp updateManyAndReturn
 */
export type RentCompUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * The data used to update RentComps.
   */
  data: Prisma.XOR<Prisma.RentCompUpdateManyMutationInput, Prisma.RentCompUncheckedUpdateManyInput>
  /**
   * Filter which RentComps to update
   */
  where?: Prisma.RentCompWhereInput
  /**
   * Limit how many RentComps to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * RentComp upsert
 */
export type RentCompUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * The filter to search for the RentComp to update in case it exists.
   */
  where: Prisma.RentCompWhereUniqueInput
  /**
   * In case the RentComp found by the `where` argument doesn't exist, create a new RentComp with this data.
   */
  create: Prisma.XOR<Prisma.RentCompCreateInput, Prisma.RentCompUncheckedCreateInput>
  /**
   * In case the RentComp was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.RentCompUpdateInput, Prisma.RentCompUncheckedUpdateInput>
}

/**
 * RentComp delete
 */
export type RentCompDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
  /**
   * Filter which RentComp to delete.
   */
  where: Prisma.RentCompWhereUniqueInput
}

/**
 * RentComp deleteMany
 */
export type RentCompDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RentComps to delete
   */
  where?: Prisma.RentCompWhereInput
  /**
   * Limit how many RentComps to delete.
   */
  limit?: number
}

/**
 * RentComp without action
 */
export type RentCompDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RentComp
   */
  select?: Prisma.RentCompSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RentComp
   */
  omit?: Prisma.RentCompOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RentCompInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\RentComp.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\Task.ts
TYPE: TS
SIZE: 46824 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Task` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Task
 * 
 */
export type TaskModel = runtime.Types.Result.DefaultSelection<Prisma.$TaskPayload>

export type AggregateTask = {
  _count: TaskCountAggregateOutputType | null
  _min: TaskMinAggregateOutputType | null
  _max: TaskMaxAggregateOutputType | null
}

export type TaskMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  title: string | null
  isCompleted: boolean | null
  createdAt: Date | null
}

export type TaskMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  title: string | null
  isCompleted: boolean | null
  createdAt: Date | null
}

export type TaskCountAggregateOutputType = {
  id: number
  propertyId: number
  title: number
  isCompleted: number
  createdAt: number
  _all: number
}


export type TaskMinAggregateInputType = {
  id?: true
  propertyId?: true
  title?: true
  isCompleted?: true
  createdAt?: true
}

export type TaskMaxAggregateInputType = {
  id?: true
  propertyId?: true
  title?: true
  isCompleted?: true
  createdAt?: true
}

export type TaskCountAggregateInputType = {
  id?: true
  propertyId?: true
  title?: true
  isCompleted?: true
  createdAt?: true
  _all?: true
}

export type TaskAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Task to aggregate.
   */
  where?: Prisma.TaskWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Tasks to fetch.
   */
  orderBy?: Prisma.TaskOrderByWithRelationInput | Prisma.TaskOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.TaskWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Tasks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Tasks.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Tasks
  **/
  _count?: true | TaskCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: TaskMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: TaskMaxAggregateInputType
}

export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
      [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateTask[P]>
    : Prisma.GetScalarType<T[P], AggregateTask[P]>
}




export type TaskGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TaskWhereInput
  orderBy?: Prisma.TaskOrderByWithAggregationInput | Prisma.TaskOrderByWithAggregationInput[]
  by: Prisma.TaskScalarFieldEnum[] | Prisma.TaskScalarFieldEnum
  having?: Prisma.TaskScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: TaskCountAggregateInputType | true
  _min?: TaskMinAggregateInputType
  _max?: TaskMaxAggregateInputType
}

export type TaskGroupByOutputType = {
  id: string
  propertyId: string
  title: string
  isCompleted: boolean
  createdAt: Date
  _count: TaskCountAggregateOutputType | null
  _min: TaskMinAggregateOutputType | null
  _max: TaskMaxAggregateOutputType | null
}

type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<TaskGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], TaskGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], TaskGroupByOutputType[P]>
      }
    >
  >



export type TaskWhereInput = {
  AND?: Prisma.TaskWhereInput | Prisma.TaskWhereInput[]
  OR?: Prisma.TaskWhereInput[]
  NOT?: Prisma.TaskWhereInput | Prisma.TaskWhereInput[]
  id?: Prisma.StringFilter<"Task"> | string
  propertyId?: Prisma.StringFilter<"Task"> | string
  title?: Prisma.StringFilter<"Task"> | string
  isCompleted?: Prisma.BoolFilter<"Task"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Task"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type TaskOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type TaskWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.TaskWhereInput | Prisma.TaskWhereInput[]
  OR?: Prisma.TaskWhereInput[]
  NOT?: Prisma.TaskWhereInput | Prisma.TaskWhereInput[]
  propertyId?: Prisma.StringFilter<"Task"> | string
  title?: Prisma.StringFilter<"Task"> | string
  isCompleted?: Prisma.BoolFilter<"Task"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Task"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type TaskOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.TaskCountOrderByAggregateInput
  _max?: Prisma.TaskMaxOrderByAggregateInput
  _min?: Prisma.TaskMinOrderByAggregateInput
}

export type TaskScalarWhereWithAggregatesInput = {
  AND?: Prisma.TaskScalarWhereWithAggregatesInput | Prisma.TaskScalarWhereWithAggregatesInput[]
  OR?: Prisma.TaskScalarWhereWithAggregatesInput[]
  NOT?: Prisma.TaskScalarWhereWithAggregatesInput | Prisma.TaskScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Task"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"Task"> | string
  title?: Prisma.StringWithAggregatesFilter<"Task"> | string
  isCompleted?: Prisma.BoolWithAggregatesFilter<"Task"> | boolean
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Task"> | Date | string
}

export type TaskCreateInput = {
  id?: string
  title: string
  isCompleted?: boolean
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutTasksInput
}

export type TaskUncheckedCreateInput = {
  id?: string
  propertyId: string
  title: string
  isCompleted?: boolean
  createdAt?: Date | string
}

export type TaskUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutTasksNestedInput
}

export type TaskUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TaskCreateManyInput = {
  id?: string
  propertyId: string
  title: string
  isCompleted?: boolean
  createdAt?: Date | string
}

export type TaskUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TaskUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TaskListRelationFilter = {
  every?: Prisma.TaskWhereInput
  some?: Prisma.TaskWhereInput
  none?: Prisma.TaskWhereInput
}

export type TaskOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type TaskCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type TaskMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type TaskMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type TaskCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.TaskCreateWithoutPropertyInput, Prisma.TaskUncheckedCreateWithoutPropertyInput> | Prisma.TaskCreateWithoutPropertyInput[] | Prisma.TaskUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TaskCreateOrConnectWithoutPropertyInput | Prisma.TaskCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.TaskCreateManyPropertyInputEnvelope
  connect?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
}

export type TaskUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.TaskCreateWithoutPropertyInput, Prisma.TaskUncheckedCreateWithoutPropertyInput> | Prisma.TaskCreateWithoutPropertyInput[] | Prisma.TaskUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TaskCreateOrConnectWithoutPropertyInput | Prisma.TaskCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.TaskCreateManyPropertyInputEnvelope
  connect?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
}

export type TaskUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.TaskCreateWithoutPropertyInput, Prisma.TaskUncheckedCreateWithoutPropertyInput> | Prisma.TaskCreateWithoutPropertyInput[] | Prisma.TaskUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TaskCreateOrConnectWithoutPropertyInput | Prisma.TaskCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.TaskUpsertWithWhereUniqueWithoutPropertyInput | Prisma.TaskUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.TaskCreateManyPropertyInputEnvelope
  set?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  disconnect?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  delete?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  connect?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  update?: Prisma.TaskUpdateWithWhereUniqueWithoutPropertyInput | Prisma.TaskUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.TaskUpdateManyWithWhereWithoutPropertyInput | Prisma.TaskUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.TaskScalarWhereInput | Prisma.TaskScalarWhereInput[]
}

export type TaskUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.TaskCreateWithoutPropertyInput, Prisma.TaskUncheckedCreateWithoutPropertyInput> | Prisma.TaskCreateWithoutPropertyInput[] | Prisma.TaskUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TaskCreateOrConnectWithoutPropertyInput | Prisma.TaskCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.TaskUpsertWithWhereUniqueWithoutPropertyInput | Prisma.TaskUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.TaskCreateManyPropertyInputEnvelope
  set?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  disconnect?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  delete?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  connect?: Prisma.TaskWhereUniqueInput | Prisma.TaskWhereUniqueInput[]
  update?: Prisma.TaskUpdateWithWhereUniqueWithoutPropertyInput | Prisma.TaskUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.TaskUpdateManyWithWhereWithoutPropertyInput | Prisma.TaskUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.TaskScalarWhereInput | Prisma.TaskScalarWhereInput[]
}

export type TaskCreateWithoutPropertyInput = {
  id?: string
  title: string
  isCompleted?: boolean
  createdAt?: Date | string
}

export type TaskUncheckedCreateWithoutPropertyInput = {
  id?: string
  title: string
  isCompleted?: boolean
  createdAt?: Date | string
}

export type TaskCreateOrConnectWithoutPropertyInput = {
  where: Prisma.TaskWhereUniqueInput
  create: Prisma.XOR<Prisma.TaskCreateWithoutPropertyInput, Prisma.TaskUncheckedCreateWithoutPropertyInput>
}

export type TaskCreateManyPropertyInputEnvelope = {
  data: Prisma.TaskCreateManyPropertyInput | Prisma.TaskCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type TaskUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.TaskWhereUniqueInput
  update: Prisma.XOR<Prisma.TaskUpdateWithoutPropertyInput, Prisma.TaskUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.TaskCreateWithoutPropertyInput, Prisma.TaskUncheckedCreateWithoutPropertyInput>
}

export type TaskUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.TaskWhereUniqueInput
  data: Prisma.XOR<Prisma.TaskUpdateWithoutPropertyInput, Prisma.TaskUncheckedUpdateWithoutPropertyInput>
}

export type TaskUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.TaskScalarWhereInput
  data: Prisma.XOR<Prisma.TaskUpdateManyMutationInput, Prisma.TaskUncheckedUpdateManyWithoutPropertyInput>
}

export type TaskScalarWhereInput = {
  AND?: Prisma.TaskScalarWhereInput | Prisma.TaskScalarWhereInput[]
  OR?: Prisma.TaskScalarWhereInput[]
  NOT?: Prisma.TaskScalarWhereInput | Prisma.TaskScalarWhereInput[]
  id?: Prisma.StringFilter<"Task"> | string
  propertyId?: Prisma.StringFilter<"Task"> | string
  title?: Prisma.StringFilter<"Task"> | string
  isCompleted?: Prisma.BoolFilter<"Task"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Task"> | Date | string
}

export type TaskCreateManyPropertyInput = {
  id?: string
  title: string
  isCompleted?: boolean
  createdAt?: Date | string
}

export type TaskUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TaskUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TaskUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type TaskSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  title?: boolean
  isCompleted?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["task"]>

export type TaskSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  title?: boolean
  isCompleted?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["task"]>

export type TaskSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  title?: boolean
  isCompleted?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["task"]>

export type TaskSelectScalar = {
  id?: boolean
  propertyId?: boolean
  title?: boolean
  isCompleted?: boolean
  createdAt?: boolean
}

export type TaskOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "title" | "isCompleted" | "createdAt", ExtArgs["result"]["task"]>
export type TaskInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type TaskIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type TaskIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $TaskPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Task"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    title: string
    isCompleted: boolean
    createdAt: Date
  }, ExtArgs["result"]["task"]>
  composites: {}
}

export type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$TaskPayload, S>

export type TaskCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TaskCountAggregateInputType | true
  }

export interface TaskDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
  /**
   * Find zero or one Task that matches the filter.
   * @param {TaskFindUniqueArgs} args - Arguments to find a Task
   * @example
   * // Get one Task
   * const task = await prisma.task.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends TaskFindUniqueArgs>(args: Prisma.SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Task that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
   * @example
   * // Get one Task
   * const task = await prisma.task.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Task that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskFindFirstArgs} args - Arguments to find a Task
   * @example
   * // Get one Task
   * const task = await prisma.task.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends TaskFindFirstArgs>(args?: Prisma.SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Task that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
   * @example
   * // Get one Task
   * const task = await prisma.task.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Tasks that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Tasks
   * const tasks = await prisma.task.findMany()
   * 
   * // Get first 10 Tasks
   * const tasks = await prisma.task.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends TaskFindManyArgs>(args?: Prisma.SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Task.
   * @param {TaskCreateArgs} args - Arguments to create a Task.
   * @example
   * // Create one Task
   * const Task = await prisma.task.create({
   *   data: {
   *     // ... data to create a Task
   *   }
   * })
   * 
   */
  create<T extends TaskCreateArgs>(args: Prisma.SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Tasks.
   * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
   * @example
   * // Create many Tasks
   * const task = await prisma.task.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends TaskCreateManyArgs>(args?: Prisma.SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Tasks and returns the data saved in the database.
   * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
   * @example
   * // Create many Tasks
   * const task = await prisma.task.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Tasks and only return the `id`
   * const taskWithIdOnly = await prisma.task.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Task.
   * @param {TaskDeleteArgs} args - Arguments to delete one Task.
   * @example
   * // Delete one Task
   * const Task = await prisma.task.delete({
   *   where: {
   *     // ... filter to delete one Task
   *   }
   * })
   * 
   */
  delete<T extends TaskDeleteArgs>(args: Prisma.SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Task.
   * @param {TaskUpdateArgs} args - Arguments to update one Task.
   * @example
   * // Update one Task
   * const task = await prisma.task.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends TaskUpdateArgs>(args: Prisma.SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Tasks.
   * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
   * @example
   * // Delete a few Tasks
   * const { count } = await prisma.task.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends TaskDeleteManyArgs>(args?: Prisma.SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Tasks.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Tasks
   * const task = await prisma.task.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends TaskUpdateManyArgs>(args: Prisma.SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Tasks and returns the data updated in the database.
   * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
   * @example
   * // Update many Tasks
   * const task = await prisma.task.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Tasks and only return the `id`
   * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Task.
   * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
   * @example
   * // Update or create a Task
   * const task = await prisma.task.upsert({
   *   create: {
   *     // ... data to create a Task
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Task we want to update
   *   }
   * })
   */
  upsert<T extends TaskUpsertArgs>(args: Prisma.SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma.Prisma__TaskClient<runtime.Types.Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Tasks.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
   * @example
   * // Count the number of Tasks
   * const count = await prisma.task.count({
   *   where: {
   *     // ... the filter for the Tasks we want to count
   *   }
   * })
  **/
  count<T extends TaskCountArgs>(
    args?: Prisma.Subset<T, TaskCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], TaskCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Task.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends TaskAggregateArgs>(args: Prisma.Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

  /**
   * Group by Task.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TaskGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends TaskGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: TaskGroupByArgs['orderBy'] }
      : { orderBy?: TaskGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Task model
 */
readonly fields: TaskFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Task.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TaskClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Task model
 */
export interface TaskFieldRefs {
  readonly id: Prisma.FieldRef<"Task", 'String'>
  readonly propertyId: Prisma.FieldRef<"Task", 'String'>
  readonly title: Prisma.FieldRef<"Task", 'String'>
  readonly isCompleted: Prisma.FieldRef<"Task", 'Boolean'>
  readonly createdAt: Prisma.FieldRef<"Task", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Task findUnique
 */
export type TaskFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * Filter, which Task to fetch.
   */
  where: Prisma.TaskWhereUniqueInput
}

/**
 * Task findUniqueOrThrow
 */
export type TaskFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * Filter, which Task to fetch.
   */
  where: Prisma.TaskWhereUniqueInput
}

/**
 * Task findFirst
 */
export type TaskFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * Filter, which Task to fetch.
   */
  where?: Prisma.TaskWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Tasks to fetch.
   */
  orderBy?: Prisma.TaskOrderByWithRelationInput | Prisma.TaskOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Tasks.
   */
  cursor?: Prisma.TaskWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Tasks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Tasks.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Tasks.
   */
  distinct?: Prisma.TaskScalarFieldEnum | Prisma.TaskScalarFieldEnum[]
}

/**
 * Task findFirstOrThrow
 */
export type TaskFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * Filter, which Task to fetch.
   */
  where?: Prisma.TaskWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Tasks to fetch.
   */
  orderBy?: Prisma.TaskOrderByWithRelationInput | Prisma.TaskOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Tasks.
   */
  cursor?: Prisma.TaskWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Tasks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Tasks.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Tasks.
   */
  distinct?: Prisma.TaskScalarFieldEnum | Prisma.TaskScalarFieldEnum[]
}

/**
 * Task findMany
 */
export type TaskFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * Filter, which Tasks to fetch.
   */
  where?: Prisma.TaskWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Tasks to fetch.
   */
  orderBy?: Prisma.TaskOrderByWithRelationInput | Prisma.TaskOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Tasks.
   */
  cursor?: Prisma.TaskWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` Tasks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Tasks.
   */
  skip?: number
  distinct?: Prisma.TaskScalarFieldEnum | Prisma.TaskScalarFieldEnum[]
}

/**
 * Task create
 */
export type TaskCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * The data needed to create a Task.
   */
  data: Prisma.XOR<Prisma.TaskCreateInput, Prisma.TaskUncheckedCreateInput>
}

/**
 * Task createMany
 */
export type TaskCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Tasks.
   */
  data: Prisma.TaskCreateManyInput | Prisma.TaskCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Task createManyAndReturn
 */
export type TaskCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * The data used to create many Tasks.
   */
  data: Prisma.TaskCreateManyInput | Prisma.TaskCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Task update
 */
export type TaskUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * The data needed to update a Task.
   */
  data: Prisma.XOR<Prisma.TaskUpdateInput, Prisma.TaskUncheckedUpdateInput>
  /**
   * Choose, which Task to update.
   */
  where: Prisma.TaskWhereUniqueInput
}

/**
 * Task updateMany
 */
export type TaskUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Tasks.
   */
  data: Prisma.XOR<Prisma.TaskUpdateManyMutationInput, Prisma.TaskUncheckedUpdateManyInput>
  /**
   * Filter which Tasks to update
   */
  where?: Prisma.TaskWhereInput
  /**
   * Limit how many Tasks to update.
   */
  limit?: number
}

/**
 * Task updateManyAndReturn
 */
export type TaskUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * The data used to update Tasks.
   */
  data: Prisma.XOR<Prisma.TaskUpdateManyMutationInput, Prisma.TaskUncheckedUpdateManyInput>
  /**
   * Filter which Tasks to update
   */
  where?: Prisma.TaskWhereInput
  /**
   * Limit how many Tasks to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Task upsert
 */
export type TaskUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * The filter to search for the Task to update in case it exists.
   */
  where: Prisma.TaskWhereUniqueInput
  /**
   * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
   */
  create: Prisma.XOR<Prisma.TaskCreateInput, Prisma.TaskUncheckedCreateInput>
  /**
   * In case the Task was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.TaskUpdateInput, Prisma.TaskUncheckedUpdateInput>
}

/**
 * Task delete
 */
export type TaskDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
  /**
   * Filter which Task to delete.
   */
  where: Prisma.TaskWhereUniqueInput
}

/**
 * Task deleteMany
 */
export type TaskDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Tasks to delete
   */
  where?: Prisma.TaskWhereInput
  /**
   * Limit how many Tasks to delete.
   */
  limit?: number
}

/**
 * Task without action
 */
export type TaskDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Task
   */
  select?: Prisma.TaskSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Task
   */
  omit?: Prisma.TaskOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TaskInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\Task.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models\TimelineEvent.ts
TYPE: TS
SIZE: 59456 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `TimelineEvent` model and its related types.
 *
 * 游릭 You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model TimelineEvent
 * 
 */
export type TimelineEventModel = runtime.Types.Result.DefaultSelection<Prisma.$TimelineEventPayload>

export type AggregateTimelineEvent = {
  _count: TimelineEventCountAggregateOutputType | null
  _min: TimelineEventMinAggregateOutputType | null
  _max: TimelineEventMaxAggregateOutputType | null
}

export type TimelineEventMinAggregateOutputType = {
  id: string | null
  propertyId: string | null
  title: string | null
  description: string | null
  eventType: string | null
  startDate: Date | null
  endDate: Date | null
  isCompleted: boolean | null
  assignedTo: string | null
  createdAt: Date | null
}

export type TimelineEventMaxAggregateOutputType = {
  id: string | null
  propertyId: string | null
  title: string | null
  description: string | null
  eventType: string | null
  startDate: Date | null
  endDate: Date | null
  isCompleted: boolean | null
  assignedTo: string | null
  createdAt: Date | null
}

export type TimelineEventCountAggregateOutputType = {
  id: number
  propertyId: number
  title: number
  description: number
  eventType: number
  startDate: number
  endDate: number
  isCompleted: number
  assignedTo: number
  createdAt: number
  _all: number
}


export type TimelineEventMinAggregateInputType = {
  id?: true
  propertyId?: true
  title?: true
  description?: true
  eventType?: true
  startDate?: true
  endDate?: true
  isCompleted?: true
  assignedTo?: true
  createdAt?: true
}

export type TimelineEventMaxAggregateInputType = {
  id?: true
  propertyId?: true
  title?: true
  description?: true
  eventType?: true
  startDate?: true
  endDate?: true
  isCompleted?: true
  assignedTo?: true
  createdAt?: true
}

export type TimelineEventCountAggregateInputType = {
  id?: true
  propertyId?: true
  title?: true
  description?: true
  eventType?: true
  startDate?: true
  endDate?: true
  isCompleted?: true
  assignedTo?: true
  createdAt?: true
  _all?: true
}

export type TimelineEventAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which TimelineEvent to aggregate.
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TimelineEvents to fetch.
   */
  orderBy?: Prisma.TimelineEventOrderByWithRelationInput | Prisma.TimelineEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.TimelineEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` TimelineEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TimelineEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned TimelineEvents
  **/
  _count?: true | TimelineEventCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: TimelineEventMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: TimelineEventMaxAggregateInputType
}

export type GetTimelineEventAggregateType<T extends TimelineEventAggregateArgs> = {
      [P in keyof T & keyof AggregateTimelineEvent]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateTimelineEvent[P]>
    : Prisma.GetScalarType<T[P], AggregateTimelineEvent[P]>
}




export type TimelineEventGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TimelineEventWhereInput
  orderBy?: Prisma.TimelineEventOrderByWithAggregationInput | Prisma.TimelineEventOrderByWithAggregationInput[]
  by: Prisma.TimelineEventScalarFieldEnum[] | Prisma.TimelineEventScalarFieldEnum
  having?: Prisma.TimelineEventScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: TimelineEventCountAggregateInputType | true
  _min?: TimelineEventMinAggregateInputType
  _max?: TimelineEventMaxAggregateInputType
}

export type TimelineEventGroupByOutputType = {
  id: string
  propertyId: string
  title: string
  description: string
  eventType: string
  startDate: Date
  endDate: Date | null
  isCompleted: boolean
  assignedTo: string | null
  createdAt: Date
  _count: TimelineEventCountAggregateOutputType | null
  _min: TimelineEventMinAggregateOutputType | null
  _max: TimelineEventMaxAggregateOutputType | null
}

type GetTimelineEventGroupByPayload<T extends TimelineEventGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<TimelineEventGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof TimelineEventGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], TimelineEventGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], TimelineEventGroupByOutputType[P]>
      }
    >
  >



export type TimelineEventWhereInput = {
  AND?: Prisma.TimelineEventWhereInput | Prisma.TimelineEventWhereInput[]
  OR?: Prisma.TimelineEventWhereInput[]
  NOT?: Prisma.TimelineEventWhereInput | Prisma.TimelineEventWhereInput[]
  id?: Prisma.StringFilter<"TimelineEvent"> | string
  propertyId?: Prisma.StringFilter<"TimelineEvent"> | string
  title?: Prisma.StringFilter<"TimelineEvent"> | string
  description?: Prisma.StringFilter<"TimelineEvent"> | string
  eventType?: Prisma.StringFilter<"TimelineEvent"> | string
  startDate?: Prisma.DateTimeFilter<"TimelineEvent"> | Date | string
  endDate?: Prisma.DateTimeNullableFilter<"TimelineEvent"> | Date | string | null
  isCompleted?: Prisma.BoolFilter<"TimelineEvent"> | boolean
  assignedTo?: Prisma.StringNullableFilter<"TimelineEvent"> | string | null
  createdAt?: Prisma.DateTimeFilter<"TimelineEvent"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}

export type TimelineEventOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  eventType?: Prisma.SortOrder
  startDate?: Prisma.SortOrder
  endDate?: Prisma.SortOrderInput | Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  assignedTo?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  property?: Prisma.PropertyOrderByWithRelationInput
}

export type TimelineEventWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.TimelineEventWhereInput | Prisma.TimelineEventWhereInput[]
  OR?: Prisma.TimelineEventWhereInput[]
  NOT?: Prisma.TimelineEventWhereInput | Prisma.TimelineEventWhereInput[]
  propertyId?: Prisma.StringFilter<"TimelineEvent"> | string
  title?: Prisma.StringFilter<"TimelineEvent"> | string
  description?: Prisma.StringFilter<"TimelineEvent"> | string
  eventType?: Prisma.StringFilter<"TimelineEvent"> | string
  startDate?: Prisma.DateTimeFilter<"TimelineEvent"> | Date | string
  endDate?: Prisma.DateTimeNullableFilter<"TimelineEvent"> | Date | string | null
  isCompleted?: Prisma.BoolFilter<"TimelineEvent"> | boolean
  assignedTo?: Prisma.StringNullableFilter<"TimelineEvent"> | string | null
  createdAt?: Prisma.DateTimeFilter<"TimelineEvent"> | Date | string
  property?: Prisma.XOR<Prisma.PropertyScalarRelationFilter, Prisma.PropertyWhereInput>
}, "id">

export type TimelineEventOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  eventType?: Prisma.SortOrder
  startDate?: Prisma.SortOrder
  endDate?: Prisma.SortOrderInput | Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  assignedTo?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.TimelineEventCountOrderByAggregateInput
  _max?: Prisma.TimelineEventMaxOrderByAggregateInput
  _min?: Prisma.TimelineEventMinOrderByAggregateInput
}

export type TimelineEventScalarWhereWithAggregatesInput = {
  AND?: Prisma.TimelineEventScalarWhereWithAggregatesInput | Prisma.TimelineEventScalarWhereWithAggregatesInput[]
  OR?: Prisma.TimelineEventScalarWhereWithAggregatesInput[]
  NOT?: Prisma.TimelineEventScalarWhereWithAggregatesInput | Prisma.TimelineEventScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"TimelineEvent"> | string
  propertyId?: Prisma.StringWithAggregatesFilter<"TimelineEvent"> | string
  title?: Prisma.StringWithAggregatesFilter<"TimelineEvent"> | string
  description?: Prisma.StringWithAggregatesFilter<"TimelineEvent"> | string
  eventType?: Prisma.StringWithAggregatesFilter<"TimelineEvent"> | string
  startDate?: Prisma.DateTimeWithAggregatesFilter<"TimelineEvent"> | Date | string
  endDate?: Prisma.DateTimeNullableWithAggregatesFilter<"TimelineEvent"> | Date | string | null
  isCompleted?: Prisma.BoolWithAggregatesFilter<"TimelineEvent"> | boolean
  assignedTo?: Prisma.StringNullableWithAggregatesFilter<"TimelineEvent"> | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"TimelineEvent"> | Date | string
}

export type TimelineEventCreateInput = {
  id?: string
  title: string
  description?: string
  eventType: string
  startDate: Date | string
  endDate?: Date | string | null
  isCompleted?: boolean
  assignedTo?: string | null
  createdAt?: Date | string
  property: Prisma.PropertyCreateNestedOneWithoutTimelineEventsInput
}

export type TimelineEventUncheckedCreateInput = {
  id?: string
  propertyId: string
  title: string
  description?: string
  eventType: string
  startDate: Date | string
  endDate?: Date | string | null
  isCompleted?: boolean
  assignedTo?: string | null
  createdAt?: Date | string
}

export type TimelineEventUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  property?: Prisma.PropertyUpdateOneRequiredWithoutTimelineEventsNestedInput
}

export type TimelineEventUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TimelineEventCreateManyInput = {
  id?: string
  propertyId: string
  title: string
  description?: string
  eventType: string
  startDate: Date | string
  endDate?: Date | string | null
  isCompleted?: boolean
  assignedTo?: string | null
  createdAt?: Date | string
}

export type TimelineEventUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TimelineEventUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  propertyId?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TimelineEventListRelationFilter = {
  every?: Prisma.TimelineEventWhereInput
  some?: Prisma.TimelineEventWhereInput
  none?: Prisma.TimelineEventWhereInput
}

export type TimelineEventOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type TimelineEventCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  eventType?: Prisma.SortOrder
  startDate?: Prisma.SortOrder
  endDate?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  assignedTo?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type TimelineEventMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  eventType?: Prisma.SortOrder
  startDate?: Prisma.SortOrder
  endDate?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  assignedTo?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type TimelineEventMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  propertyId?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  eventType?: Prisma.SortOrder
  startDate?: Prisma.SortOrder
  endDate?: Prisma.SortOrder
  isCompleted?: Prisma.SortOrder
  assignedTo?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type TimelineEventCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.TimelineEventCreateWithoutPropertyInput, Prisma.TimelineEventUncheckedCreateWithoutPropertyInput> | Prisma.TimelineEventCreateWithoutPropertyInput[] | Prisma.TimelineEventUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TimelineEventCreateOrConnectWithoutPropertyInput | Prisma.TimelineEventCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.TimelineEventCreateManyPropertyInputEnvelope
  connect?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
}

export type TimelineEventUncheckedCreateNestedManyWithoutPropertyInput = {
  create?: Prisma.XOR<Prisma.TimelineEventCreateWithoutPropertyInput, Prisma.TimelineEventUncheckedCreateWithoutPropertyInput> | Prisma.TimelineEventCreateWithoutPropertyInput[] | Prisma.TimelineEventUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TimelineEventCreateOrConnectWithoutPropertyInput | Prisma.TimelineEventCreateOrConnectWithoutPropertyInput[]
  createMany?: Prisma.TimelineEventCreateManyPropertyInputEnvelope
  connect?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
}

export type TimelineEventUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.TimelineEventCreateWithoutPropertyInput, Prisma.TimelineEventUncheckedCreateWithoutPropertyInput> | Prisma.TimelineEventCreateWithoutPropertyInput[] | Prisma.TimelineEventUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TimelineEventCreateOrConnectWithoutPropertyInput | Prisma.TimelineEventCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.TimelineEventUpsertWithWhereUniqueWithoutPropertyInput | Prisma.TimelineEventUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.TimelineEventCreateManyPropertyInputEnvelope
  set?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  disconnect?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  delete?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  connect?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  update?: Prisma.TimelineEventUpdateWithWhereUniqueWithoutPropertyInput | Prisma.TimelineEventUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.TimelineEventUpdateManyWithWhereWithoutPropertyInput | Prisma.TimelineEventUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.TimelineEventScalarWhereInput | Prisma.TimelineEventScalarWhereInput[]
}

export type TimelineEventUncheckedUpdateManyWithoutPropertyNestedInput = {
  create?: Prisma.XOR<Prisma.TimelineEventCreateWithoutPropertyInput, Prisma.TimelineEventUncheckedCreateWithoutPropertyInput> | Prisma.TimelineEventCreateWithoutPropertyInput[] | Prisma.TimelineEventUncheckedCreateWithoutPropertyInput[]
  connectOrCreate?: Prisma.TimelineEventCreateOrConnectWithoutPropertyInput | Prisma.TimelineEventCreateOrConnectWithoutPropertyInput[]
  upsert?: Prisma.TimelineEventUpsertWithWhereUniqueWithoutPropertyInput | Prisma.TimelineEventUpsertWithWhereUniqueWithoutPropertyInput[]
  createMany?: Prisma.TimelineEventCreateManyPropertyInputEnvelope
  set?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  disconnect?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  delete?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  connect?: Prisma.TimelineEventWhereUniqueInput | Prisma.TimelineEventWhereUniqueInput[]
  update?: Prisma.TimelineEventUpdateWithWhereUniqueWithoutPropertyInput | Prisma.TimelineEventUpdateWithWhereUniqueWithoutPropertyInput[]
  updateMany?: Prisma.TimelineEventUpdateManyWithWhereWithoutPropertyInput | Prisma.TimelineEventUpdateManyWithWhereWithoutPropertyInput[]
  deleteMany?: Prisma.TimelineEventScalarWhereInput | Prisma.TimelineEventScalarWhereInput[]
}

export type TimelineEventCreateWithoutPropertyInput = {
  id?: string
  title: string
  description?: string
  eventType: string
  startDate: Date | string
  endDate?: Date | string | null
  isCompleted?: boolean
  assignedTo?: string | null
  createdAt?: Date | string
}

export type TimelineEventUncheckedCreateWithoutPropertyInput = {
  id?: string
  title: string
  description?: string
  eventType: string
  startDate: Date | string
  endDate?: Date | string | null
  isCompleted?: boolean
  assignedTo?: string | null
  createdAt?: Date | string
}

export type TimelineEventCreateOrConnectWithoutPropertyInput = {
  where: Prisma.TimelineEventWhereUniqueInput
  create: Prisma.XOR<Prisma.TimelineEventCreateWithoutPropertyInput, Prisma.TimelineEventUncheckedCreateWithoutPropertyInput>
}

export type TimelineEventCreateManyPropertyInputEnvelope = {
  data: Prisma.TimelineEventCreateManyPropertyInput | Prisma.TimelineEventCreateManyPropertyInput[]
  skipDuplicates?: boolean
}

export type TimelineEventUpsertWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.TimelineEventWhereUniqueInput
  update: Prisma.XOR<Prisma.TimelineEventUpdateWithoutPropertyInput, Prisma.TimelineEventUncheckedUpdateWithoutPropertyInput>
  create: Prisma.XOR<Prisma.TimelineEventCreateWithoutPropertyInput, Prisma.TimelineEventUncheckedCreateWithoutPropertyInput>
}

export type TimelineEventUpdateWithWhereUniqueWithoutPropertyInput = {
  where: Prisma.TimelineEventWhereUniqueInput
  data: Prisma.XOR<Prisma.TimelineEventUpdateWithoutPropertyInput, Prisma.TimelineEventUncheckedUpdateWithoutPropertyInput>
}

export type TimelineEventUpdateManyWithWhereWithoutPropertyInput = {
  where: Prisma.TimelineEventScalarWhereInput
  data: Prisma.XOR<Prisma.TimelineEventUpdateManyMutationInput, Prisma.TimelineEventUncheckedUpdateManyWithoutPropertyInput>
}

export type TimelineEventScalarWhereInput = {
  AND?: Prisma.TimelineEventScalarWhereInput | Prisma.TimelineEventScalarWhereInput[]
  OR?: Prisma.TimelineEventScalarWhereInput[]
  NOT?: Prisma.TimelineEventScalarWhereInput | Prisma.TimelineEventScalarWhereInput[]
  id?: Prisma.StringFilter<"TimelineEvent"> | string
  propertyId?: Prisma.StringFilter<"TimelineEvent"> | string
  title?: Prisma.StringFilter<"TimelineEvent"> | string
  description?: Prisma.StringFilter<"TimelineEvent"> | string
  eventType?: Prisma.StringFilter<"TimelineEvent"> | string
  startDate?: Prisma.DateTimeFilter<"TimelineEvent"> | Date | string
  endDate?: Prisma.DateTimeNullableFilter<"TimelineEvent"> | Date | string | null
  isCompleted?: Prisma.BoolFilter<"TimelineEvent"> | boolean
  assignedTo?: Prisma.StringNullableFilter<"TimelineEvent"> | string | null
  createdAt?: Prisma.DateTimeFilter<"TimelineEvent"> | Date | string
}

export type TimelineEventCreateManyPropertyInput = {
  id?: string
  title: string
  description?: string
  eventType: string
  startDate: Date | string
  endDate?: Date | string | null
  isCompleted?: boolean
  assignedTo?: string | null
  createdAt?: Date | string
}

export type TimelineEventUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TimelineEventUncheckedUpdateWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TimelineEventUncheckedUpdateManyWithoutPropertyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  eventType?: Prisma.StringFieldUpdateOperationsInput | string
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  endDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedTo?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type TimelineEventSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  title?: boolean
  description?: boolean
  eventType?: boolean
  startDate?: boolean
  endDate?: boolean
  isCompleted?: boolean
  assignedTo?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["timelineEvent"]>

export type TimelineEventSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  title?: boolean
  description?: boolean
  eventType?: boolean
  startDate?: boolean
  endDate?: boolean
  isCompleted?: boolean
  assignedTo?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["timelineEvent"]>

export type TimelineEventSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  propertyId?: boolean
  title?: boolean
  description?: boolean
  eventType?: boolean
  startDate?: boolean
  endDate?: boolean
  isCompleted?: boolean
  assignedTo?: boolean
  createdAt?: boolean
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["timelineEvent"]>

export type TimelineEventSelectScalar = {
  id?: boolean
  propertyId?: boolean
  title?: boolean
  description?: boolean
  eventType?: boolean
  startDate?: boolean
  endDate?: boolean
  isCompleted?: boolean
  assignedTo?: boolean
  createdAt?: boolean
}

export type TimelineEventOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "propertyId" | "title" | "description" | "eventType" | "startDate" | "endDate" | "isCompleted" | "assignedTo" | "createdAt", ExtArgs["result"]["timelineEvent"]>
export type TimelineEventInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type TimelineEventIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}
export type TimelineEventIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  property?: boolean | Prisma.PropertyDefaultArgs<ExtArgs>
}

export type $TimelineEventPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "TimelineEvent"
  objects: {
    property: Prisma.$PropertyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    propertyId: string
    title: string
    description: string
    eventType: string
    startDate: Date
    endDate: Date | null
    isCompleted: boolean
    assignedTo: string | null
    createdAt: Date
  }, ExtArgs["result"]["timelineEvent"]>
  composites: {}
}

export type TimelineEventGetPayload<S extends boolean | null | undefined | TimelineEventDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload, S>

export type TimelineEventCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<TimelineEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TimelineEventCountAggregateInputType | true
  }

export interface TimelineEventDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimelineEvent'], meta: { name: 'TimelineEvent' } }
  /**
   * Find zero or one TimelineEvent that matches the filter.
   * @param {TimelineEventFindUniqueArgs} args - Arguments to find a TimelineEvent
   * @example
   * // Get one TimelineEvent
   * const timelineEvent = await prisma.timelineEvent.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends TimelineEventFindUniqueArgs>(args: Prisma.SelectSubset<T, TimelineEventFindUniqueArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one TimelineEvent that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {TimelineEventFindUniqueOrThrowArgs} args - Arguments to find a TimelineEvent
   * @example
   * // Get one TimelineEvent
   * const timelineEvent = await prisma.timelineEvent.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends TimelineEventFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, TimelineEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first TimelineEvent that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventFindFirstArgs} args - Arguments to find a TimelineEvent
   * @example
   * // Get one TimelineEvent
   * const timelineEvent = await prisma.timelineEvent.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends TimelineEventFindFirstArgs>(args?: Prisma.SelectSubset<T, TimelineEventFindFirstArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first TimelineEvent that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventFindFirstOrThrowArgs} args - Arguments to find a TimelineEvent
   * @example
   * // Get one TimelineEvent
   * const timelineEvent = await prisma.timelineEvent.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends TimelineEventFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, TimelineEventFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more TimelineEvents that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all TimelineEvents
   * const timelineEvents = await prisma.timelineEvent.findMany()
   * 
   * // Get first 10 TimelineEvents
   * const timelineEvents = await prisma.timelineEvent.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const timelineEventWithIdOnly = await prisma.timelineEvent.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends TimelineEventFindManyArgs>(args?: Prisma.SelectSubset<T, TimelineEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a TimelineEvent.
   * @param {TimelineEventCreateArgs} args - Arguments to create a TimelineEvent.
   * @example
   * // Create one TimelineEvent
   * const TimelineEvent = await prisma.timelineEvent.create({
   *   data: {
   *     // ... data to create a TimelineEvent
   *   }
   * })
   * 
   */
  create<T extends TimelineEventCreateArgs>(args: Prisma.SelectSubset<T, TimelineEventCreateArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many TimelineEvents.
   * @param {TimelineEventCreateManyArgs} args - Arguments to create many TimelineEvents.
   * @example
   * // Create many TimelineEvents
   * const timelineEvent = await prisma.timelineEvent.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends TimelineEventCreateManyArgs>(args?: Prisma.SelectSubset<T, TimelineEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many TimelineEvents and returns the data saved in the database.
   * @param {TimelineEventCreateManyAndReturnArgs} args - Arguments to create many TimelineEvents.
   * @example
   * // Create many TimelineEvents
   * const timelineEvent = await prisma.timelineEvent.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many TimelineEvents and only return the `id`
   * const timelineEventWithIdOnly = await prisma.timelineEvent.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends TimelineEventCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, TimelineEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a TimelineEvent.
   * @param {TimelineEventDeleteArgs} args - Arguments to delete one TimelineEvent.
   * @example
   * // Delete one TimelineEvent
   * const TimelineEvent = await prisma.timelineEvent.delete({
   *   where: {
   *     // ... filter to delete one TimelineEvent
   *   }
   * })
   * 
   */
  delete<T extends TimelineEventDeleteArgs>(args: Prisma.SelectSubset<T, TimelineEventDeleteArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one TimelineEvent.
   * @param {TimelineEventUpdateArgs} args - Arguments to update one TimelineEvent.
   * @example
   * // Update one TimelineEvent
   * const timelineEvent = await prisma.timelineEvent.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends TimelineEventUpdateArgs>(args: Prisma.SelectSubset<T, TimelineEventUpdateArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more TimelineEvents.
   * @param {TimelineEventDeleteManyArgs} args - Arguments to filter TimelineEvents to delete.
   * @example
   * // Delete a few TimelineEvents
   * const { count } = await prisma.timelineEvent.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends TimelineEventDeleteManyArgs>(args?: Prisma.SelectSubset<T, TimelineEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more TimelineEvents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many TimelineEvents
   * const timelineEvent = await prisma.timelineEvent.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends TimelineEventUpdateManyArgs>(args: Prisma.SelectSubset<T, TimelineEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more TimelineEvents and returns the data updated in the database.
   * @param {TimelineEventUpdateManyAndReturnArgs} args - Arguments to update many TimelineEvents.
   * @example
   * // Update many TimelineEvents
   * const timelineEvent = await prisma.timelineEvent.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more TimelineEvents and only return the `id`
   * const timelineEventWithIdOnly = await prisma.timelineEvent.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends TimelineEventUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, TimelineEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one TimelineEvent.
   * @param {TimelineEventUpsertArgs} args - Arguments to update or create a TimelineEvent.
   * @example
   * // Update or create a TimelineEvent
   * const timelineEvent = await prisma.timelineEvent.upsert({
   *   create: {
   *     // ... data to create a TimelineEvent
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the TimelineEvent we want to update
   *   }
   * })
   */
  upsert<T extends TimelineEventUpsertArgs>(args: Prisma.SelectSubset<T, TimelineEventUpsertArgs<ExtArgs>>): Prisma.Prisma__TimelineEventClient<runtime.Types.Result.GetResult<Prisma.$TimelineEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of TimelineEvents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventCountArgs} args - Arguments to filter TimelineEvents to count.
   * @example
   * // Count the number of TimelineEvents
   * const count = await prisma.timelineEvent.count({
   *   where: {
   *     // ... the filter for the TimelineEvents we want to count
   *   }
   * })
  **/
  count<T extends TimelineEventCountArgs>(
    args?: Prisma.Subset<T, TimelineEventCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], TimelineEventCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a TimelineEvent.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends TimelineEventAggregateArgs>(args: Prisma.Subset<T, TimelineEventAggregateArgs>): Prisma.PrismaPromise<GetTimelineEventAggregateType<T>>

  /**
   * Group by TimelineEvent.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TimelineEventGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends TimelineEventGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: TimelineEventGroupByArgs['orderBy'] }
      : { orderBy?: TimelineEventGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, TimelineEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the TimelineEvent model
 */
readonly fields: TimelineEventFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for TimelineEvent.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TimelineEventClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  property<T extends Prisma.PropertyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PropertyDefaultArgs<ExtArgs>>): Prisma.Prisma__PropertyClient<runtime.Types.Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the TimelineEvent model
 */
export interface TimelineEventFieldRefs {
  readonly id: Prisma.FieldRef<"TimelineEvent", 'String'>
  readonly propertyId: Prisma.FieldRef<"TimelineEvent", 'String'>
  readonly title: Prisma.FieldRef<"TimelineEvent", 'String'>
  readonly description: Prisma.FieldRef<"TimelineEvent", 'String'>
  readonly eventType: Prisma.FieldRef<"TimelineEvent", 'String'>
  readonly startDate: Prisma.FieldRef<"TimelineEvent", 'DateTime'>
  readonly endDate: Prisma.FieldRef<"TimelineEvent", 'DateTime'>
  readonly isCompleted: Prisma.FieldRef<"TimelineEvent", 'Boolean'>
  readonly assignedTo: Prisma.FieldRef<"TimelineEvent", 'String'>
  readonly createdAt: Prisma.FieldRef<"TimelineEvent", 'DateTime'>
}
    

// Custom InputTypes
/**
 * TimelineEvent findUnique
 */
export type TimelineEventFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * Filter, which TimelineEvent to fetch.
   */
  where: Prisma.TimelineEventWhereUniqueInput
}

/**
 * TimelineEvent findUniqueOrThrow
 */
export type TimelineEventFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * Filter, which TimelineEvent to fetch.
   */
  where: Prisma.TimelineEventWhereUniqueInput
}

/**
 * TimelineEvent findFirst
 */
export type TimelineEventFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * Filter, which TimelineEvent to fetch.
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TimelineEvents to fetch.
   */
  orderBy?: Prisma.TimelineEventOrderByWithRelationInput | Prisma.TimelineEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for TimelineEvents.
   */
  cursor?: Prisma.TimelineEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` TimelineEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TimelineEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of TimelineEvents.
   */
  distinct?: Prisma.TimelineEventScalarFieldEnum | Prisma.TimelineEventScalarFieldEnum[]
}

/**
 * TimelineEvent findFirstOrThrow
 */
export type TimelineEventFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * Filter, which TimelineEvent to fetch.
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TimelineEvents to fetch.
   */
  orderBy?: Prisma.TimelineEventOrderByWithRelationInput | Prisma.TimelineEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for TimelineEvents.
   */
  cursor?: Prisma.TimelineEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` TimelineEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TimelineEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of TimelineEvents.
   */
  distinct?: Prisma.TimelineEventScalarFieldEnum | Prisma.TimelineEventScalarFieldEnum[]
}

/**
 * TimelineEvent findMany
 */
export type TimelineEventFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * Filter, which TimelineEvents to fetch.
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of TimelineEvents to fetch.
   */
  orderBy?: Prisma.TimelineEventOrderByWithRelationInput | Prisma.TimelineEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing TimelineEvents.
   */
  cursor?: Prisma.TimelineEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `췀n` TimelineEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` TimelineEvents.
   */
  skip?: number
  distinct?: Prisma.TimelineEventScalarFieldEnum | Prisma.TimelineEventScalarFieldEnum[]
}

/**
 * TimelineEvent create
 */
export type TimelineEventCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * The data needed to create a TimelineEvent.
   */
  data: Prisma.XOR<Prisma.TimelineEventCreateInput, Prisma.TimelineEventUncheckedCreateInput>
}

/**
 * TimelineEvent createMany
 */
export type TimelineEventCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many TimelineEvents.
   */
  data: Prisma.TimelineEventCreateManyInput | Prisma.TimelineEventCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * TimelineEvent createManyAndReturn
 */
export type TimelineEventCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * The data used to create many TimelineEvents.
   */
  data: Prisma.TimelineEventCreateManyInput | Prisma.TimelineEventCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * TimelineEvent update
 */
export type TimelineEventUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * The data needed to update a TimelineEvent.
   */
  data: Prisma.XOR<Prisma.TimelineEventUpdateInput, Prisma.TimelineEventUncheckedUpdateInput>
  /**
   * Choose, which TimelineEvent to update.
   */
  where: Prisma.TimelineEventWhereUniqueInput
}

/**
 * TimelineEvent updateMany
 */
export type TimelineEventUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update TimelineEvents.
   */
  data: Prisma.XOR<Prisma.TimelineEventUpdateManyMutationInput, Prisma.TimelineEventUncheckedUpdateManyInput>
  /**
   * Filter which TimelineEvents to update
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * Limit how many TimelineEvents to update.
   */
  limit?: number
}

/**
 * TimelineEvent updateManyAndReturn
 */
export type TimelineEventUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * The data used to update TimelineEvents.
   */
  data: Prisma.XOR<Prisma.TimelineEventUpdateManyMutationInput, Prisma.TimelineEventUncheckedUpdateManyInput>
  /**
   * Filter which TimelineEvents to update
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * Limit how many TimelineEvents to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * TimelineEvent upsert
 */
export type TimelineEventUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * The filter to search for the TimelineEvent to update in case it exists.
   */
  where: Prisma.TimelineEventWhereUniqueInput
  /**
   * In case the TimelineEvent found by the `where` argument doesn't exist, create a new TimelineEvent with this data.
   */
  create: Prisma.XOR<Prisma.TimelineEventCreateInput, Prisma.TimelineEventUncheckedCreateInput>
  /**
   * In case the TimelineEvent was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.TimelineEventUpdateInput, Prisma.TimelineEventUncheckedUpdateInput>
}

/**
 * TimelineEvent delete
 */
export type TimelineEventDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
  /**
   * Filter which TimelineEvent to delete.
   */
  where: Prisma.TimelineEventWhereUniqueInput
}

/**
 * TimelineEvent deleteMany
 */
export type TimelineEventDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which TimelineEvents to delete
   */
  where?: Prisma.TimelineEventWhereInput
  /**
   * Limit how many TimelineEvents to delete.
   */
  limit?: number
}

/**
 * TimelineEvent without action
 */
export type TimelineEventDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TimelineEvent
   */
  select?: Prisma.TimelineEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the TimelineEvent
   */
  omit?: Prisma.TimelineEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TimelineEventInclude<ExtArgs> | null
}


[FILE_END: src\generated\models\TimelineEvent.ts]
################################################################################

================================================================================
FILE_BEGIN: src\generated\models.ts
TYPE: TS
SIZE: 707 bytes
================================================================================

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This is a barrel export file for all models and their related types.
 *
 * 游릭 You can import this file directly.
 */
export type * from './models/Property'
export type * from './models/Expense'
export type * from './models/Task'
export type * from './models/RehabItem'
export type * from './models/MarketData'
export type * from './models/RentComp'
export type * from './models/Projection'
export type * from './models/TimelineEvent'
export type * from './models/Comment'
export type * from './models/Document'
export type * from './commonInputTypes'

[FILE_END: src\generated\models.ts]
################################################################################

================================================================================
FILE_BEGIN: src\lib\calculations.ts
TYPE: TS
SIZE: 5187 bytes
================================================================================
/**
 * Shared Calculation Utilities
 * Single source of truth for property calculations used by both server and client.
 */

import {
  calculateCapRate,
  calculateCashOnCashReturn,
  calculateMAO,
  calculateOnePercentRule,
  calculateGrossYield,
  Decision,
  Strategy,
} from '@/data/properties';

// Re-export Decision and Strategy for convenience
export type { Decision, Strategy } from '@/data/properties';

/**
 * Base property interface that matches Prisma schema (with Date objects)
 * Uses string types for decision and strategy since Prisma stores them as strings.
 * The frontend should validate/cast these to the proper union types when needed.
 */
export interface PropertyBase {
  id: string;
  address: string;
  city: string;
  state: string;
  zip: string;
  lat: number;
  lng: number;
  listPrice: number;
  equityGap: number;
  sqft: number;
  bedrooms: number;
  bathrooms: number;
  decision: string;  // Stored as string in DB, cast to Decision type when needed
  strategy: string;  // Stored as string in DB, cast to Strategy type when needed
  rationale: string;
  type: string;
  realtor: string | null;
  url: string | null;
  details: string | null;
  images: string[];
  estimatedRent: number;
  annualTaxes: number;
  annualInsurance: number;
  renovationBudget: number;
  afterRepairValue: number;
  notes: string;
  // Extended fields from database schema
  isOwned: boolean;
  purchasePrice: number;
  purchaseDate: Date | string | null;
  rehabCompleted: Date | string | null;
  isFavorite: boolean;
  favoriteNotes: string;
  dealScore: number;
  riskLevel: string;
  createdAt: Date | string;
  updatedAt: Date | string;
}

/**
 * Interface for properties with calculated fields
 * Uses string types for decision/strategy to match Prisma storage.
 */
export interface PropertyWithCalculations extends PropertyBase {
  pricePerSqft: number;
  pricePerDoor: number;
  capRate: number;
  cashOnCashReturn: number;
  mao: number;
  onePercentRule: boolean;
  grossYield: number;
  // Type-safe accessors - cast to proper types when needed
  decision: string;
  strategy: string;
}

/**
 * Add calculated fields to a property object.
 * This is the SINGLE source of truth for all property calculations.
 * Used by both the API route and the client-side context.
 * 
 * @param property - The base property object (can be from Prisma or client)
 * @returns Property with all calculated fields added
 */
export function addCalculations<T extends PropertyBase>(property: T): PropertyWithCalculations {
  // Ensure numeric values are valid (defensive coding)
  const listPrice = property.listPrice ?? 0;
  const sqft = property.sqft ?? 0;
  const bedrooms = property.bedrooms ?? 0;

  return {
    ...property,
    // Price per square foot (0 if sqft is 0 or negative)
    pricePerSqft: sqft > 0 ? Number((listPrice / sqft).toFixed(2)) : 0,
    // Price per bedroom/door (0 if bedrooms is 0 or negative)
    pricePerDoor: bedrooms > 0 ? Number((listPrice / bedrooms).toFixed(2)) : 0,
    // Cap rate calculation
    capRate: Number(calculateCapRate(property as any).toFixed(2)),
    // Cash on cash return calculation
    cashOnCashReturn: Number(calculateCashOnCashReturn(property as any).toFixed(2)),
    // Maximum Allowable Offer
    mao: Number(calculateMAO(property as any).toFixed(2)),
    // 1% rule check (rent >= 1% of purchase price)
    onePercentRule: calculateOnePercentRule(property as any),
    // Gross yield calculation
    grossYield: Number(calculateGrossYield(property as any).toFixed(2)),
  };
}

/**
 * Add calculations to an array of properties.
 * Convenience function for batch processing.
 * 
 * @param properties - Array of base property objects
 * @returns Array of properties with calculated fields
 */
export function addCalculationsToAll<T extends PropertyBase>(
  properties: T[]
): PropertyWithCalculations[] {
  if (!properties || !Array.isArray(properties)) {
    return [];
  }
  return properties.map(addCalculations);
}

/**
 * Serialize a property for client-side usage.
 * Converts Date objects to ISO strings for JSON serialization.
 * 
 * @param property - Property from Prisma (with Date objects)
 * @returns Property with dates as ISO strings
 */
export function serializeProperty<T extends { createdAt: Date; updatedAt: Date }>(
  property: T
): Omit<T, 'createdAt' | 'updatedAt'> & { createdAt: string; updatedAt: string } {
  return {
    ...property,
    createdAt: property.createdAt instanceof Date 
      ? property.createdAt.toISOString() 
      : String(property.createdAt),
    updatedAt: property.updatedAt instanceof Date 
      ? property.updatedAt.toISOString() 
      : String(property.updatedAt),
  };
}

/**
 * Serialize an array of properties for client-side usage.
 * 
 * @param properties - Array of properties from Prisma
 * @returns Array of properties with dates as ISO strings
 */
export function serializeProperties<T extends { createdAt: Date; updatedAt: Date }>(
  properties: T[]
): Array<Omit<T, 'createdAt' | 'updatedAt'> & { createdAt: string; updatedAt: string }> {
  if (!properties || !Array.isArray(properties)) {
    return [];
  }
  return properties.map(serializeProperty);
}


[FILE_END: src\lib\calculations.ts]
################################################################################

================================================================================
FILE_BEGIN: tests\basic.spec.ts
TYPE: TS
SIZE: 1921 bytes
================================================================================
import { test, expect } from '@playwright/test';

test.describe('Homepage Tests', () => {
  test('should load homepage successfully', async ({ page }) => {
    await page.goto('/');
    await expect(page).toHaveTitle(/Property Investment Tracker/i);
  });

  test('should have main navigation', async ({ page }) => {
    await page.goto('/');
    const nav = page.locator('nav');
    await expect(nav).toBeVisible();
  });

  test('should display property data', async ({ page }) => {
    await page.goto('/');
    // Wait for any content to load
    await page.waitForSelector('body', { state: 'visible' });
    const body = page.locator('body');
    await expect(body).toBeVisible();
  });
});

test.describe('Responsive Design Tests', () => {
  test('should be mobile-friendly', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    await expect(page).toHaveTitle(/Property Investment Tracker/i);
  });

  test('should work on tablet', async ({ page }) => {
    await page.setViewportSize({ width: 1024, height: 768 });
    await page.goto('/');
    await expect(page).toHaveTitle(/Property Investment Tracker/i);
  });

  test('should work on desktop', async ({ page }) => {
    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.goto('/');
    await expect(page).toHaveTitle(/Property Investment Tracker/i);
  });
});

test.describe('Accessibility Tests', () => {
  test('should have proper heading structure', async ({ page }) => {
    await page.goto('/');
    const h1 = page.locator('h1');
    await expect(h1).toBeVisible();
  });

  test('should support keyboard navigation', async ({ page }) => {
    await page.goto('/');
    await page.keyboard.press('Tab');
    const focusedElement = page.locator(':focus');
    await expect(focusedElement).toBeVisible();
  });
});


[FILE_END: tests\basic.spec.ts]
################################################################################
